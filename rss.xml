<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当时只道是寻常</title>
  
  
  <link href="https://revival-of-hope.github.io/rss.xml" rel="self"/>
  
  <link href="https://revival-of-hope.github.io/"/>
  <updated>2026-01-21T03:47:13.687Z</updated>
  <id>https://revival-of-hope.github.io/</id>
  
  <author>
    <name>Revival-of-hope</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2026-01-21 python重学-源码剖析</title>
    <link href="https://revival-of-hope.github.io/2026/01/21/python%E9%87%8D%E5%AD%A6-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>https://revival-of-hope.github.io/2026/01/21/python%E9%87%8D%E5%AD%A6-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2026-01-21T00:00:00.000Z</published>
    <updated>2026-01-21T03:47:13.687Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考书籍:(python源码剖析:深度探索动态语言核心技术),本书围绕的是06年的python2.5.0</strong></p><h2 id="概览includeobjecth"><a class="markdownIt-Anchor" href="#概览includeobjecth"></a> 概览(include/object.h)</h2><blockquote><p>我觉得python最明显的优点是自动内存管理,不需要进行垃圾收集,减少了写代码的各种烦恼</p></blockquote><h3 id="pyobject"><a class="markdownIt-Anchor" href="#pyobject"></a> pyobject</h3><blockquote><p>python中所有对象和类型都用pyobject指针类型来表示,可以通过将指针指向不同的内存区域来实现内存区域的扩张与收缩,这也是python之所以能够称为动态语言的本钱,其中pyobject定义如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA\</span></span><br><span class="line"><span class="meta">struct _object *_ob_next;\</span></span><br><span class="line"><span class="meta">struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD\</span></span><br><span class="line"><span class="meta">_PyObject_HEAD_EXTRA\</span></span><br><span class="line"><span class="meta">Py_ssize_t ob_refcnt;\</span></span><br><span class="line"><span class="meta">struct _typeobject *ob_type;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">PyObject_HEAD</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><ul><li>这里的Py_ssize_t实际上就是 long long,我就说世界是一个巨大的草台班子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">ssize_t</span>Py_ssize_t;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">typedef</span> __int64 <span class="type">ssize_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>而每次pyobject对象A被引用时,引用计数就增加1,当引用对象被删除时,引用计数就减小1,减小到零时就会从堆上被删除</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_INC_REFTOTAL_Py_RefTotal++</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_DEC_REFTOTAL_Py_RefTotal--</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) (\</span></span><br><span class="line"><span class="meta">_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA\</span></span><br><span class="line"><span class="meta">(op)-&gt;ob_refcnt++)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD\</span></span><br><span class="line"><span class="meta">PyObject_HEAD\</span></span><br><span class="line"><span class="meta">Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">PyObject_VAR_HEAD</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到python里还有一类PyVarObject,用来管理可变长度的容器对象</p></blockquote><p><img src="/images/2026-01-21/PixPin_2026-01-21_11-23-40.webp" alt="alt text" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;参考书籍:(python源码剖析:深度探索动态语言核心技术),本书围绕的是06年的python2.5.0&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览includeobjecth&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概</summary>
      
    
    
    
    
    <category term="python" scheme="https://revival-of-hope.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-19 python重学-语法</title>
    <link href="https://revival-of-hope.github.io/2026/01/19/python%E9%87%8D%E5%AD%A6/"/>
    <id>https://revival-of-hope.github.io/2026/01/19/python%E9%87%8D%E5%AD%A6/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-01-21T06:55:43.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><blockquote><p>所有变量都无需指明类型,统一作为一个可变指针对象,可以随时改变值和内存大小</p></blockquote><h3 id="顺序结构"><a class="markdownIt-Anchor" href="#顺序结构"></a> 顺序结构</h3><h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python list</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 / 修改</span></span><br><span class="line">x = a[<span class="number">0</span>]</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度</span></span><br><span class="line">n = <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加</span></span><br><span class="line">a.append(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line">a.insert(<span class="number">1</span>, <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">a.pop()</span><br><span class="line">a.pop(<span class="number">1</span>)</span><br><span class="line">a.remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片 list[start:end:step]</span></span><br><span class="line">b = a[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">c = a[:<span class="number">3</span>]</span><br><span class="line">d = a[::<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找</span></span><br><span class="line">flag = <span class="number">3</span> <span class="keyword">in</span> a</span><br><span class="line">idx = a.index(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序 / 反转</span></span><br><span class="line">a.sort()</span><br><span class="line">a.reverse()</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ array + vector</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 / 修改</span></span><br><span class="line">    <span class="type">int</span> x = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">int</span> n_arr = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_arr; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : arr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 / 修改</span></span><br><span class="line">    <span class="type">int</span> y = v[<span class="number">0</span>];</span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">int</span> n_vec = v.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    v.<span class="built_in">pop_back</span>();</span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="type">bool</span> found = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>) != v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序 / 反转</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很显然两个语言都是T.method,function(T)这样混着用的,真的不好记啊<br />当然也可以解释说function是作为外部函数,并非单独一个数据结构的对象</p></blockquote><blockquote><p>看得出来python的index也是左闭右开的</p></blockquote><h4 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">tup2=(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">tup3=tup1+tup3</span><br></pre></td></tr></table></figure><blockquote><p>没什么好解释的,就是不可变的列表而已,相当于加了const,但是可以转换成list,元组之间也能连接</p></blockquote><h4 id="dict"><a class="markdownIt-Anchor" href="#dict"></a> dict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python dict（字典）示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">d = &#123;<span class="string">&quot;apple&quot;</span>: <span class="number">3</span>, <span class="string">&quot;banana&quot;</span>: <span class="number">5</span>, <span class="string">&quot;cherry&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">d2 = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">x = d[<span class="string">&quot;apple&quot;</span>]      <span class="comment"># 3</span></span><br><span class="line">y = d.get(<span class="string">&quot;banana&quot;</span>) <span class="comment"># 5</span></span><br><span class="line">z = d.get(<span class="string">&quot;orange&quot;</span>, <span class="number">0</span>) <span class="comment"># 指定默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 / 添加</span></span><br><span class="line">d[<span class="string">&quot;apple&quot;</span>] = <span class="number">10</span></span><br><span class="line">d[<span class="string">&quot;orange&quot;</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;banana&quot;</span>]</span><br><span class="line">val = d.pop(<span class="string">&quot;cherry&quot;</span>)     <span class="comment"># 删除并返回值</span></span><br><span class="line">val2 = d.pop(<span class="string">&quot;pear&quot;</span>, <span class="number">0</span>)   <span class="comment"># 指定默认返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(key, d[key])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查键是否存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;apple&quot;</span> <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;exists&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有键 / 值 / 项</span></span><br><span class="line">keys = d.keys()</span><br><span class="line">values = d.values()</span><br><span class="line">items = d.items()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并字典</span></span><br><span class="line">d3 = &#123;**d, **d2&#125;  <span class="comment"># Python 3.5+ 支持</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 map</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 插入元素</span></span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">    m[<span class="string">&quot;banana&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cherry&quot;</span>, <span class="number">2</span>&#125;);  <span class="comment">// 另一种插入方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 访问元素</span></span><br><span class="line">    <span class="type">int</span> x = m[<span class="string">&quot;apple&quot;</span>];      <span class="comment">// 如果 key 不存在，会自动创建默认值 0</span></span><br><span class="line">    <span class="type">int</span> y = m.<span class="built_in">at</span>(<span class="string">&quot;banana&quot;</span>);  <span class="comment">// 如果 key 不存在，会抛出 out_of_range 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 修改元素</span></span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 删除元素</span></span><br><span class="line">    m.<span class="built_in">erase</span>(<span class="string">&quot;banana&quot;</span>);       <span class="comment">// 删除指定 key</span></span><br><span class="line">    <span class="comment">// m.clear();            // 删除所有元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 遍历 map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : m) &#123;</span><br><span class="line">        cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;cherry&quot;</span>);  <span class="comment">// 返回迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found cherry: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>dict 用hash table实现,故具有随机性,而map是用红黑树实现的,可以做到有序</p></blockquote><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python set（集合）示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建</span></span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s2 = <span class="built_in">set</span>([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">s3 = <span class="built_in">set</span>()  <span class="comment"># 空集合，不能写 &#123;&#125;，会被当作 dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加元素</span></span><br><span class="line">s.add(<span class="number">6</span>)</span><br><span class="line">s.update([<span class="number">7</span>, <span class="number">8</span>])  <span class="comment"># 批量添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除元素</span></span><br><span class="line">s.remove(<span class="number">2</span>)   <span class="comment"># key 不存在会报 KeyError</span></span><br><span class="line">s.discard(<span class="number">10</span>) <span class="comment"># key 不存在也不会报错</span></span><br><span class="line">val = s.pop() <span class="comment"># 随机删除一个元素并返回</span></span><br><span class="line">s.clear()     <span class="comment"># 删除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 遍历</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 集合运算</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">union_set = a | b       <span class="comment"># 并集</span></span><br><span class="line">intersection_set = a &amp; b <span class="comment"># 交集</span></span><br><span class="line">diff_set = a - b         <span class="comment"># 差集</span></span><br><span class="line">symmetric_diff = a ^ b   <span class="comment"># 对称差集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 判断成员</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;exists&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not exists&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::set：有序集合</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">6</span>);       <span class="comment">// 添加元素</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">2</span>);        <span class="comment">// 删除元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : s)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出有序: 1 3 4 5 6</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unordered_set：无序集合</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; us = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    us.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">    us.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : us)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出顺序不定</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="number">3</span>) != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3 exists in set&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只是比dict和map少了一个值的存储,因此数据结构仍然不变</p></blockquote><h3 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h3><h4 id="选择语句"><a class="markdownIt-Anchor" href="#选择语句"></a> 选择语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    y = <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = -<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>看得出来<code>else if</code>还是太长了,而<code>switch case</code>大多数时候是真的没有用</p></blockquote><h4 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历容器</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># break / continue</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="函数与模块"><a class="markdownIt-Anchor" href="#函数与模块"></a> 函数与模块</h3><ul><li>python函数不需要指定返回类型,return也是可选的</li><li>如果没写return或者return后没有东西,则返回None</li><li>其余的函数语法和cpp差不多</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printHello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">x = add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">y = add(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># math_utils.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="comment"># 1.py</span></span><br><span class="line"><span class="keyword">import</span> math_utils</span><br><span class="line"></span><br><span class="line">v = math_utils.square(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 2.py</span></span><br><span class="line"><span class="keyword">from</span> math_utils <span class="keyword">import</span> square</span><br><span class="line"></span><br><span class="line">result = square(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 3.py </span></span><br><span class="line"><span class="keyword">from</span> math_utils <span class="keyword">import</span> square  <span class="keyword">as</span> sq</span><br><span class="line">result=sq(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 4.py</span></span><br><span class="line"><span class="keyword">from</span> math_utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">result=square(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 5.py</span></span><br><span class="line"><span class="keyword">import</span> math_utils <span class="keyword">as</span> math</span><br><span class="line"></span><br><span class="line">v = math.square(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="oop"><a class="markdownIt-Anchor" href="#oop"></a> oop</h3><blockquote><p>最值得一提的特征就是python没有public,protected,private这样的限定符,而是通过下划线来区分,</p></blockquote><h4 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h4><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_class.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>._value = value  <span class="comment"># 私有成员（约定）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._value = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> my_class <span class="keyword">import</span> MyClass</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.get())   <span class="comment"># 10</span></span><br><span class="line">obj.<span class="built_in">set</span>(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.get())   <span class="comment"># 20</span></span><br></pre></td></tr></table></figure><ul><li>python不使用隐式的this指针,而是要显式写明self,调用的时候则可以忽略self</li><li>对象也和变量一样直接用’='赋值即可<br /><strong>cpp</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v);        <span class="comment">// 构造函数（类内声明）</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>();            <span class="comment">// 析构函数（类内声明）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 成员函数（类内声明）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::set</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    obj.<span class="built_in">set</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>python做不到像cpp一样的类内声明和类外实现,只能用下面的例子所述直接添加方法和成员,但这样或许还方便一点,就不需要用到难用的cmake了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_class <span class="keyword">import</span> MyClass</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_double</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.x * <span class="number">2</span></span><br><span class="line">    MyClass.double = double</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4><blockquote><p>如果不指定__init__就只有一个默认为空的实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value  <span class="comment"># 初始化成员变量</span></span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.value)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><h4 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h4><blockquote><p>基本用不上,因为python内部就能实现垃圾回收</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;MyClass(<span class="subst">&#123;self.value&#125;</span>) 被销毁&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">del</span> obj  <span class="comment"># 手动删除会立即调用 __del__</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实例属性和类属性"><a class="markdownIt-Anchor" href="#实例属性和类属性"></a> 实例属性和类属性</h4><ul><li><strong>实例属性</strong>：每个对象独立，存储在实例字典中</li><li><strong>类属性</strong>：所有实例共享，存储在类字典中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_attr = <span class="number">0</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.instance_attr = value  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass(<span class="number">10</span>)</span><br><span class="line">obj2 = MyClass(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1.instance_attr)  <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(obj2.instance_attr)  <span class="comment"># 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1.class_attr)     <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(obj2.class_attr)     <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">MyClass.class_attr = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(obj1.class_attr)     <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(obj2.class_attr)     <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h4 id="私有成员和公有成员"><a class="markdownIt-Anchor" href="#私有成员和公有成员"></a> 私有成员和公有成员</h4><ul><li><p>Python 没有真正的私有成员，使用约定 _name 或双下划线 __name</p></li><li><p>公有成员无前导下划线，直接访问</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.public = <span class="number">1</span>        <span class="comment"># 公有</span></span><br><span class="line">        <span class="variable language_">self</span>._protected = <span class="number">2</span>    <span class="comment"># 受保护（约定）</span></span><br><span class="line">        <span class="variable language_">self</span>.__private = <span class="number">3</span>     <span class="comment"># 私有（name mangling）</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.public)       <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(obj._protected)   <span class="comment"># 2</span></span><br><span class="line"><span class="comment"># print(obj.__private)  # ❌ 报错</span></span><br><span class="line"><span class="built_in">print</span>(obj._MyClass__private)  <span class="comment"># 3，通过 name mangling 访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="公有私有静态方法"><a class="markdownIt-Anchor" href="#公有私有静态方法"></a> 公有,私有,静态方法</h4><ul><li><strong>公有方法</strong>：默认，无下划线，任何地方可调用</li><li><strong>私有方法</strong>：双下划线 <code>__name</code>，name mangling，限制外部访问</li><li><strong>静态方法</strong>：<code>@staticmethod</code>，不接收 <code>self</code> 或 <code>cls</code>，独立于实例和类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">public_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;公有方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;私有方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.public_method()          <span class="comment"># 公有方法</span></span><br><span class="line"><span class="comment"># obj.__private_method()     # ❌ 报错</span></span><br><span class="line">obj._MyClass__private_method()  <span class="comment"># 私有方法，通过 name mangling 访问</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.static_method(<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 静态方法，直接通过类调用</span></span><br></pre></td></tr></table></figure><h4 id="类的继承"><a class="markdownIt-Anchor" href="#类的继承"></a> 类的继承</h4><ul><li>私有成员和私有方法不会被继承,需要这样调用<code>self._Parent__private_method()</code></li><li>构造函数默认不继承,需要重写,但可以调用基类的构造函数</li><li>不过构造函数的前导双下划线说明了他是私有成员不可被继承,也可以说是设计的一个巧思</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal speaks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Dog barks&quot;</span>)  <span class="comment"># 重写方法</span></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">dog.speak()  <span class="comment"># Dog barks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Walker</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Walking&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperDog</span>(Dog, Walker):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sd = SuperDog()</span><br><span class="line">sd.speak()  <span class="comment"># Dog barks</span></span><br><span class="line">sd.walk()   <span class="comment"># Walking</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h4><ul><li>多态：<strong>同一接口，不同对象，表现出不同行为</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal speaks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Dog barks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cat meows&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.speak()   <span class="comment"># 只要求对象“有 speak 方法”</span></span><br><span class="line"></span><br><span class="line">make_sound(Dog())  <span class="comment"># Dog barks</span></span><br><span class="line">make_sound(Cat())  <span class="comment"># Cat meows</span></span><br></pre></td></tr></table></figure><blockquote><p>也就是说同一个方法可以直接由子类继承并完成不同的实现,而cpp里必须得先写明该方法是virtual,子类中要写明override,相比起来麻烦了不少</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 多态（基于继承 + 虚函数）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;          <span class="comment">// 必须是 virtual</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speaks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125;             <span class="comment">// 多态基类必须有虚析构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat meows&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_sound</span><span class="params">(Animal* a)</span> </span>&#123;          <span class="comment">// 基类指针</span></span><br><span class="line">    a-&gt;<span class="built_in">speak</span>();                       <span class="comment">// 运行时多态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    Cat c;</span><br><span class="line">    <span class="built_in">make_sound</span>(&amp;d);</span><br><span class="line">    <span class="built_in">make_sound</span>(&amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;语法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#语法&quot;&gt;&lt;/a&gt; 语法&lt;/h2&gt;
&lt;h3 id=&quot;变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#变量&quot;&gt;&lt;/a&gt; 变量&lt;/h3&gt;
&lt;blockquot</summary>
      
    
    
    
    
    <category term="python" scheme="https://revival-of-hope.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-18 astro尝试</title>
    <link href="https://revival-of-hope.github.io/2026/01/18/archives-2026-01-18-astro%E5%B0%9D%E8%AF%95/"/>
    <id>https://revival-of-hope.github.io/2026/01/18/archives-2026-01-18-astro%E5%B0%9D%E8%AF%95/</id>
    <published>2026-01-18T00:00:00.000Z</published>
    <updated>2026-01-21T02:35:18.554Z</updated>
    
    <content type="html"><![CDATA[<p>本来觉得hexo的图片管理太麻烦了,部署速度又比较慢,做不到动态同步,就想着换其他的博客框架试试,经过多方搜寻敲定了astro来尝鲜,下面是没有模板时的效果<br /><img src="/images/2026-01-18/PixPin_2026-01-18_14-15-02.webp" alt="alt text" /></p><blockquote><p>看着还不错,之后再改改就是个还不错的博客框架了,但问题就是所有组件都要我一个个自己写,没有前端基础的话光靠AI做不出太好的效果,而当我一点点添加组件的时候部署速度就飞速下降了</p></blockquote><p><img src="/images/2026-01-18/PixPin_2026-01-18_14-18-42.webp" alt="alt text" /></p><p><img src="/images/2026-01-18/PixPin_2026-01-18_14-19-29.webp" alt="alt text" /></p><p><img src="/images/2026-01-18/PixPin_2026-01-18_14-20-28.webp" alt="alt text" /></p><blockquote><p>尽管相比起来的话astro还是快了不少,但我一想到之后再加入图片管理功能和访客统计,评论系统,加载动画这些东西之后那臃肿的package库,就觉得不太可能会有多快,所以决定及时止损,虽然hexo跑的不够快,但也是一辆历久弥新的自行车!</p></blockquote><ul><li>而且不用我自己写组件</li></ul><blockquote><p>准备再试试hugo,如果真的有质的飞跃,再考虑换过去</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来觉得hexo的图片管理太麻烦了,部署速度又比较慢,做不到动态同步,就想着换其他的博客框架试试,经过多方搜寻敲定了astro来尝鲜,下面是没有模板时的效果&lt;br /&gt;
&lt;img src=&quot;/images/2026-01-18/PixPin_2026-01-18_14-15</summary>
      
    
    
    
    
    <category term="前端" scheme="https://revival-of-hope.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-15 计算机组成原理复习</title>
    <link href="https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</id>
    <published>2026-01-15T00:00:00.000Z</published>
    <updated>2026-01-18T06:10:09.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="考试事项"><a class="markdownIt-Anchor" href="#考试事项"></a> 考试事项</h2><p>考试分数占比60%<br />填空15分 一空一分<br />选择20分 20道题<br />综合题65分 七道大题,基本一个章节一道题</p><h2 id="重要的杂项"><a class="markdownIt-Anchor" href="#重要的杂项"></a> 重要的杂项</h2><h3 id="片选信号"><a class="markdownIt-Anchor" href="#片选信号"></a> 片选信号</h3><p>CS(chip select): 片选信号,低电平有效,通过地址逻辑生成,故在原理图中一般都在上面加一横来表示</p><h3 id="译码器"><a class="markdownIt-Anchor" href="#译码器"></a> 译码器</h3><p>译码器(decoder)是一种具有“翻译”功能的多输入多输出的组合逻辑电路器件。<br />译码器的功能：将每一组编码序列信号转换为一个特定的输出信号<br />译码器的输入：一组编码序列信号<br />译码器的输出：一条特定的译码信号（与每组输入信号对应）<br />译码器的工作原理：当某组编码进入输入端时，相应的译码线输出为低电平，与此同时，其他所有译码线输出保持为高电平。<br />通常，译码器的输出端与输入端的数量关系为（2^n）</p><h2 id="第一章-概论"><a class="markdownIt-Anchor" href="#第一章-概论"></a> 第一章 概论</h2><h3 id="计算机5个部件的示意图"><a class="markdownIt-Anchor" href="#计算机5个部件的示意图"></a> 计算机5个部件的示意图</h3><p><img src="/images/2026-01-11/PixPin_2026-01-13_09-42-23.webp" alt="alt text" /></p><blockquote><p>由于运算器(ALU)与控制器都集成在cpu上,因此可以写成下图形式</p></blockquote><p><img src="/images/2026-01-11/PixPin_2026-01-13_09-44-09.webp" alt="alt text" /><br />而早期的冯诺伊曼结构是这样的<br /><img src="/images/2026-01-11/PixPin_2026-01-13_09-47-07.webp" alt="alt text" /></p><h3 id="各部件详解"><a class="markdownIt-Anchor" href="#各部件详解"></a> 各部件详解</h3><blockquote><p>运算器: 算术逻辑单元,用于完成算术运算和逻辑运算<br />控制器: 计算机的管理机构和指挥中心,协调计算机各部件自动工作<br />存储器: 计算机的存储部件,用于存储程序和数据,由内存和外存两部分构成<br />内存: 由大量存储单元组成,构成一个按地址访问的一维线性空间,也称为主存<br />输入设备: 将程序和数据以计算机能识别的形式输入到计算机内<br />输出设备: 将计算机处理的结果以人们能接受或其他系统所要求的形式输出到外部世界<br />操作系统: 最主要的系统软件,负责管理系统资源,为应用程序提供运行环境,为用户提供操作界面</p></blockquote><hr /><p>其中,控制器由以下6部分构成:</p><ol><li>指令寄存器(IR): 用于存放当前正在执行的指令</li><li>程序计数器(PC): 用于存放当前正在执行的指令的地址</li><li>指令译码器: 对指令进行译码,形成相应的控制信号</li><li>时钟脉冲(CP): 协调计算机各部件的同步主时钟,工作频率称为计算机的<strong>主频</strong></li><li>时序信号发生器: 按时间顺序发出节拍信号</li><li>微操作控制部件: 根据时序信号发生器的节拍信号和指令译码器的译码结果产生微操作控制信号给各个计算机部件</li></ol><blockquote><p>而运算部件由运算器和通用寄存器组构成,寄存器组用于暂存运算数据和中间结果<br />内存则由存储体,地址寄存器AR,数据寄存器DR三部分构成</p></blockquote><h3 id="计算机的性能指标"><a class="markdownIt-Anchor" href="#计算机的性能指标"></a> 计算机的性能指标</h3><ol><li>主频: 衡量计算机工作速度的主要指标之一</li><li>运算速度: 以每秒执行多少条指令或完成多少次浮点运算来表示</li><li>基本字长: 直接参与运算的数据的二进制位数,标志着运算精度,位数越多,精度越高</li><li>主存容量: 主存能储存信息的总量</li><li>主存存取周期: 对主存连续两次访问的最小时间间隔</li><li>外部设备的配置</li></ol><blockquote><p>其中运算速度由两种计量单位,分别是</p></blockquote><ol><li>MIPS:百万条指令/秒(million instructions per second)</li><li>MFLOPS:百万次浮点运算/秒(million flops per second)</li></ol><h2 id="第二章-数的表示作为第十章的基础"><a class="markdownIt-Anchor" href="#第二章-数的表示作为第十章的基础"></a> 第二章 数的表示（作为第十章的基础）</h2><blockquote><p><strong>机器数</strong>：用二进制编码表示的数据<br />在计算机中，常用 <strong>原码、补码、反码</strong> 三种方法来表示带符号的机器数</p></blockquote><hr /><ul><li>下面的.表示拼接</li></ul><h3 id="原码表示法"><a class="markdownIt-Anchor" href="#原码表示法"></a> 原码表示法</h3><p><strong>定义</strong><br />原码由 <strong>符号位 + 数值位</strong> 组成</p><ul><li>符号位 s：0 表示正，1 表示负</li><li>数值位表示绝对值的二进制</li></ul><p><strong>表示公式</strong></p><ul><li><p>正数</p><ul><li>原码 = 0 · |x|₂</li></ul></li><li><p>负数</p><ul><li>原码 = 1 · |x|₂</li></ul></li></ul><ul><li><strong>简单说就是负数前面加个1</strong></li></ul><blockquote><p>举例:<br />[-0.1101]_原=1.1101<br />[-1101]_原=11101</p></blockquote><p><strong>特点</strong></p><ul><li>表示直观</li><li>存在 +0 与 −0</li><li>加减运算用根据符号来判断,但符号位不参与运算</li></ul><hr /><h3 id="反码表示法"><a class="markdownIt-Anchor" href="#反码表示法"></a> 反码表示法</h3><p><strong>定义</strong><br />补码的中间过程<br /><strong>表示公式</strong></p><ul><li><p>正数</p><ul><li>反码 = 原码 = 0 · |x|₂</li></ul></li><li><p>负数</p><ul><li>反码 = 符号位不变，数值位逐位取反</li></ul></li></ul><p><strong>特点</strong></p><ul><li>存在 +0 与 −0</li><li>运算仍不方便</li></ul><h3 id="补码表示法"><a class="markdownIt-Anchor" href="#补码表示法"></a> 补码表示法</h3><p><strong>定义</strong><br />补码是计算机中实际采用的带符号数表示方法</p><p><strong>表示公式</strong></p><ul><li><p>正数</p><ul><li>补码 = 原码 = 0 · |x|₂</li></ul></li><li><p>负数</p><ul><li>补码 = 原码数值位逐位取反 + 1</li></ul></li></ul><p><strong>补充说明</strong></p><ul><li>小数补码中，“加 1”是对最低有效位加 1</li><li>若产生进位，直接舍去最高进位</li></ul><p><strong>特点</strong></p><ul><li>只有一个 0</li><li>加减法统一为加法</li><li>硬件实现简单</li></ul><h4 id="深入理解"><a class="markdownIt-Anchor" href="#深入理解"></a> 深入理解</h4><blockquote><p>一个数减去小于模的另一个数,可以用加上模与另一个数的绝对值之差来代替</p></blockquote><blockquote><p>实际上负数的补码是用2的(n+1)次方加上该负数得到的,若负数x有n位,则补码相当于(11…11)n +1 +x,这也就是负数补码之所以要对所有位取反再加一的真相</p></blockquote><ul><li>当最高位即符号位有进位时实际上相当于加上了一个2的(n+1)次方,对结果取模时可以舍去</li></ul><hr /><h3 id="移码表示法"><a class="markdownIt-Anchor" href="#移码表示法"></a> 移码表示法</h3><p><img src="/images/2026-01-11/PixPin_2026-01-13_13-32-56.webp" alt="alt text" /></p><blockquote><p>无论正负均用一个式子表示</p></blockquote><p><img src="/images/2026-01-11/PixPin_2026-01-13_13-35-46.webp" alt="alt text" /></p><h3 id="数的浮点表示"><a class="markdownIt-Anchor" href="#数的浮点表示"></a> 数的浮点表示</h3><blockquote><p>浮点是指小数点的位置不固定,随时浮动</p></blockquote><p><img src="/images/2026-01-11/PixPin_2026-01-13_13-57-51.webp" alt="alt text" /></p><p>[<br />X = M \times 2^{E}<br />]</p><blockquote><p>其中：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>：阶码，用定点整数表示,采用移码<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>：尾数，用定点小数表示</p></blockquote><h4 id="规格化浮点数"><a class="markdownIt-Anchor" href="#规格化浮点数"></a> 规格化浮点数</h4><p>当浮点数的基数为 2 时，如果其尾数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 满足：<br />[<br />\frac{1}{2} \le |M| &lt; 1<br />]<br />则称该浮点数为规格化浮点数</p><ul><li>很好理解,如果尾数小于1/2,说明有前导0,那么就可以将阶码减小1来消去0</li></ul><h4 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h4><p><img src="/images/2026-01-11/PixPin_2026-01-13_14-02-32.webp" alt="alt text" /></p><blockquote><p>步骤如下:</p></blockquote><ol><li>先将十进制数化成尾数乘以阶码的形式,</li><li>而在实际存储中,将阶码用移码表示,也就是加上2的4次方,从而保证都是正数</li><li>再把尾数用补码的形式表示出来,符号位放到最前面的数符位置,数值位放在最后面</li></ol><h2 id="第六章-计算机执行程序的过程"><a class="markdownIt-Anchor" href="#第六章-计算机执行程序的过程"></a> 第六章 计算机执行程序的过程</h2><h3 id="指令说明"><a class="markdownIt-Anchor" href="#指令说明"></a> 指令说明</h3><h4 id="load-指令装载寄存器指令"><a class="markdownIt-Anchor" href="#load-指令装载寄存器指令"></a> Load 指令（装载寄存器指令）</h4><ul><li>功能：把一个数据送入指定的寄存器</li><li>数据来源：<ul><li>立即数</li><li>存储器中的某个单元</li></ul></li></ul><hr /><h4 id="store-指令存储指令"><a class="markdownIt-Anchor" href="#store-指令存储指令"></a> Store 指令（存储指令）</h4><ul><li>功能：把指定寄存器中的数据存入存储器的某个单元</li></ul><hr /><h4 id="add-指令加法指令"><a class="markdownIt-Anchor" href="#add-指令加法指令"></a> Add 指令（加法指令）</h4><ul><li>功能：将两个寄存器中的数据相加,把运算结果存入指定寄存器</li></ul><hr /><h4 id="jump-指令跳转指令"><a class="markdownIt-Anchor" href="#jump-指令跳转指令"></a> Jump 指令（跳转指令）</h4><ul><li>功能：跳转到新的地址继续执行指令</li></ul><hr /><h3 id="记号说明"><a class="markdownIt-Anchor" href="#记号说明"></a> 记号说明</h3><ul><li><code>[Rx]</code>：寄存器 Rx 中的内容</li><li><code>MEM[y]</code>：存储器中地址为 y 的存储单元内容</li><li><code>→</code>：传送（数据流向）</li></ul><h3 id="指令示例说明"><a class="markdownIt-Anchor" href="#指令示例说明"></a> 指令示例说明</h3><h4 id="第-1-条"><a class="markdownIt-Anchor" href="#第-1-条"></a> 第 1 条</h4><p><strong>Load R1，200(R0)</strong><br />MEM[[R0] + 200] → R1<br />以 R0 为基址，加偏移量 200，将对应存储单元内容送入 R1</p><h4 id="第-2-条"><a class="markdownIt-Anchor" href="#第-2-条"></a> 第 2 条</h4><p><strong>Load R2，#4</strong><br />4 → R2<br />4 直接包含在指令中，称为<strong>立即数</strong></p><h4 id="第-3-条"><a class="markdownIt-Anchor" href="#第-3-条"></a> 第 3 条</h4><p><strong>Add R3，R1，R2</strong><br />[R1] + [R2] → R3<br />将 R1 与 R2 中的数据相加，结果送入 R3</p><h4 id="第-4-条"><a class="markdownIt-Anchor" href="#第-4-条"></a> 第 4 条</h4><p><strong>Store R3，200(R2)</strong><br />[R3] → MEM[[R2] + 200]<br />以 R2 为基址，加偏移量 200，将 R3 的内容存入存储器</p><h4 id="第-5-条"><a class="markdownIt-Anchor" href="#第-5-条"></a> 第 5 条</h4><p><strong>Store R2，@(208)</strong><br />[R2] → MEM[ MEM[208] ]<br />@ 表示间接寻址，208 中的内容作为有效地址</p><h4 id="第-6-条"><a class="markdownIt-Anchor" href="#第-6-条"></a> 第 6 条</h4><p><strong>Jump 1000</strong><br />1000 → PC<br />将程序计数器 PC 置为 1000，跳转执行</p><hr /><ul><li>指令后面跟着的第一个数就是指令操作的结果存储对象,再后面才是这个操作需要的数据</li><li>注意到这里的R1,R2,R3都是寄存器(register)</li></ul><h3 id="第一条指令load-r1200r0详解"><a class="markdownIt-Anchor" href="#第一条指令load-r1200r0详解"></a> 第一条指令**Load R1，200(R0)**详解</h3><p><strong>第一步</strong></p><ol><li>[PC]-&gt;AR,将pc存放的当前指令地址传入地址寄存器AR</li><li>从存储体读出对应地址的指令放入数据寄存器DR</li><li>将DR送入指令寄存器IR</li></ol><p><strong>第二步</strong><br />指令译码器进行译码,结合CP和时序信号发生器产生的节拍信号,产生微操作控制信号</p><p><strong>第三步</strong></p><ol><li>计算访问地址:[R0]+200-&gt;AR<ol><li>[R0]-&gt;ALU,把寄存器R0中的内容送入ALU</li><li>IR中的操作数200送入ALU</li><li>[ALU]-&gt;AR,ALU进行加法运算,把结果传给AR</li></ol></li><li>从存储器读出数据,送入寄存器R1<ol><li>从存储器中地址200的存储单元读出数据,送入DR</li><li>DR-&gt;R1,将DR中的数据送入R1</li></ol></li></ol><p><strong>第四步</strong><br />PC+4,指向下一条指令</p><ul><li>显然所有指令的第1步(取指令),第2步(指令译码),第4步(PC+4)都是一样的,只是第三步的执行指令有区别</li></ul><hr /><h2 id="第七章-指令系统"><a class="markdownIt-Anchor" href="#第七章-指令系统"></a> 第七章 指令系统</h2><h3 id="指令格式"><a class="markdownIt-Anchor" href="#指令格式"></a> 指令格式</h3><blockquote><p>一条指令必须包含以下三条信息</p></blockquote><ol><li>要执行的操作</li><li>操作的对象</li><li>操作的结果(操作结果要保存到哪里)</li></ol><ul><li>操作数:操作码操作的对象数据<br /><strong>指令的基本格式</strong><br /><img src="/images/2026-01-11/PixPin_2026-01-13_17-17-33.webp" alt="alt text" /></li></ul><h3 id="指令的地址码"><a class="markdownIt-Anchor" href="#指令的地址码"></a> 指令的地址码</h3><p>地址码中的地址可以为0,1个或多个,根据指令中地址码中的地址数量可以分为以下5种指令</p><h4 id="零地址指令"><a class="markdownIt-Anchor" href="#零地址指令"></a> 零地址指令</h4><p><img src="/images/2026-01-11/PixPin_2026-01-13_17-21-33.webp" alt="alt text" /></p><blockquote><p>通常在两种情况下可能采用零地址指令</p></blockquote><ol><li>指令本身不需要任何操作数</li><li>指令中所需的操作数是隐含指定的</li></ol><h4 id="一地址指令"><a class="markdownIt-Anchor" href="#一地址指令"></a> 一地址指令</h4><p><img src="/images/2026-01-11/PixPin_2026-01-13_17-21-59.webp" alt="alt text" /></p><blockquote><p>在两种情况下可能采用一地址指令</p></blockquote><ol><li>指令本身只需要一个操作数,如加1,求补等<ul><li>A &lt;- OP[A]</li></ul></li><li>指令操作需要两个操作数，指令中指明一个操作数，而另外一个操作数在默认的某个地方<ul><li>如 ：累加器AC中，操作结果存放到累加器AC中</li><li>AC &lt;- [AC] OP [A]</li></ul></li></ol><h4 id="二地址指令"><a class="markdownIt-Anchor" href="#二地址指令"></a> 二地址指令</h4><p><img src="/images/2026-01-11/PixPin_2026-01-13_17-26-04.webp" alt="alt text" /></p><ul><li>A1 &lt;- [A1] OP [A2]</li></ul><blockquote><p>根据存放操作数的位置不同，分为3种。</p></blockquote><ol><li>寄存器-寄存器型（R-R型）指令</li><li>存储器-存储器型（M-M型）指令</li><li>寄存器-存储器型（R-M型）指令</li></ol><ul><li>显然其中一个是用来存放操作结果地址的</li></ul><h4 id="三地址指令和多地址指令"><a class="markdownIt-Anchor" href="#三地址指令和多地址指令"></a> 三地址指令和多地址指令</h4><blockquote><p>三地址指令被广泛采用,特别是在RISC计算机中</p></blockquote><blockquote><p>多地址指令用于描述一批数据，指令中需要多个地址来指出数据存放的首地址、长度和下标等信息</p></blockquote><h3 id="指令的操作码"><a class="markdownIt-Anchor" href="#指令的操作码"></a> 指令的操作码</h3><blockquote><p>指令系统中的每一条指令都有唯一确定的操作码，不同指令的操作码是不相同的。<br />操作码的长度决定了指令系统的最大规模。<br />若操作码的位数为 n 位，则该指令系统最多能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 条指令</p></blockquote><hr /><h4 id="固定长度操作码"><a class="markdownIt-Anchor" href="#固定长度操作码"></a> 固定长度操作码</h4><blockquote><p>所有指令操作码的长度都是固定的，且集中放在指令的一个字段内。<br />有利于简化硬件设计，减少指令译码时间。<br />很多现代计算机都采用了固定长度操作码。</p></blockquote><hr /><h4 id="可变长度操作码"><a class="markdownIt-Anchor" href="#可变长度操作码"></a> 可变长度操作码</h4><p>指令系统中操作码的长度有多种，不同指令的操作码长度不完全相同。</p><ul><li>使用频率高的指令使用短的操作码</li><li>使用频率低的指令使用较长的操作码</li></ul><p>可以缩短操作码的平均长度，但会使硬件设计复杂化，增加指令译码的时间和难度。</p><hr /><h4 id="扩展操作码"><a class="markdownIt-Anchor" href="#扩展操作码"></a> 扩展操作码</h4><p>将操作码设计为几种不同的固定长度，且相互之间按某种规则进行扩展。</p><p><strong>优点</strong></p><ul><li>可以简化硬件设计；</li><li>当指令总长度一定时，可以使操作码的长度随地址数的增加而减少，<br />不同地址数的指令的操作码长度也不同，从而有效缩短指令总长度。</li></ul><p><strong>扩展操作码的方法</strong></p><ul><li>等长扩展</li><li>不等长扩展</li></ul><p><strong>扩展示例</strong><br /><img src="/images/2026-01-11/PixPin_2026-01-13_17-41-26.webp" alt="alt text" /></p><h3 id="指令长度"><a class="markdownIt-Anchor" href="#指令长度"></a> 指令长度</h3><p><strong>指令长度</strong>：指一条指令所包含的二进制代码的总位数。</p><p>指令长度主要取决于以下因素：</p><ul><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数地址的个数</li></ul><p>指令长度通常与机器字长存在简单的倍数关系。</p><hr /><h4 id="按与机器字长的关系分类"><a class="markdownIt-Anchor" href="#按与机器字长的关系分类"></a> 按与机器字长的关系分类</h4><ul><li><p><strong>单字长指令</strong><br />指令长度等于机器字长的指令</p></li><li><p><strong>半字长指令</strong><br />指令长度等于半个机器字长的指令</p></li><li><p><strong>双字长指令</strong><br />指令长度等于机器字长两倍的指令</p></li></ul><hr /><ul><li>指令长度一般应是<strong>字节的整数倍</strong></li></ul><h3 id="寻址方式"><a class="markdownIt-Anchor" href="#寻址方式"></a> 寻址方式</h3><blockquote><p>指令的地址码给出的地址不一定是操作数的真正地址,而是形式地址,确定操作数有效地址的方法就叫寻址方式</p></blockquote><h4 id="直接寻址"><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h4><blockquote><p>在指令的地址码字段直接给出操作数所在主存单元的地址。</p></blockquote><ul><li>简单、快速的寻址方式，但寻址范围受限于地址码字段的位数<br /><img src="/images/2026-01-11/PixPin_2026-01-13_17-49-37.webp" alt="alt text" /></li></ul><h4 id="间接寻址"><a class="markdownIt-Anchor" href="#间接寻址"></a> 间接寻址</h4><blockquote><p>指令的地址码字段给出的是操作数所在内存单元的地址的地址。</p></blockquote><ol><li>指令中形式地址所指定的内存单元中存放的内容才是操作数的真正地址。</li><li>得到操作数需要访问两次内存，指令的执行速度比较慢</li></ol><p><img src="/images/2026-01-11/PixPin_2026-01-13_17-54-10.webp" alt="alt text" /></p><h4 id="立即寻址"><a class="markdownIt-Anchor" href="#立即寻址"></a> 立即寻址</h4><ul><li>指令的地址码字段直接给出操作数本身，而不是操作数的地址。</li><li>指令执行速度最快，得到指令的同时就得到了操作数，不需要再访问内存。</li></ul><h4 id="寄存器直接寻址与寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器直接寻址与寄存器间接寻址"></a> 寄存器直接寻址与寄存器间接寻址</h4><blockquote><p>寄存器直接寻址：指令的地址码字段给出一个寄存器编号，该寄存器中存放的内容就是操作数。<br />寄存器间接寻址：寄存器中存放的内容是操作数的地址，根据此地址访问内存取得操作数。</p></blockquote><p><img src="/images/2026-01-11/PixPin_2026-01-13_18-10-32.webp" alt="alt text" /></p><h4 id="隐含寻址"><a class="markdownIt-Anchor" href="#隐含寻址"></a> 隐含寻址</h4><blockquote><p>指令中不给出操作数的地址</p></blockquote><ul><li>操作数约定在某个特定的寄存器或堆栈中</li></ul><h4 id="pc相对寻址"><a class="markdownIt-Anchor" href="#pc相对寻址"></a> PC相对寻址</h4><blockquote><p>将程序计数器PC的内容与指令中给出的形式地址（偏移量）的值相加，形成操作数的有效地址</p></blockquote><ul><li>形式地址（偏移量）的值可正可负。</li><li>对于短跳转和程序的再定位很有用。<br /><img src="/images/2026-01-11/PixPin_2026-01-13_18-12-10.webp" alt="alt text" /></li></ul><h4 id="变址寻址"><a class="markdownIt-Anchor" href="#变址寻址"></a> 变址寻址</h4><blockquote><p>将指令中给出的形式地址的值与变址寄存器的内容相加，形成操作数的有效地址。</p></blockquote><ul><li>变址寄存器可以是专用寄存器，也可以是通用寄存器中的一个。</li><li>常用于字符串处理、数组运算等成批数据处理中，主要是面向用户，解决程序循环控制问题。</li><li>通常地址的变化体现在变址寄存器中，指令中的形式地址相对固定。<br /><img src="/images/2026-01-11/PixPin_2026-01-13_18-13-41.webp" alt="alt text" /></li></ul><h4 id="基址寻址"><a class="markdownIt-Anchor" href="#基址寻址"></a> 基址寻址</h4><blockquote><p>把指令中给出的形式地址的值与基址寄存器的内容相加，形成操作数的有效地址。</p></blockquote><blockquote><ul><li>基址寄存器的内容称为基地址。</li><li>主要用于将用户程序的逻辑地址转换成主存的实际地址。它面向系统，解决程序重定位和扩大寻址空间等问题。</li><li>通常地址变化体现形式地址上，基地址相对不变。</li></ul></blockquote><h4 id="基址变址寻址"><a class="markdownIt-Anchor" href="#基址变址寻址"></a> “基址+变址”寻址</h4><pre><code>     有效地址=（RB）+（RX）+D </code></pre><p>其中:</p><ul><li>（RB）：基址寄存器RB中的内容</li><li>（RX）：变址寄存器RX中的内容</li><li>D：指令字中给出的形式地址（偏移量）</li></ul><h3 id="指令按功能分类"><a class="markdownIt-Anchor" href="#指令按功能分类"></a> 指令按功能分类</h3><ol><li><blockquote><p><strong>数据传送类指令</strong><br />将数据从一个地方传送到另一个地方</p></blockquote></li></ol><ul><li>主要实现主存和主存之间、主存和寄存器之间、寄存器和寄存器之间的数据传送。</li><li>数据传送指令一次可以传送一个数据，也可以一次传送一批数据。</li></ul><ol start="2"><li><blockquote><p>数据运算类指令<br />用来实现数据的算术运算、逻辑运算和移位运算</p></blockquote></li></ol><ul><li>算术运算：加、减、乘、除运算；加1 、减1；比较指令等。</li><li>逻辑运算：包括与、或、非 、异或等运算。</li><li>移位指令：算术移位、逻辑移位和循环移位三类，它们又可分为左移和右移两种。</li></ul><ol start="3"><li><blockquote><p>程序控制类指令<br />主要用来控制程序执行的顺序和方向。</p></blockquote></li></ol><ul><li>包含转移指令、子程序调用和返回指令、自陷指令等</li></ul><ol start="4"><li><blockquote><p>输入输出指令</p></blockquote></li></ol><ul><li>简称I/O指令,主要用于实现主机与外部设备之间的信息交换</li></ul><h3 id="指令系统设计"><a class="markdownIt-Anchor" href="#指令系统设计"></a> 指令系统设计</h3><blockquote><p>指令系统的设计包括指令的功能设计,指令格式的设计两部分</p></blockquote><blockquote><p>在确定哪些基本功能用硬件来实现时，主要考虑3个因素：速度、成本、灵活性。</p></blockquote><ul><li>硬件实现的特点<ul><li>速度快、成本高、灵活性差</li></ul></li><li>软件实现的特点<ul><li>速度慢、价格便宜、灵活性好</li></ul></li></ul><h4 id="对指令系统的基本要求"><a class="markdownIt-Anchor" href="#对指令系统的基本要求"></a> 对指令系统的基本要求</h4><ol><li><blockquote><p>完整性：在一个有限可用的存储空间内，对于任何可解的问题，编制计算程序时，指令集所提供的指令足够用。</p></blockquote></li></ol><ul><li>要求指令集功能齐全、使用方便</li></ul><ol start="2"><li>规整性：主要包括对称性和均匀性。</li></ol><ul><li><blockquote><p>对称性：所有与指令集有关的存储单元的使用,操作码的设置等都是对称的。</p></blockquote><ul><li>例如：在存储单元的使用上，所有通用寄存器都要同等对待。在操作码的设置上，如果设置了A-B的指令，就应该也设置B-A的指令。</li></ul></li><li><blockquote><p>均匀性：指对于各种不同的操作数类型、字长、操作种类和数据存储单元，指令的设置都要同等对待。</p></blockquote><ul><li>例如：如果某机器有5种数据表示，4种字长，两种存储单元，则要设置5×4×2=40种同一操作的指令。</li></ul></li></ul><ol start="3"><li><blockquote><p>正交性：指在指令中各个不同含义的字段，如操作类型、数据类型、寻址方式字段等，在编码时应互不相关、相互独立。</p></blockquote></li><li><blockquote><p>高效率：指指令的执行速度快、使用频度高。</p></blockquote></li><li><blockquote><p>兼容性：主要是要实现向后兼容，指令系统可以增加新指令，但不能删除指令或更改指令的功能。</p></blockquote></li></ol><h4 id="指令格式的设计"><a class="markdownIt-Anchor" href="#指令格式的设计"></a> 指令格式的设计</h4><blockquote><p>3种常用的指令编码格式:可变长度编码格式、固定长度编码格式、混合型编码格式</p></blockquote><h5 id="可变长度编码格式"><a class="markdownIt-Anchor" href="#可变长度编码格式"></a> 可变长度编码格式</h5><blockquote><p>当指令系统包含多种寻址方式和操作类型时，这种编码方式可以有效减少指令系统的平均指令长度，降低目标代码的大小。</p></blockquote><ul><li>可能会使各条指令的字长和执行时间相差很大。</li><li>多数CISC指令系统均采用了这种编码格式。<br /><img src="/images/2026-01-11/PixPin_2026-01-13_18-52-58.webp" alt="alt text" /></li></ul><h5 id="固定长度编码格式"><a class="markdownIt-Anchor" href="#固定长度编码格式"></a> 固定长度编码格式</h5><blockquote><p>将操作类型和寻址方式一起编码到操作码中。</p></blockquote><ul><li>当寻址方式和操作类型非常少时,这种编码格式非常好,可以有效地降低译码的复杂度，提高译码的速度。</li><li>大部分RISC的指令系统均采用这种编码格式。</li></ul><p><img src="/images/2026-01-11/PixPin_2026-01-13_18-54-43.webp" alt="alt text" /></p><h5 id="混合型编码格式"><a class="markdownIt-Anchor" href="#混合型编码格式"></a> 混合型编码格式</h5><blockquote><p>提供若干种固定的指令字长,以期达到既能够减少目标代码长度又能降低译码复杂度的目标。<br /><img src="/images/2026-01-11/PixPin_2026-01-13_18-55-00.webp" alt="alt text" /></p></blockquote><h4 id="指令系统的两种设计策略"><a class="markdownIt-Anchor" href="#指令系统的两种设计策略"></a> 指令系统的两种设计策略</h4><h5 id="cisc复杂指令系统计算机"><a class="markdownIt-Anchor" href="#cisc复杂指令系统计算机"></a> CISC（复杂指令系统计算机）</h5><p>Complex Instruction Set Computer</p><ul><li>增强指令功能</li><li>将越来越多的功能交由硬件实现</li><li>指令数量不断增加</li><li>单条指令可完成较复杂的操作</li></ul><hr /><h5 id="risc精简指令系统计算机"><a class="markdownIt-Anchor" href="#risc精简指令系统计算机"></a> RISC（精简指令系统计算机）</h5><p>Reduced Instruction Set Computer</p><ul><li>尽可能简化指令系统</li><li>指令条数较少</li><li>指令功能相对简单</li><li>复杂功能由多条简单指令组合完成</li></ul><h5 id="为什么研发risc"><a class="markdownIt-Anchor" href="#为什么研发risc"></a> 为什么研发RISC</h5><blockquote><p>CISC的优点:指令数量多、功能多样<br />问题:</p></blockquote><ol><li><p>各种指令的使用频度相差悬殊，许多指令很少用</p><ul><li>据统计：只有20％的指令使用频度比较高，占运<br />行时间的80％。而其余80％的指令只在20％的运行时<br />间内才会用到。</li></ul></li><li><p>指令系统庞大，指令条数很多，许多指令的功能又很复杂，使得控制器硬件非常复杂。</p><ul><li>占用了大量的芯片面积</li><li>增加了研制时间和成本，容易造成设计错误。</li></ul></li><li><p>许多指令由于操作繁杂，其CPI值比较大，执行速度慢。采用这些复杂指令有可能使整个程序的执行时间反而增加。</p></li><li><p>由于指令功能复杂，规整性不好，不利于采用流<br />水技术来提高性能。</p></li></ol><blockquote><p>设计RISC机器遵循的原则</p></blockquote><ol><li>指令条数少、指令功能简单。只选取使用频度很高的指令，在此基础上补充一些最有用的指令</li><li>采用简单而又统一的指令格式，并减少寻址方式；指令字长都为32位或64位</li><li>指令的执行在单个机器周期内完成</li><li>采用load-store结构:只有load和store指令才能访问存储器,其它指令的操作都是在寄存器之间进行</li><li>大多数指令都采用硬连逻辑来实现</li><li>强调优化编译器的作用,为高级语言程序生成优化的代码</li><li>充分利用流水技术来提高性能</li></ol><h3 id="典型risc实例mips"><a class="markdownIt-Anchor" href="#典型risc实例mips"></a> 典型RISC实例:MIPS</h3><h4 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h4><ul><li>32个64位通用寄存器,其中R0的值永远是0(GPRs)</li><li>32个64位浮点数寄存器(FPRs)</li><li>一些特殊寄存器</li></ul><h4 id="数据表示"><a class="markdownIt-Anchor" href="#数据表示"></a> 数据表示</h4><ul><li>整数:字节（8位）;半字（16位）;字（32位）; 双字（64位）</li><li>浮点数:单精度浮点数（32位）  双精度浮点数（64位）</li></ul><blockquote><p>字节、半字或者字在装入64位寄存器时，用零扩展或者用符号位扩展来填充该寄存器的剩余部分。装入以后，对它们将按照64位整数的方式进行运算。</p></blockquote><h4 id="数据寻址方式"><a class="markdownIt-Anchor" href="#数据寻址方式"></a> 数据寻址方式</h4><p>只有立即数寻址与偏移量寻址两种</p><h4 id="指令格式-2"><a class="markdownIt-Anchor" href="#指令格式-2"></a> 指令格式</h4><blockquote><p>只有三种指令格式,都是32位,其中操作码占6位</p></blockquote><h5 id="i-类指令immediate"><a class="markdownIt-Anchor" href="#i-类指令immediate"></a> I 类指令（Immediate）</h5><p><strong>包含类型</strong></p><ul><li>Load / Store 指令</li><li>立即数指令</li><li>分支指令</li><li>寄存器跳转指令</li><li>寄存器链接跳转指令</li></ul><p><strong>特点</strong></p><ul><li>立即数字段长度：16 位</li><li>用途：提供立即数或地址偏移量</li></ul><p><strong>指令语义</strong></p><ul><li><p><strong>Load 指令</strong></p><ul><li>有效地址：<code>Regs[rs] + immediate</code></li><li>从存储器读取数据，写入寄存器 <code>rt</code></li></ul></li><li><p><strong>Store 指令</strong></p><ul><li>有效地址：<code>Regs[rs] + immediate</code></li><li>将寄存器 <code>rt</code> 中的数据写入存储器</li></ul></li><li><p><strong>立即数指令</strong></p><ul><li><code>Regs[rt] ← Regs[rs] op immediate</code></li></ul></li><li><p><strong>分支指令</strong></p><ul><li>转移目标地址：<code>Regs[rs] + immediate</code></li><li>寄存器 <code>rt</code> 不使用</li></ul></li><li><p><strong>寄存器跳转并链接</strong></p><ul><li>转移目标地址：<code>Regs[rs]</code></li></ul></li></ul><p><img src="/images/2026-01-11/PixPin_2026-01-14_10-03-14.webp" alt="I类指令格式" /></p><hr /><h5 id="r-类指令register"><a class="markdownIt-Anchor" href="#r-类指令register"></a> R 类指令（Register）</h5><p><strong>包含类型</strong></p><ul><li>ALU 运算指令</li><li>专用寄存器读 / 写指令</li><li>move 指令等</li></ul><p><strong>ALU 指令语义</strong></p><ul><li><code>Regs[rd] ← Regs[rs] funct Regs[rt]</code></li><li><code>funct</code> 字段指定具体运算类型</li></ul><p><img src="/images/2026-01-11/PixPin_2026-01-14_10-03-40.webp" alt="R类指令格式" /></p><hr /><h5 id="j-类指令jump"><a class="markdownIt-Anchor" href="#j-类指令jump"></a> J 类指令（Jump）</h5><p><strong>包含类型</strong></p><ul><li>跳转指令</li><li>跳转并链接指令</li><li>自陷指令</li><li>异常返回指令</li></ul><p><strong>特点</strong></p><ul><li>指令字低 26 位为偏移量</li><li>与当前 PC 值组合形成跳转目标地址</li></ul><p><img src="/images/2026-01-11/PixPin_2026-01-14_10-04-15.webp" alt="J类指令格式" /></p><h4 id="mips的操作"><a class="markdownIt-Anchor" href="#mips的操作"></a> MIPS的操作</h4><p>MIPS指令可以分为四大类<br />load和store<br />ALU操作<br />分支与跳转<br />浮点操作</p><h4 id="数据表示-2"><a class="markdownIt-Anchor" href="#数据表示-2"></a> 数据表示</h4><h4 id="数据表示-3"><a class="markdownIt-Anchor" href="#数据表示-3"></a> 数据表示</h4><h2 id="第八章-cpu"><a class="markdownIt-Anchor" href="#第八章-cpu"></a> 第八章 CPU</h2><h3 id="cpu的功能"><a class="markdownIt-Anchor" href="#cpu的功能"></a> CPU的功能</h3><p>CPU具有以下4个方面的基本功能</p><ul><li>指令顺序控制<ul><li>指控制程序中指令的执行顺序。</li><li>程序中各指令之间是有严格先后顺序的，必须严格按程序规定的顺序执行，才能保证计算机工作的正确性</li></ul></li><li>操作控制<ul><li>一条指令的功能往往是由计算机中的部件执行一序列的操作来实现的。</li><li>CPU要根据指令的功能，产生相应的操作控制信号，发送给相应的部件，从而控制这些部件按指令的要求进行动作</li></ul></li><li>时间控制<br />对各种操作实施时间上的定时。<ul><li>在一条指令的执行过程中，在什么时间做什么操作均应受到严格的控制</li></ul></li><li>数据加工<ul><li>即对数据进行算术运算和逻辑运算，或进行其他的信息处理</li></ul></li></ul><h4 id="基本组成"><a class="markdownIt-Anchor" href="#基本组成"></a> 基本组成</h4><ul><li>现代CPU一般由运算器、控制器、数据通路和Cache组成</li></ul><h4 id="指令执行的基本步骤"><a class="markdownIt-Anchor" href="#指令执行的基本步骤"></a> 指令执行的基本步骤</h4><blockquote><p>一条指令的执行过程包括3个基本步骤：</p></blockquote><ol><li>取指令：从存储器取出一条指令，该指令的地址由程序计数器PC给出。</li><li>译码：对该指令的操作码进行译码分析，确定是哪一种指令，并转到这种指令对应的执行阶段。</li><li>执行：按指令操作码的要求执行该指令。执行过程可能需要多步操作，控制器将为之形成完成该指令功能所需要的操作控制信号。执行完毕后,回到取指令阶段，去取下一条指令。如此反复，直到整个程序执行完。</li></ol><h3 id="模型机mips结构的简单实现"><a class="markdownIt-Anchor" href="#模型机mips结构的简单实现"></a> 模型机:MIPS结构的简单实现</h3><p>所包含的指令</p><ul><li>算术逻辑运算指令（R类型指令格式）<ul><li>add，sub，and，or，slt</li><li>操作码字段Op=0</li></ul></li><li>存储器访问指令（I类型指令格式）<ul><li>lw（load word，op=35）</li><li>sw（store word，Op=43）</li></ul></li><li>等于“0”分支（I类型指令格式）<ul><li>beqz，Op=63</li><li>说明：beqz在MIPS中实际上是条伪指令。<br /><strong>R</strong></li></ul></li></ul><p><img src="/images/2026-01-11/PixPin_2026-01-14_10-29-31.webp" alt="alt text" /></p><ul><li><p><strong>Op</strong> —— 操作码字段<br />用 IR[Op] 或 IR[31:26] 表示</p></li><li><p><strong>rs</strong> —— 第一源操作数字段<br />用 IR[rs] 或 IR[25:21] 表示</p></li><li><p><strong>rt</strong> —— 第二源操作数字段<br />用 IR[rt] 或 IR[20:16] 表示</p></li><li><p><strong>rd</strong> —— 目标操作数字段(或结果字段)<br />用 IR[rd] 或 IR[15:11] 表示</p></li><li><p><strong>shamt</strong> —— 无用</p></li><li><p><strong>funct</strong> —— ALU 指令的运算函数码字段<br />用 IR[funct] 或 IR[5:0] 表示</p></li></ul><hr /><p><strong>I</strong></p><p><img src="/images/2026-01-11/PixPin_2026-01-14_10-30-12.webp" alt="alt text" /></p><ul><li><p><strong>rs</strong> —— 基址寄存器字段<br />用 IR[rs] 或 IR[25:21] 表示<br />对于 beqz 指令来说, 是存放被检测的数据</p></li><li><p><strong>adr</strong> —— 偏移量字段<br />用 IR[adr] 或 IR[15:0] 表示<br />rs 和 adr 用于计算访存有效地址或分支目标地址</p></li><li><p><strong>rt</strong> —— 寄存器字段<br />对于 load 指令来说, rt 所指出的寄存器是存放所取的数据<br />对于 store 指令来说, 是存放要写入存储器的数据</p></li></ul><h3 id="构建基本的数据通路"><a class="markdownIt-Anchor" href="#构建基本的数据通路"></a> 构建基本的数据通路</h3><p><img src="/images/2026-01-11/PixPin_2026-01-14_10-39-16.webp" alt="alt text" /></p><ul><li>程序计数器(PC):指出当前正在执行的指令的地址,每执行一条指令,PC+4</li><li>指令存储器(IM):假设IM内已经加载好了所需的指令,在IA加载地址,就可以从Ins得到对应指令</li><li>数据存储器(DM):两个输入端,一个是DA,给出要写入或读出的存储单元的地址,另一个是WD,给出要写入DM的数据;有两个控制信号:DMRead和DMWrite,任何时候最多只有一个有效</li><li>通用寄存器组:输入端有4个,RR1和RR2给出两个读操作的地址,WR给出写操作的地址,WD给出要写入的数据;输出端有两个:RD1和RD2分别给出读出的寄存器单元的数据;有一个控制信号RegWrite,当对寄存器组进行写入时才有效</li><li>ALU:输入两个32位的数据,输出ALUo是运算结果,由ALUCtrl(4位)给出运算操作</li><li>加法器:将两个输入数据相加,结果放到输出端SUM</li><li>符号位扩展部件:把16位的数据按符号扩展为32位的数据</li><li>判0部件:输入一个32位的数据,输出是一位信号,若输入为0时输出为真<br /><img src="/images/2026-01-11/PixPin_2026-01-14_10-53-11.webp" alt="alt text" /></li></ul><h4 id="构建r类指令"><a class="markdownIt-Anchor" href="#构建r类指令"></a> 构建R类指令</h4><p><img src="/images/2026-01-11/PixPin_2026-01-14_10-55-38.webp" alt="alt text" /></p><h4 id="构建访存指令load和store"><a class="markdownIt-Anchor" href="#构建访存指令load和store"></a> 构建访存指令(load和store)</h4><p><img src="/images/2026-01-11/PixPin_2026-01-14_10-58-09.webp" alt="alt text" /><br /><img src="/images/2026-01-11/PixPin_2026-01-14_10-59-29.webp" alt="alt text" /><br /><img src="/images/2026-01-11/PixPin_2026-01-14_11-01-46.webp" alt="alt text" /></p><h4 id="beqz指令"><a class="markdownIt-Anchor" href="#beqz指令"></a> beqz指令</h4><p><img src="/images/2026-01-11/PixPin_2026-01-14_11-10-09.webp" alt="alt text" /><br /><img src="/images/2026-01-11/PixPin_2026-01-14_11-10-38.webp" alt="alt text" /></p><h3 id="alu控制器"><a class="markdownIt-Anchor" href="#alu控制器"></a> ALU控制器</h3><p><img src="/images/2026-01-11/PixPin_2026-01-14_11-18-57.webp" alt="alt text" /></p><blockquote><p>ALU完成具体的运算有5个：加、减、或、与、比较</p></blockquote><p><img src="/images/2026-01-11/PixPin_2026-01-14_11-20-40.webp" alt="alt text" /></p><h3 id="多周期实现方案"><a class="markdownIt-Anchor" href="#多周期实现方案"></a> 多周期实现方案</h3><h4 id="为什么用多周期"><a class="markdownIt-Anchor" href="#为什么用多周期"></a> 为什么用多周期</h4><p><strong>单周期方案的不足</strong></p><ul><li><p><strong>效率低下</strong><br />不同类型的指令所完成的工作量有很大的差别<br />所要用到的部件和所通过的数据通路不同<br />所用时间的长短也有很大的差别</p></li><li><p><strong>硬件利用率低</strong><br />每个时钟周期中功能部件最多被使用一次<br />如果在执行一条指令的过程中多次使用某一部件<br />就需要重复设置该部件（增加实现成本）</p></li></ul><hr /><p><strong>解决方法：采用多周期方案</strong></p><ul><li>采用更短的时间作为时钟周期</li><li>允许一条指令的执行跨越多个时钟周期</li><li>该时钟周期通常等于一个基本部件的延迟时间</li></ul><p><strong>好处</strong></p><ul><li>可以共享同一个功能部件</li></ul><h3 id="控制器设计"><a class="markdownIt-Anchor" href="#控制器设计"></a> 控制器设计</h3><p>实现控制器的技术有两种：硬连逻辑和微程序设计</p><ul><li>硬连逻辑是建立在有限状态机的基础上，并且一般是以状态图的形式表示。</li><li>微程序设计则是采用微指令的方式来表示和实现控制。</li></ul><h4 id="控制器的组成"><a class="markdownIt-Anchor" href="#控制器的组成"></a> 控制器的组成</h4><ul><li>指令部件<ul><li>程序计数器PC</li><li>指令寄存器IR</li><li>指令译码器ID</li><li>地址形成部件</li></ul></li><li>时序控制部件<ul><li>时钟脉冲CP</li><li>时序信号发生器</li></ul></li><li>微操作控制信号形成部件</li><li>中断控制逻辑</li><li>程序状态寄存器</li></ul><h3 id="流水线技术"><a class="markdownIt-Anchor" href="#流水线技术"></a> 流水线技术</h3><blockquote><p>什么是流水线技术<br />定义：<br />流水线技术是把一条指令的执行过程划分为若干个顺序阶段，每个阶段由专门的部件完成，不同指令在不同阶段上并行执行的一种处理技术。</p></blockquote><blockquote><p>为什么要采用流水线技术<br />提高处理器吞吐率：在同一时间并行处理多条指令的不同阶段，使单位时间内完成的指令数增加<br />提高硬件利用率：各功能部件（取指、译码、执行等）可以同时工作，减少空闲时间<br />提升整体性能：在不显著增加主频的情况下，提高平均指令执行速度</p></blockquote><h2 id="第九章-微程序控制器"><a class="markdownIt-Anchor" href="#第九章-微程序控制器"></a> 第九章 微程序控制器</h2><blockquote><p>组合逻辑控制器存在的两个比较突出的缺点:</p></blockquote><ul><li>设计复杂、繁琐，缺乏规律性，设计效率低</li><li>不易修改和扩充，缺乏灵活性</li></ul><blockquote><p>微程序控制器的缺点:速度比较慢</p></blockquote><ul><li>因此RISC仍旧采用硬连逻辑设计</li></ul><h3 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h3><blockquote><p>用二进制编码字（称为微指令字）来代替组合逻辑控制器中的微操作控制信号的产生</p></blockquote><h4 id="微操作和微命令"><a class="markdownIt-Anchor" href="#微操作和微命令"></a> 微操作和微命令</h4><p>微命令:构成控制信号序列的最小单位<br />微操作:接受微命令后进行的最基本的操作</p><ul><li>分为两种：<ul><li>相容的微操作：可以同时进行的微操作</li><li>互斥的微操作：不能同时进行的微操作</li></ul></li></ul><h4 id="微指令和微程序"><a class="markdownIt-Anchor" href="#微指令和微程序"></a> 微指令和微程序</h4><p><strong>微指令</strong><br />微指令：用来产生微控制信号的二进制编码字,用于控制完成一组微操作</p><p><strong>微程序</strong><br />微程序：由一系列微指令构成的有序集合<br />每一条机器指令都对应一段微程序<br />通过解释执行该微程序，完成指令所规定的操作</p><hr /><h4 id="微指令周期"><a class="markdownIt-Anchor" href="#微指令周期"></a> 微指令周期</h4><p><strong>微指令周期</strong><br />微指令周期：微程序控制器的工作周期<br />从控制存储器中读取一条微指令到执行完相应微操作所需时间的最大值</p><h3 id="微指令的编码方法"><a class="markdownIt-Anchor" href="#微指令的编码方法"></a> 微指令的编码方法</h3><blockquote><p>设计目标: 减少微指令的宽度, 减少微程序的长度, 提高执行速度, 保持微程序设计的灵活性</p></blockquote><p>共有四种编码方法</p><hr /><h4 id="直接控制编码法不译码法"><a class="markdownIt-Anchor" href="#直接控制编码法不译码法"></a> 直接控制编码法(不译码法)</h4><ul><li>微操作控制字段的每一位直接对应一个微操作</li><li>当某位为 1 时, 表示执行相应的微操作;为 0 时不执行该微操作</li></ul><p><strong>优点</strong></p><ul><li>结构简单</li><li>并行性最好</li><li>操作速度快</li></ul><p><strong>缺点</strong></p><ul><li>微指令字太长<br /><img src="/images/2026-01-11/PixPin_2026-01-14_14-53-30.webp" alt="alt text" /></li></ul><hr /><h4 id="最短字长编码法"><a class="markdownIt-Anchor" href="#最短字长编码法"></a> 最短字长编码法</h4><ul><li>将所有微命令进行统一的二进制编码</li><li>每条微指令只定义一个微操作</li></ul><p><strong>微操作控制字段长度关系</strong></p><ul><li><p>微操作控制字段长度 L 与微命令总数 N 的关系</p><ul><li>L ≥ log2 N</li></ul></li></ul><p><strong>优缺点</strong></p><ul><li>微指令字长最短</li><li>需要经过译码才能得到所需的微命令, 执行速度受影响</li><li>一条微指令只能产生一个微命令</li><li>无法利用硬件的并行性<br /><img src="/images/2026-01-11/PixPin_2026-01-14_14-54-21.webp" alt="alt text" /></li></ul><hr /><h4 id="字段直接编码法"><a class="markdownIt-Anchor" href="#字段直接编码法"></a> 字段直接编码法</h4><ul><li>将微操作控制字段进一步划分为若干字段</li><li>每个字段单独编码</li><li>每个码点表示一个微命令</li></ul><p><strong>折中方案</strong></p><ul><li>字段之间采用直接控制</li><li>字段内部采用最短字长编码</li></ul><p><strong>字段划分原则</strong></p><ul><li><p>可按功能或部件划分</p><ul><li>对机器中的每一类功能或每一个部件分配一个字段</li></ul></li><li><p>将互斥的微操作分在同一字段</p></li><li><p>将相容的微操作分在不同字段</p></li><li><p>字段划分应与数据通路相适应</p></li><li><p>一般每个字段应保留一个码点,用于表示不发任何微命令<br /><img src="/images/2026-01-11/PixPin_2026-01-14_14-55-50.webp" alt="alt text" /></p></li></ul><hr /><h4 id="字段间接编码"><a class="markdownIt-Anchor" href="#字段间接编码"></a> 字段间接编码</h4><ul><li>字段编码的含义需要由另一个字段的编码来解释确定</li><li>一个解释字段可同时对多个字段进行控制</li><li>只有这样才能有效缩短微指令字长</li><li>解释字段应具有一定的分类特征<br /><img src="/images/2026-01-11/PixPin_2026-01-14_14-56-53.webp" alt="alt text" /></li></ul><hr /><h4 id="常数源字段的设置"><a class="markdownIt-Anchor" href="#常数源字段的设置"></a> 常数源字段的设置</h4><p><strong>作用</strong></p><ul><li>提供常数</li><li>参与其他字段的间接编码</li></ul><h3 id="微指令的格式"><a class="markdownIt-Anchor" href="#微指令的格式"></a> 微指令的格式</h3><p>分为两大类: 水平型微指令 和 垂直型微指令</p><hr /><h4 id="水平型微指令"><a class="markdownIt-Anchor" href="#水平型微指令"></a> 水平型微指令</h4><p>一次能定义并执行多个微操作的微指令</p><p><strong>特点</strong></p><ul><li><p>微指令字较长,一般为几十位到上百位</p></li><li><p>描述并行微操作的能力强<br />在一个微周期中可并行执行多个微操作</p></li><li><p>微指令译码简单<br />一般采用直接控制编码法和分段直接编码法</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点</p><ul><li>并行操作能力强</li><li>执行速度快</li><li>代码长度短</li></ul></li><li><p>缺点</p><ul><li>微指令字较长,明显增加控存宽度</li><li>微程序编制复杂,难度较大,不易实现设计自动化</li></ul></li></ul><hr /><h4 id="垂直型微指令"><a class="markdownIt-Anchor" href="#垂直型微指令"></a> 垂直型微指令</h4><blockquote><p>一次只能定义一两个微操作,微指令字长较短</p></blockquote><p><strong>特点</strong></p><ul><li><p>微指令字短<br />一般为十几位到二十位左右</p></li><li><p>并行微操作能力差<br />一条微指令只能控制数据通路的一两种信息传送</p></li><li><p>通过微操作码字段定义微指令的基本功能和信息传送路径<br />执行时需要完全译码<br />译码过程较复杂</p></li><li><p>微指令各二进制位与数据通路控制点之间不存在直接对应关系</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点</p><ul><li>结构直观、规整,易于编制微程序</li><li>微指令字较短,控存横向较窄</li></ul></li><li><p>缺点</p><ul><li>微程序较长,微指令需经译码产生微命令,执行速度较慢</li><li>描述并行微操作能力差,不适合并行性较强的数据通路机器</li></ul></li></ul><h3 id="后续微地址的产生"><a class="markdownIt-Anchor" href="#后续微地址的产生"></a> 后续微地址的产生</h3><blockquote><p>两种方式: 增量方式, 断定方式</p></blockquote><hr /><h4 id="增量方式"><a class="markdownIt-Anchor" href="#增量方式"></a> 增量方式</h4><ul><li>设置一个微程序计数器 μPC</li><li>顺序执行时<br />给 μPC 增加一个增量(通常为 1), 得到下一条微指令地址</li><li>遇到转移时<br />由微指令给出转移目标微地址</li></ul><p><strong>微地址字段 SCF 的组成</strong></p><ul><li><p>转移控制字段 BCF<br />用于规定是顺序执行还是转移<br />若为转移, 由 BCF 指出转移地址的来源</p></li><li><p>转移地址字段 BAF<br /><img src="/images/2026-01-11/PixPin_2026-01-14_15-45-43.webp" alt="alt text" /><br /><strong>转移地址的来源有 3 种</strong></p></li><li><p>由 BAF 给出的地址</p></li><li><p>机器指令所对应微程序的入口地址</p></li><li><p>微子程序入口地址和返回地址<br />返回地址存放在返回地址寄存器中</p></li></ul><p><strong>优点</strong></p><ul><li>SCF 字段较短</li><li>后继微地址生成逻辑较简单</li><li>微程序编制较容易</li></ul><p><strong>缺点</strong></p><ul><li>不能直接实现多路转移</li></ul><hr /><h4 id="断定方式"><a class="markdownIt-Anchor" href="#断定方式"></a> 断定方式</h4><p><strong>后继微地址的确定方式</strong></p><ul><li><p>由微程序设计者直接指定</p></li><li><p>由微程序设计者指定的测试判别逻辑字段控制产生<br /><img src="/images/2026-01-11/PixPin_2026-01-14_15-46-10.webp" alt="alt text" /><br /><strong>后继微地址的组成</strong></p></li><li><p>非测试地址<br />由微程序设计者直接指定<br />地址不变<br />构成微地址的高位部分</p></li><li><p>测试地址<br />在微程序执行过程中<br />通过测试某些状态位动态决定<br />构成微地址的低位部分</p></li></ul><p><strong>分支能力与字段位数</strong></p><ul><li><p>若测试地址位数为 m<br />分支路数为 2^m<br />测试字段个数为 m</p></li><li><p>测试字段位数 n 取决于测试条件个数 N<br />一般有<br />n = [log2 N] + 1</p></li></ul><p><strong>优点</strong></p><ul><li>可实现快速多路转移</li><li>提高微程序执行速度</li><li>微程序在控存中的存放位置灵活、方便</li></ul><p><strong>缺点</strong></p><ul><li>后继微地址生成逻辑较复杂</li><li>微程序执行顺序不直观</li></ul><h3 id="微指令的执行方式"><a class="markdownIt-Anchor" href="#微指令的执行方式"></a> 微指令的执行方式</h3><h4 id="串行执行"><a class="markdownIt-Anchor" href="#串行执行"></a> 串行执行</h4><blockquote><p>取微指令和执行微指令串行进行。在前一条的微指令执行完之后，才能取下一条微指令。<br /><strong>特点</strong><br />设备效率低，执行速度慢。控制简单，易于实现。</p></blockquote><h4 id="并行执行"><a class="markdownIt-Anchor" href="#并行执行"></a> 并行执行</h4><blockquote><p>当前微指令的执行和下一条微指令的取出重叠进行</p></blockquote><p><strong>优点</strong></p><ul><li>提高了执行速度和设备利用率</li></ul><hr /><p><strong>存在的问题</strong></p><ul><li>当需要根据当前微指令的执行结果进行转移时<br />会产生控制上的困难</li></ul><hr /><p><strong>两种处理方法</strong></p><ul><li><p><strong>方法一: 推迟取指</strong><br />推迟下一条微指令的取出<br />使其取出时间与串行执行方式相同</p></li><li><p><strong>方法二: 猜测法</strong><br />采用猜测方式<br />在两条可能的分支中<br />猜测性地选择其中一条作为后继微指令</p></li></ul><h2 id="第十章-运算方法和运算器"><a class="markdownIt-Anchor" href="#第十章-运算方法和运算器"></a> 第十章 运算方法和运算器</h2><h3 id="移位运算"><a class="markdownIt-Anchor" href="#移位运算"></a> 移位运算</h3><h4 id="逻辑移位"><a class="markdownIt-Anchor" href="#逻辑移位"></a> 逻辑移位</h4><p>逻辑移位中,被移动的数据是逻辑数,没有符号和数值大小</p><ol><li>逻辑左移: 数据各位左移一位,最高位丢弃,最低位移入0</li><li>逻辑右移: 依次右移,最低位丢弃,最高位移入0</li></ol><h4 id="循环移位"><a class="markdownIt-Anchor" href="#循环移位"></a> 循环移位</h4><p>将被移位的数据左右两端相连形成闭合回路<br />如10011左移变成00111</p><h4 id="算术移位"><a class="markdownIt-Anchor" href="#算术移位"></a> 算术移位</h4><p>对带符号的数进行移位;会引发数值变化</p><h5 id="原码算术移位"><a class="markdownIt-Anchor" href="#原码算术移位"></a> 原码算术移位</h5><p>符号位不参加移位,将相应数值进行逻辑移位</p><h5 id="补码算术移位"><a class="markdownIt-Anchor" href="#补码算术移位"></a> 补码算术移位</h5><p>对补码进行算术移位时,符号位一起参与移位</p><ol><li>算术左移: 连同符号位一起左移一位,最高位丢弃,最低位移入0</li><li>算术右移:连同符号位一起右移一位,符号位不变,最低位移出丢弃</li></ol><ul><li>左移时可能发生溢出,取模时得到负数</li></ul><h3 id="定点数加减法运算"><a class="markdownIt-Anchor" href="#定点数加减法运算"></a> 定点数加减法运算</h3><h4 id="补码加减法"><a class="markdownIt-Anchor" href="#补码加减法"></a> 补码加减法</h4><p>若符号位产生进位则舍弃进位</p><h4 id="判断溢出"><a class="markdownIt-Anchor" href="#判断溢出"></a> 判断溢出</h4><blockquote><p><strong>采用两个操作数和结果的符号来判断</strong><br />当两个同号数的补码相加，若得到的结果的符号与两个操作数的符号不同，则发生了溢出</p></blockquote><blockquote><p><strong>采用最高数值位产生的进位与符号位产生的进位是否相同来判断</strong> ,当不相同时，则发生了溢出</p></blockquote><p><img src="/images/2026-01-11/PixPin_2026-01-14_17-40-21.webp" alt="alt text" /></p><blockquote><p>采用变形补码,将符号位扩展为2位,若运算结果的两个符号位不同,则发生了溢出</p></blockquote><p><img src="/images/2026-01-11/PixPin_2026-01-14_17-46-46.webp" alt="alt text" /></p><h3 id="定点数乘除法运算"><a class="markdownIt-Anchor" href="#定点数乘除法运算"></a> 定点数乘除法运算</h3><h4 id="原码一位乘法"><a class="markdownIt-Anchor" href="#原码一位乘法"></a> 原码一位乘法</h4><p><img src="/images/2026-01-11/PixPin_2026-01-14_17-53-17.webp" alt="alt text" /></p><h3 id="浮点数加减法运算"><a class="markdownIt-Anchor" href="#浮点数加减法运算"></a> 浮点数加减法运算</h3><p>设有两个规格化浮点数 X 和 Y, 分别为<br />X: XEXM<br />Y: YEYM</p><p>其中</p><ul><li>XE 和 YE: 阶码</li><li>XM 和 YM: 尾数</li></ul><hr /><h4 id="浮点加减法运算的步骤"><a class="markdownIt-Anchor" href="#浮点加减法运算的步骤"></a> 浮点加减法运算的步骤</h4><ol><li>判 0 操作</li><li>对阶</li><li>尾数加减</li><li>规格化与舍入<br />（在规格化过程中需要判断运算结果是否溢出）</li></ol><hr /><h4 id="1-判-0-操作"><a class="markdownIt-Anchor" href="#1-判-0-操作"></a> 1. 判 0 操作</h4><ul><li><p>若两个操作数 X 和 Y 中有一个为 0<br />则不需要进行运算<br />直接设置运算结果为 0<br />运算结束</p></li><li><p>否则进入下一步</p></li></ul><hr /><h4 id="2-对阶"><a class="markdownIt-Anchor" href="#2-对阶"></a> 2. 对阶</h4><p><strong>目的</strong></p><ul><li>使小数点对齐</li></ul><p><strong>方法</strong></p><ul><li>对其中一个操作数进行变换<br />使两个操作数的阶码相等</li></ul><ul><li>对齐大阶码<br /><strong>实现步骤</strong></li></ul><ol><li><p>求阶差<br />△E = XE − YE</p></li><li><p>若 △E &gt; 0</p><ul><li><p>表示 X 的阶码大于 Y 的阶码</p></li><li><p>调整操作数 Y</p><ul><li>将 Y 的尾数 YM 右移</li><li>每右移一位<br />阶码 YE 加 1</li><li>直到两数阶码相等</li></ul></li></ul></li><li><p>若 △E &lt; 0</p><ul><li>表示 X 的阶码小于 Y 的阶码</li><li>调整操作数 X</li><li>调整方法与上述相同</li></ul></li></ol><hr /><h4 id="3-尾数加减"><a class="markdownIt-Anchor" href="#3-尾数加减"></a> 3. 尾数加减</h4><ul><li>将两数的尾数 XM 和 YM<br />按照相应的定点加减运算规则<br />进行加法或减法运算</li><li>得到运算结果的尾数</li></ul><hr /><h4 id="4-结果规格化并判溢出"><a class="markdownIt-Anchor" href="#4-结果规格化并判溢出"></a> 4. 结果规格化并判溢出</h4><ol><li><p>右规情况</p><ul><li><p>若运算结果的绝对值大于 1</p><ul><li>将结果右移一位</li><li>相应的阶码加 1</li><li>右规最多只需一位</li></ul></li></ul></li><li><p>左规情况</p><ul><li><p>若运算结果的绝对值小于 1</p><ul><li>将结果左移</li><li>每左移一位<br />阶码减 1</li><li>直到结果的绝对值大于等于 1/2 为止</li></ul></li></ul></li><li><p>溢出判断</p><ul><li><p>每次阶码加 1 或减 1 后<br />都要判断阶码是否越界</p></li><li><p>阶码上溢</p><ul><li>阶码大于可表示的最大正数</li><li>可置溢出标志</li><li>或将结果作为 +∞ 或 −∞ 处理</li></ul></li><li><p>阶码下溢</p><ul><li>阶码小于可表示的最小负数</li><li>可置溢出标志</li><li>或将结果作为 0 处理</li></ul></li></ul></li></ol><hr /><h4 id="5-舍入处理"><a class="markdownIt-Anchor" href="#5-舍入处理"></a> 5. 舍入处理</h4><p>常用的舍入方法有</p><ol><li>0 舍 1 入法:类似四舍五入</li><li>截断法:直接舍去右移的数字</li><li>朝 +∞ 舍入法:若为正数,只要移出的数位不全为0,则最低有效位加1;若为负数则采用截断法</li><li>朝 −∞ 舍入法:若为负数,只要移出的数位不全为0,则最低有效位加1;若为正数则采用截断法</li></ol><h2 id="第十一章-存储器"><a class="markdownIt-Anchor" href="#第十一章-存储器"></a> 第十一章 存储器</h2><h3 id="存储子系统概述"><a class="markdownIt-Anchor" href="#存储子系统概述"></a> 存储子系统概述</h3><blockquote><p>三级存储系统:</p><ul><li>Cache（高速缓冲存储器）</li><li>主存储器</li><li>磁盘存储器（辅存）</li></ul></blockquote><ul><li><p>最靠近CPU的Cache速度最快,容量最小;离CPU最远的硬盘速度最慢，但容量最大</p></li><li><p>CPU所访问的指令和数据的绝大部分都能在Cache中找到,之所以可以做到,是根据程序访问的局部性原理,即程序在一小段时间间隔内访问的指令和数据在地址上是相对集中的</p></li><li><p>两个存储层次</p><ul><li>“Cache—主存”层次：解决主存速度不足的问题</li><li>“主存—辅存”层次：解决主存容量不足的问题<br /><img src="/images/2026-01-11/PixPin_2026-01-13_21-57-01.webp" alt="alt text" /></li></ul></li></ul><h3 id="存储器分类"><a class="markdownIt-Anchor" href="#存储器分类"></a> 存储器分类</h3><h4 id="按在计算机系统中的作用分类"><a class="markdownIt-Anchor" href="#按在计算机系统中的作用分类"></a> 按在计算机系统中的作用分类</h4><ol><li><strong>主存储器</strong>,又简称为主存或内存。</li></ol><ul><li>它是整个存储系统的核心，用来存放计算机当前运行的程序以及所需的数据，CPU可直接随机地对它进行访问。</li></ul><ol start="2"><li><strong>辅助存储器</strong>,简称为辅存或外存</li></ol><ul><li>弥补主存的容量不足,用来存放暂时不用的程序和数据。CPU不能直接访问它，当需要运行辅助存储器中的程序时，需将它们调入主存后供CPU使用。</li></ul><ol start="3"><li>高速缓冲存储器Cache</li></ol><ul><li>弥补主存的速度不足,位于CPU和主存储器之间</li></ul><h4 id="按照存取方式分类"><a class="markdownIt-Anchor" href="#按照存取方式分类"></a> 按照存取方式分类</h4><blockquote><p>存取方式：指访问存储单元的方法</p></blockquote><ul><li><p><strong>随机存储器 RAM</strong><br />Random Access Memory</p></li><li><p><strong>只读存储器 ROM</strong><br />Read Only Memory</p></li><li><p><strong>顺序存取存储器 SAM</strong><br />Sequential Access Memory</p></li></ul><ol><li>随机存储器RAM</li></ol><blockquote><p>可随机地读取或写入存储器的任何一个单元，访问时间是固定的，与存储单元的物理位置无关</p></blockquote><ul><li>在系统断电后大多数随机存储器RAM所保存的信息将丢失</li><li>常用来作主存和Cache</li></ul><ol start="2"><li>只读存储器ROM</li></ol><blockquote><p>只能随机读取存储器的任何一个单元，不能写入信息。</p></blockquote><ul><li>系统断电后，所保存的信息不会丢失。</li><li>用来存放不需要改变的信息,比如存放系统程序</li></ul><ol start="3"><li>顺序存取存储器SAM</li></ol><blockquote><p>只能按顺序访问存储器中的信息，访问时间与信息在存储器中所处的物理位置有关。</p></blockquote><ul><li>信息通常以文件或数据块的形式存放,如磁带</li></ul><h4 id="按照存储介质分类"><a class="markdownIt-Anchor" href="#按照存储介质分类"></a> 按照存储介质分类</h4><blockquote><p>存储介质一般具备3个特点:</p></blockquote><ol><li><p>具有两种稳定的状态，分别代表二进制代码0和1</p></li><li><p>能方便地检测出存储介质所处的状态</p></li><li><p>两种状态容易相互转换</p></li><li><p>半导体存储器</p></li><li><p>磁表面存储器</p></li><li><p>光存储器</p></li></ol><h3 id="主存储器"><a class="markdownIt-Anchor" href="#主存储器"></a> 主存储器</h3><h4 id="主存的组成结构"><a class="markdownIt-Anchor" href="#主存的组成结构"></a> 主存的组成结构</h4><ol><li>存储体</li></ol><blockquote><p>存储二进制信息的主体，由许多存储单元构成，每一个存储单元存放1～8个字节<br />每一个存储单元都有一个统一的编号，称为地址,地址与存储单元之间是一一对应的。</p></blockquote><ol start="2"><li>地址译码和驱动电路</li><li>读写电路</li><li>存储控制电路</li></ol><h3 id="主存的主要技术指标"><a class="markdownIt-Anchor" href="#主存的主要技术指标"></a> 主存的主要技术指标</h3><h4 id="存储容量"><a class="markdownIt-Anchor" href="#存储容量"></a> 存储容量</h4><p>一个存储器中所能存储的二进制信息的总量.<br />常用位 b 和字节 B 来表示<br />如 64Kb, 512KB, 4MB.</p><hr /><h4 id="存取速度"><a class="markdownIt-Anchor" href="#存取速度"></a> 存取速度</h4><p>指访问存储器的速度.</p><p><strong>存取时间 TA</strong><br />又称访问时间或读写时间, 指从启动一次存储器访存操作到完成该操作所需要的时间.</p><p><strong>存储周期 TM</strong><br />指连续两次启动存储器访问所需的最小时间间隔.</p><ul><li>包括存储器的存取时间和自身恢复时间.</li><li>存储周期通常大于或等于存取时间.</li></ul><p><strong>主存带宽 BM</strong><br />存储器单位时间内所能存取的信息量.</p><ul><li>也称为数据传输率或主存的数据传输频率.</li><li>单位为 bit/s 或 byte/s.</li></ul><p>BM 的计算公式为:</p><ul><li>BM = 每个存储单元的位数 / TM (bit/s)</li><li>BM = 每个存储单元的位数 / (TM × 8) (byte/s)</li></ul><p>提高 BM 的方法有三种:</p><ul><li>增加存储单元的位数</li><li>减少 TM</li><li>采用多个存储体</li></ul><hr /><h4 id="可靠性"><a class="markdownIt-Anchor" href="#可靠性"></a> 可靠性</h4><p>在规定的时间内, 存储器无故障读写的概率.<br />通常用平均无故障间隔时间 MTBF (Mean Time Between Failures) 来衡量.<br />MTBF 越长, 说明存储器的可靠性越高.</p><hr /><h4 id="功耗"><a class="markdownIt-Anchor" href="#功耗"></a> 功耗</h4><p>指单位时间存储器所消耗的电能,功耗越小越好</p><h3 id="随机存储器"><a class="markdownIt-Anchor" href="#随机存储器"></a> 随机存储器</h3><h4 id="静态随机存储器sram"><a class="markdownIt-Anchor" href="#静态随机存储器sram"></a> 静态随机存储器SRAM</h4><blockquote><p>利用触发器来储存二进制信息<br />优点：SRAM 工作速度快，稳定可靠，不需要外加刷新电路，从而简化了外电路设计<br />缺点：所含晶体管较多，故集成度较低，功耗较大</p></blockquote><h4 id="动态随机存储器dram"><a class="markdownIt-Anchor" href="#动态随机存储器dram"></a> 动态随机存储器DRAM</h4><blockquote><p>利用 MOS 晶体管的管极电容来存储二进制信息<br />优点：基本存储位元电路中所含晶体管数目少、集成度高、成本低、功耗小<br />缺点：它需外加刷新电路，工作速度比 SRAM 慢得多（破坏性读出且需要刷新）</p></blockquote><h3 id="dram的刷新"><a class="markdownIt-Anchor" href="#dram的刷新"></a> DRAM的刷新</h3><blockquote><p>什么叫刷新：为维持 DRAM 所存信息不变，需要定时地对 DRAM 中的电容充电，以补充泄漏掉的电荷。这个过程叫刷新</p></blockquote><blockquote><p>DRAM 为什么需要刷新： DRAM 是利用电容上保存的电荷来存储信息的，由于存在漏电阻，即使电源不掉电，时间长了，电容上的电荷也会慢慢泄漏掉，DRAM 内存储的信息会自动消失。</p></blockquote><blockquote><p>什么叫刷新周期：从上一次对整个存储器刷新结束到下一次对整个存储器刷新结束所需的时间</p></blockquote><ol><li>集中式刷新：在一个刷新周期内，集中一段时间连续地对全部存储单元逐行刷新一遍。</li></ol><ul><li>在刷新操作期间，不允许 CPU 对存储器进行正常的访问</li></ul><p>优点：读写操作时不受刷新工作的影响，系统的存取速度比较高<br />缺点：在集中刷新期间必须停止读写，这一段时间称为“死区”，而且存储容量越大，死区就越长。<br />2. 分散式刷新：把对每行存储单元的刷新分散到每个系统存取周期内完成。此时系统存取周期被分为两部分，周期前半段时间进行正常的存储器访问，后半段时间进行刷新操作。在一个系统存取周期内刷新存储矩阵中的一行,增加了系统的存取周期<br />优点：没有死区<br />缺点：刷新过于频繁。系统存取周期是存储芯片存取周期的两倍，降低了访问存储器的速度。<br />3. 异步式刷新：把刷新操作平均分配到整个最大刷新间隔内进行，相邻两行的刷新间隔为：刷新周期÷行数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;考试事项&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#考试事项&quot;&gt;&lt;/a&gt; 考试事项&lt;/h2&gt;
&lt;p&gt;考试分数占比60%&lt;br /&gt;
填空15分 一空一分&lt;br /&gt;
选择20分 20道题&lt;br /&gt;
综合题65分 七道大题,基本一个</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://revival-of-hope.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-11 再战算法</title>
    <link href="https://revival-of-hope.github.io/2026/01/11/archives-2026-01-11-%E5%86%8D%E6%88%98%E7%AE%97%E6%B3%95/"/>
    <id>https://revival-of-hope.github.io/2026/01/11/archives-2026-01-11-%E5%86%8D%E6%88%98%E7%AE%97%E6%B3%95/</id>
    <published>2026-01-11T00:00:00.000Z</published>
    <updated>2026-01-18T06:06:41.798Z</updated>
    
    <content type="html"><![CDATA[<p>昨天考了程序设计范式,一开始觉得三个小时三道题不是有手就行,后来发现我太天真了.</p><p>第一道题是leetcode2002,一道关于不相交回文子串的中级题,我硬是没想到用dfs做,可能是一个月没碰算法生疏了吧,<br />第二道题是设计几个角色的类,考察多态和继承,还真有点难,报错信息我都看不懂,第三道题是求满足给定和的最短子串,尽管我一开始就把双指针写出来了,但却在一些测试数据中一直死循环,还好机房上装了vscode,不然我都不知道要怎么调试,前前后后最少调了半个小时才解决这个问题,只能说是在第一题没做出来的情况下太紧张脑子短路了.</p><p>这一顿折腾下来,我才发现我连最基本的dfs都没能很好地掌握,连普通的课程考试都过不了关,啥也不说了,速速去刷题,<br />之前看了百度之星的题目,彻底断了打acm的念想,但刷点水题娱乐一下也是挺好的,不仅能应付考试,还能应付面试.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天考了程序设计范式,一开始觉得三个小时三道题不是有手就行,后来发现我太天真了.&lt;/p&gt;
&lt;p&gt;第一道题是leetcode2002,一道关于不相交回文子串的中级题,我硬是没想到用dfs做,可能是一个月没碰算法生疏了吧,&lt;br /&gt;
第二道题是设计几个角色的类,考察多态和继承</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-03 考研人数的下降</title>
    <link href="https://revival-of-hope.github.io/2026/01/03/archives-2026-01-03-%E6%84%9F%E6%83%B3/"/>
    <id>https://revival-of-hope.github.io/2026/01/03/archives-2026-01-03-%E6%84%9F%E6%83%B3/</id>
    <published>2026-01-03T00:00:00.000Z</published>
    <updated>2026-01-06T09:58:00.774Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2026-01-03/PixPin_2026-01-03_21-30-11.webp" alt="" /></p><p><img src="/images/2026-01-03/PixPin_2026-01-03_21-46-12.webp" alt="" /><br />可以看出来,尽管本科毕业人数越来越多,研究生招生人数越来越多,报考研究生的人数却越来越少,接着看下图<br /><img src="/images/2026-01-03/PixPin_2026-01-03_21-56-44.webp" alt="" /><br /><img src="/images/2026-01-03/PixPin_2026-01-03_21-57-46.webp" alt="" /><br />疫情的影响太大了,大家都开始捂住钱包,不会再去做大胆的投资了,因此收入较稳定的餐饮业扶摇直上,而旅游业直到现在也未必恢复了元气.<br /><img src="/images/2026-01-03/PixPin_2026-01-03_22-07-44.webp" alt="" /><br />越来越多的人选择去找一些稳定的工作如公务员,医护人员,不愿意去创业了.</p><p>顺带一提还有战败cg,尽管没有今年的数据,但我相信降幅不会相差太多<br /><img src="/images/2026-01-03/PixPin_2026-01-03_21-50-15.webp" alt="" /></p><blockquote><p>这也是普通人的无奈吧,尽管身处这个时代,却连发生了什么都难以把握,只能隐约感觉到大环境不好,却找不到合理的数据来帮自己掌握一点点情况,连知情权也被剥夺,不知道下一步要怎么走,迷茫的在原地打转,只好依着惯例提心吊胆的生活,提不上享受生活,只看得见压抑和悲哀,失去了相信他人的胆量,失去了期盼明天的幸福,只是靠本分承担着责任,不是为了自己,而是为了亲人</p></blockquote><p>很早就想要拿日本跟本国做一个对比了,尽管人口基数差的很离谱,但以前的日本或许就是现在的我们,现在这里预告提醒我自己一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/2026-01-03/PixPin_2026-01-03_21-30-11.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2026-01-03/PixPin_2026-01-03_21-46-12.we</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-02 离散数学整理-图论</title>
    <link href="https://revival-of-hope.github.io/2026/01/02/archives-2025-2026-01-02-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E5%9B%BE%E8%AE%BA/"/>
    <id>https://revival-of-hope.github.io/2026/01/02/archives-2025-2026-01-02-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E5%9B%BE%E8%AE%BA/</id>
    <published>2026-01-02T00:00:00.000Z</published>
    <updated>2026-01-11T14:16:20.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的基本概念"><a class="markdownIt-Anchor" href="#图的基本概念"></a> 图的基本概念</h1><h2 id="有向图"><a class="markdownIt-Anchor" href="#有向图"></a> 有向图</h2><ul><li><code>&lt;V,E&gt;</code>（<code>v = vertex(节点)</code>，<code>e = edge(边)</code>）</li><li>平凡图：只有一个 <code>v</code>，没有 <code>e</code> 的图</li><li>n 阶图：<code>n</code> 为节点数</li><li>邻接：有向边起点邻接到终点，故邻接矩阵中第 <code>n</code> 行为第 <code>n</code> 个节点作为起点，第 <code>n</code> 列为第 <code>n</code> 个节点作为终点，以此统计出度和入度</li></ul><hr /><h2 id="子图"><a class="markdownIt-Anchor" href="#子图"></a> 子图</h2><ul><li>真子图：与原图不一样就行</li><li>生成子图：节点数一样就行，边可以比原图连的少，但不能自己加边</li><li>导出子图：可以不用到所有节点，但母图中对应用到节点的边都要保留（或者不用到所有边，但对应的节点保留（废话，你都用到边了，那没节点哪来的边））</li></ul><hr /><h2 id="补图"><a class="markdownIt-Anchor" href="#补图"></a> 补图</h2><blockquote><p><strong>补图</strong>：设简单无向图 G = (V, E)，其补图记为 Ḡ = (V, Ē)，其中</p><ul><li>Ē = { {u, v} | u, v ∈ V，u ≠ v，且 {u, v} ∉ E }<br />即在保持顶点集不变的情况下，Ḡ 中的边恰好是 G 中不存在的边。</li></ul></blockquote><hr /><h2 id="同构图"><a class="markdownIt-Anchor" href="#同构图"></a> 同构图</h2><blockquote><p><strong>同构图</strong>：设图 G₁ = (V₁, E₁)，G₂ = (V₂, E₂)，若存在一个双射 f : V₁ → V₂，使得</p><ul><li>对任意 u, v ∈ V₁，{u, v} ∈ E₁ 当且仅当 {f(u), f(v)} ∈ E₂，</li></ul><p>则称 G₁ 与 G₂ 同构，记为 G₁ ≅ G₂。</p></blockquote><ul><li>顶点数相同，边数相同，度数序列相同,但这只是必要条件，充分条件只能用瞪眼法了</li></ul><hr /><h2 id="连通性"><a class="markdownIt-Anchor" href="#连通性"></a> 连通性</h2><h3 id="回路与通路"><a class="markdownIt-Anchor" href="#回路与通路"></a> 回路与通路</h3><blockquote><p>当一条回路中的所有边互不相同时为简单回路，与此相反，有边相同时就是复杂回路，一个由 3 个节点形成的 <code>8</code> 是简单回路<br />若简单回路中除了初始节点和结束节点相同外，其他节点都不相同，则为初级回路，上文的 <code>8</code> 就不是初级回路</p></blockquote><ul><li>初级回路和简单回路<strong>区分</strong>:初级想成是最基本的,结构最为合理,故不会出现重复节点;简单说明是回路就行,要求少一点</li><li>把上面的回路两个字换成通路就可以得到简单通路,复杂通路,初级通路的定义了</li></ul><blockquote><p>如果 <code>u</code> 到 <code>v</code> 存在通路，则称u和v是连通的,在有向图中称 <code>u</code> 可达 <code>v</code>，若图 <code>G</code> 任意两个顶点都连通，则称 <code>G</code> 是<strong>连通图</strong>，注意平凡图也是连通图<br /><strong>连通分支</strong>:图G相互之间不连通的导出子图<br />G的连通分支的数量记为p(G)</p></blockquote><hr /><h3 id="有向图的连通性"><a class="markdownIt-Anchor" href="#有向图的连通性"></a> 有向图的连通性</h3><h4 id="可达与相互可达"><a class="markdownIt-Anchor" href="#可达与相互可达"></a> 可达与相互可达</h4><p>设有向图 D = &lt;V, E&gt;，u, v ∈ V。</p><ul><li><p><strong>u 可达 v</strong>：<br />从 u 到 v 存在一条有向通路。<br />规定：u 到自身总是可达。</p></li><li><p><strong>u 与 v 相互可达</strong>：<br />u 可达 v 且 v 可达 u。</p></li></ul><hr /><ul><li><strong>弱连通</strong></li></ul><blockquote><p>将 D 中所有有向边忽略方向，得到的无向图是连通图。</p></blockquote><ul><li><strong>单向连通</strong></li></ul><blockquote><p>对任意 u, v ∈ V,u 可达 v 或 v 可达 u</p></blockquote><ul><li><strong>强连通</strong></li></ul><blockquote><p>对任意 u, v ∈ V,u 与 v 相互可达</p></blockquote><h3 id="割集"><a class="markdownIt-Anchor" href="#割集"></a> 割集</h3><p>设 G = (V, E) 为连通图。</p><blockquote><p><strong>边割集</strong>：设 C ⊆ E，若</p><ul><li>图 G − C 不连通；</li><li>对任意 e ∈ C，G − (C \ {e}) 仍连通；<br />则称 C 为 G 的边割集。</li></ul></blockquote><ul><li>即C已经是能够让G不连通的最小边集合了,若C只有一条边e,称e为割边或桥</li></ul><hr /><blockquote><p><strong>点割集</strong>：设 S ⊆ V，若</p><ul><li>图 G − S 不连通或退化为单点图；</li><li>对任意 v ∈ S，G − (S \ {v}) 仍连通；<br />则称 S 为 G 的点割集。</li></ul></blockquote><ul><li>即S已经是能够让G不连通的最小点集合了,若S只有一个顶点v,称v为割点</li></ul><h3 id="分量与割"><a class="markdownIt-Anchor" href="#分量与割"></a> 分量与割</h3><h4 id="连通分量"><a class="markdownIt-Anchor" href="#连通分量"></a> 连通分量</h4><ul><li><p><strong>无向图的连通分量</strong><br />无向图 G 的一个极大连通子图称为 G 的一个连通分量（或连通分支）。</p><ul><li>每一个顶点和每一条边都属于唯一的一个连通分量</li><li>连通图只有一个连通分量，即其自身</li><li>非连通无向图有多个连通分量</li></ul></li><li><p><strong>有向图的强连通分量</strong><br />有向图中的强连通分量是其极大的强连通子图。</p><ul><li>强连通图只有一个强连通分量，即其自身</li><li>非强连通的有向图有多个强连通分量</li></ul></li></ul><hr /><h4 id="点割与点连通度"><a class="markdownIt-Anchor" href="#点割与点连通度"></a> 点割与点连通度</h4><ul><li><p><strong>割点集</strong><br />在连通图 G 中，一个由顶点组成的集合，若从 G 中删除这些顶点后图变得不连通，则称该集合为割点集。</p></li><li><p><strong>点连通度</strong><br />点连通度 κ(G) 定义为割点集中顶点数的最小值。</p></li><li><p><strong>k-点连通图</strong><br />若图 G 可以在删除 k 个顶点后变得不连通，但不能在删除 k−1 个顶点后变得不连通，则称 G 为 k-点连通图。<br />特别地，阶数为 n 的完全图是 (n−1)-点连通的。</p></li></ul><hr /><h4 id="局部连通度"><a class="markdownIt-Anchor" href="#局部连通度"></a> 局部连通度</h4><ul><li><p><strong>u, v 的割点集</strong><br />对一对顶点 u, v，若删除某个顶点集合后使 u 与 v 不连通，则该集合称为 u, v 的割点集。</p></li><li><p><strong>局部连通度</strong><br />κ(u, v) 表示使 u 与 v 不连通的最小割点集的大小。</p></li><li><p><strong>性质</strong></p><ul><li>在无向图中，κ(u, v) = κ(v, u)</li><li>除完全图外，κ(G) 等于所有不相邻顶点对 u, v 的 κ(u, v) 的最小值</li></ul></li></ul><hr /><h4 id="边割与边连通度"><a class="markdownIt-Anchor" href="#边割与边连通度"></a> 边割与边连通度</h4><ul><li><p><strong>桥</strong><br />在图 G 中，删除某一条边后图变得不连通，则该边称为桥。</p></li><li><p><strong>割边集</strong><br />一个由边组成的集合，若删除这些边后图变得不连通，则称为割边集。</p></li><li><p><strong>边连通度</strong><br />λ(G) 表示最小割边集的大小。</p></li><li><p><strong>局部边连通度</strong><br />λ(u, v) 表示使 u 与 v 不连通的最小割边集的大小。</p></li><li><p><strong>k-边连通图</strong><br />若 λ(G) ≥ k，则称图 G 为 k-边连通图。</p></li></ul><hr /><h4 id="连通度之间的关系"><a class="markdownIt-Anchor" href="#连通度之间的关系"></a> 连通度之间的关系</h4><ul><li>设 δ(G) 为图 G 的最小度，则有不等式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">κ(G) ≤ λ(G) ≤ δ(G)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>极大连通图</strong></li><li>若 κ(G) = δ(G)，称 G 为极大连通图</li><li>若 λ(G) = δ(G)，称 G 为极大边连通图</li></ul><h2 id="图的矩阵表示"><a class="markdownIt-Anchor" href="#图的矩阵表示"></a> 图的矩阵表示</h2><hr /><h3 id="无向图的关联矩阵"><a class="markdownIt-Anchor" href="#无向图的关联矩阵"></a> 无向图的关联矩阵</h3><blockquote><p><strong>定义</strong>：设无向图 G = (V, E)，|V| = n，|E| = m。<br />无向图的关联矩阵是一个 n × m 的 0-1 矩阵 M，其中</p><ul><li>M[i][j] = 1或2，当且仅当顶点 v_i 与边 e_j 关联；</li><li>否则 M[i][j] = 0。</li></ul></blockquote><ul><li>关联即顶点作为该边的起点或者终点出现次数,当出现自环时关联次数为2</li><li>每一列都恰好有两个1或一个2</li><li>第i行元素之和为vi的度数,所有元素之和为2m<br /><strong>例</strong>：</li><li>V = {v1, v2, v3, v4}</li><li>E = {<br />e1 = {v1, v2},<br />e2 = {v1, v3},<br />e3 = {v2, v3},<br />e4 = {v4, v4}<br />}</li></ul><table><thead><tr><th></th><th>e1</th><th>e2</th><th>e3</th><th>e4</th></tr></thead><tbody><tr><td>v1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>v2</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>v3</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>v4</td><td>0</td><td>0</td><td>0</td><td>2</td></tr></tbody></table><hr /><h3 id="有向图的关联矩阵"><a class="markdownIt-Anchor" href="#有向图的关联矩阵"></a> 有向图的关联矩阵</h3><blockquote><p><strong>定义</strong>：设无环有向图 G = (V, E)，|V| = n，|E| = m。<br />有向图的关联矩阵是一个 n × m 的矩阵 M，其中</p><ul><li>M[i][j] = -1，若边 e_j 从 v_i 出发；</li><li>M[i][j] = 1，若边 e_j 指向 v_i；</li><li>否则 M[i][j] = 0。</li></ul></blockquote><ul><li>每一列都有一个-1和1</li></ul><p><strong>例</strong>：</p><ul><li>V = {v1, v2, v3, v4}</li><li>E = {<br />e1: v1 → v2,<br />e2: v1 → v3,<br />e3: v2 → v4,<br />e4: v3 → v4<br />}</li></ul><table><thead><tr><th></th><th>e1</th><th>e2</th><th>e3</th><th>e4</th></tr></thead><tbody><tr><td>v1</td><td>-1</td><td>-1</td><td>0</td><td>0</td></tr><tr><td>v2</td><td>1</td><td>0</td><td>-1</td><td>0</td></tr><tr><td>v3</td><td>0</td><td>1</td><td>0</td><td>-1</td></tr><tr><td>v4</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><hr /><h3 id="有向图的邻接矩阵"><a class="markdownIt-Anchor" href="#有向图的邻接矩阵"></a> 有向图的邻接矩阵</h3><blockquote><p><strong>定义</strong>：设有向图 G = (V, E)，|V| = n。<br />有向图的邻接矩阵是一个 n × n 的矩阵 A，其中</p><ul><li>A[i][j] = 1，表示存在从 v_i 到 v_j 的有向边；</li><li>否则 A[i][j] = 0。</li></ul></blockquote><ul><li>所有元素之和等于边数</li></ul><p><strong>例</strong>：</p><ul><li>v1 → v2，v1 → v3，v2 → v4，v3 → v4</li></ul><table><thead><tr><th></th><th>v1</th><th>v2</th><th>v3</th><th>v4</th></tr></thead><tbody><tr><td>v1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>v2</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>v3</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>v4</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><hr /><h3 id="有向图的可达矩阵"><a class="markdownIt-Anchor" href="#有向图的可达矩阵"></a> 有向图的可达矩阵</h3><blockquote><p><strong>定义</strong>：设有向图 G = (V, E)，|V| = n。<br />可达矩阵是一个 n × n 的矩阵 R，其中</p><ul><li>R[i][j] = 1，表示从 v_i 出发存在一条路径可到达 v_j；</li><li>否则 R[i][j] = 0。</li></ul></blockquote><ul><li>由于顶点到自身都是可达的,故可达矩阵对角线上的元素恒为1<br /><strong>例</strong>：<br />基于上述有向图</li></ul><table><thead><tr><th></th><th>v1</th><th>v2</th><th>v3</th><th>v4</th></tr></thead><tbody><tr><td>v1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>v2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>v3</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>v4</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><h2 id="着色问题"><a class="markdownIt-Anchor" href="#着色问题"></a> 着色问题</h2><blockquote><p><em>着色问题</em>：设 G = (V, E) 为无向无环图，给每个顶点分配一种颜色，使得</p><ul><li>若 {u, v} ∈ E，则 u 与 v 的颜色不同,即<strong>相邻顶点颜色不同</strong><br />记使用的最少颜色数为k,称G为k-可着色的</li></ul></blockquote><blockquote><p><strong>Welsh–Powell 算法</strong>：<br />是一种求图顶点着色的启发式算法，其基本思想是优先为度数大的顶点着色。</p></blockquote><p><strong>算法步骤</strong>：</p><ol><li>将图中所有顶点按度数从大到小排序（若度数相同，可任意排列）；</li><li>取尚未着色的第一个顶点，赋予一种新颜色；</li><li>在剩余未着色顶点中，按排序顺序选择与已着该颜色顶点均不相邻的顶点，赋予同一颜色；</li><li>重复步骤 2–3，直到所有顶点均被着色。</li></ol><hr /><p><strong>例题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">设  </span><br><span class="line">V = &#123;v1, v2, v3, v4, v5&#125;  </span><br><span class="line">E = &#123; &#123;v1,v2&#125;, &#123;v1,v3&#125;, &#123;v1,v4&#125;, &#123;v2,v3&#125;, &#123;v3,v4&#125;, &#123;v4,v5&#125; &#125;</span><br><span class="line"></span><br><span class="line">各顶点度数：  </span><br><span class="line">deg(v1)=3，deg(v3)=3，deg(v4)=3，deg(v2)=2，deg(v5)=1  </span><br><span class="line"></span><br><span class="line">排序结果：  </span><br><span class="line">v1, v3, v4, v2, v5  </span><br><span class="line"></span><br><span class="line">着色过程：  </span><br><span class="line">- 颜色 1：v1，v5  </span><br><span class="line">- 颜色 2：v3  </span><br><span class="line">- 颜色 3：v4  </span><br><span class="line">- 颜色 4：v2  </span><br><span class="line"></span><br><span class="line">因此该算法得到 G 为 4-可着色（不一定是最小色数）。</span><br></pre></td></tr></table></figure><h3 id="练手"><a class="markdownIt-Anchor" href="#练手"></a> 练手</h3><p><img src="/images/2026-01-02/PixPin_2026-01-05_18-46-51.webp" alt="" /></p><hr /><p><strong>答案</strong><br /><img src="/images/2026-01-02/PixPin_2026-01-05_18-59-15.webp" alt="" /></p><h1 id="特殊的图"><a class="markdownIt-Anchor" href="#特殊的图"></a> 特殊的图</h1><h2 id="二部图"><a class="markdownIt-Anchor" href="#二部图"></a> 二部图</h2><blockquote><p>把一个图的顶点划分为两个不相交子集，使得每一条边都分别连接两个集合中的顶点，如果存在这样的划分，则此图为一个二部图</p><p>[深入理解](htt ps://blog.csdn.net/qq_26822029/article/details/90382581)<br />若 <code>G</code> 中无长度为奇数的回路，则无向图 <code>G</code> 是二部图<br /><a href="https://www.zhihu.com/question/474576285">证明</a></p></blockquote><ul><li>也就是说各自的子集中两个顶点之间都没有边</li></ul><h3 id="匹配"><a class="markdownIt-Anchor" href="#匹配"></a> 匹配</h3><blockquote><p><strong>匹配（Matching）</strong><br />在无向图 <code>G = (V, E)</code> 中，若边集 <code>M ⊆ E</code> 满足：<br />任意两条边不共享公共顶点(即<strong>不相连</strong>)，则称 <code>M</code> 为图 <code>G</code> 的一个匹配。</p></blockquote><blockquote><p><strong>极大匹配（Maximal Matching）</strong><br />若匹配 <code>M</code> 满足：<br />在图中不能再加入任何一条边而仍保持是匹配，则称 <code>M</code> 为极大匹配。</p></blockquote><blockquote><p><strong>最大匹配（Maximum Matching）</strong><br />在图 <code>G</code> 的所有匹配中，边数最多的匹配称为最大匹配。</p></blockquote><ul><li><strong>匹配数</strong><br />最大匹配 <code>M</code> 中边的条数称为匹配数</li></ul><hr /><blockquote><p><strong>完美匹配（Perfect Matching）</strong><br />若匹配 <code>M</code> 覆盖图中所有顶点，即每个顶点都恰好与一条匹配边相关联，<br />则称 <code>M</code> 为完美匹配。</p></blockquote><blockquote><p><strong>完备匹配（Complete Matching）</strong><br />在二部图 <code>G = (X, Y, E)</code> 中，若存在一个匹配使得 <code>X</code> 中的每个顶点<br />都与 <code>Y</code> 中某个顶点匹配，则称该匹配为完备匹配。(<em>当|X|&lt;|Y|时允许存在有顶点不匹配的情况</em>)</p></blockquote><hr /><h3 id="hall-定理及其引申"><a class="markdownIt-Anchor" href="#hall-定理及其引申"></a> Hall 定理及其引申</h3><blockquote><p><strong>Hall 定理（婚姻定理）</strong><br />设 <code>G = (X, Y, E)</code> 为二部图。<br />存在一个覆盖 <code>X</code> 的完备匹配，当且仅当对 <code>X</code> 的任意子集 <code>S</code>，<br /><code>S</code> 的邻接顶点集合 <code>N(S)</code> 满足：</p></blockquote><ul><li><code>|N(S)| ≥ |S|</code></li></ul><hr /><blockquote><p><strong>Hall 定理的等价表述</strong><br />二部图 <code>G = (X, Y, E)</code> 中存在完备匹配<br />当且仅当 <code>X</code> 的任意子集都不“缺少”可匹配的邻接顶点。</p></blockquote><ul><li>用人话说,当|X|&lt;=|Y|时需要保证X中任意k个顶点至少邻接Y中k个顶点</li></ul><blockquote><p><strong>Hall 定理的推论</strong><br />设 <code>G = (X, Y, E)</code> 为二部图，若存在t&gt;0,使得:</p><ul><li>X中每个顶点至少关联t条边</li><li>Y中每个顶点至多关联t条边<br />则称G中存在X到Y的完备匹配</li></ul></blockquote><ul><li>显然这是一个很强烈的充分条件而非必要条件</li></ul><h2 id="欧拉图"><a class="markdownIt-Anchor" href="#欧拉图"></a> 欧拉图</h2><blockquote><p><strong>欧拉回路</strong>:通过图中所有边且每边仅通过一次的回路，具有欧拉回路的图称为欧拉图（Euler Graph）</p></blockquote><ul><li>将回路改为通路就得到了欧拉通路的定义</li></ul><blockquote><p>无向图中：</p><ul><li>有欧拉回路：当且仅当 <code>G</code> 是连通图且无奇度顶点</li><li>有欧拉通路但没有欧拉回路：当且仅当 <code>G</code> 是连通图且恰好有两个奇度顶点</li></ul></blockquote><ul><li>当然有欧拉回路就有欧拉通路,少连一条边就是了</li></ul><blockquote><p>有向图中：</p><ul><li>有欧拉回路：当且仅当 <code>G</code> 是连通图且每个顶点的入度等于出度<br />直观上很好理解，证明还是算了吧</li></ul></blockquote><hr /><h2 id="哈密顿图"><a class="markdownIt-Anchor" href="#哈密顿图"></a> 哈密顿图</h2><blockquote><p>通过图 <code>G</code> 的每个结点一次且仅一次的通路（回路），就是<strong>哈密顿通路</strong>（回路），存在哈密顿回路的图就是哈密顿图</p></blockquote><h3 id="判定方法"><a class="markdownIt-Anchor" href="#判定方法"></a> 判定方法</h3><blockquote><p>若n阶有向图G对应的无向图中含有生成子图Kn(即生成子图为完全图),则G中存在哈密顿通路</p></blockquote><ul><li>这个挺显然的,如果每个顶点间都有连线,怎么都能把所有顶点连接起来</li></ul><hr /><h2 id="平面图"><a class="markdownIt-Anchor" href="#平面图"></a> 平面图</h2><blockquote><p>若 <code>G</code> 能画在平面上而不出现边交叉，则为<strong>平面图</strong>，画出的图称为 <code>G</code> 的平面嵌入</p></blockquote><blockquote><p><strong>面</strong>:设G是一个平面嵌入,G<br />的边将整个平面划分成若干区域,每个区域称为G的一个面,其中面积无限的区域称为<em>无限面</em>或<em>外部面</em>,面积有限的区域称为<em>有限面</em>或<em>内部面</em></p></blockquote><ul><li><em>nnd图论这一堆中文别名就不能统一一下,自己研究起来不麻烦吗</em></li></ul><blockquote><p>包围面R的所有边构成的回路称为R的边界,边界的长度称为R的次数,记为deg®</p></blockquote><ul><li>注意若外部面包含割边,需要沿着割边的两侧绕行形成回路,故会计算两次</li><li>在简单平面图中，每个面的次数 ≥ 3 （因为不存在长度为 1 或 2 的回路）。</li><li>各面次数之和等于边数的 2 倍：</li><li><strong>平面图各面的次数之和等于边数的2倍</strong></li></ul><blockquote><p>证明<br />在平面图中，每一条边都有两侧：</p><ul><li>要么分别邻接两个不同的面；</li><li>要么作为桥或割边，在同一个面边界上出现两次</li></ul><p>无论哪种情况，<br /><strong>每一条边都会被恰好计入两个面的次数中</strong>。</p></blockquote><h3 id="极大平面图"><a class="markdownIt-Anchor" href="#极大平面图"></a> 极大平面图</h3><blockquote><p>若G是简单平面图, 且在任意两个不相邻的顶点<br />之间加一条新边所得图为非平面图, 则称G为极大平面图</p></blockquote><ul><li>极大平面图是连通的 (若不连通则可以继续加边,矛盾)</li><li>设G为n(n3)阶简单图, G为极大平面图的充分必要条件是, G每个面的次数均为3.</li></ul><h3 id="欧拉公式"><a class="markdownIt-Anchor" href="#欧拉公式"></a> 欧拉公式</h3><blockquote><p>对于连通平面图有欧拉公式：<code>n + r - 2 = m</code>，其中 <code>n</code> 为顶点数，<code>m</code> 为边数，<code>r</code> 为面数（显然边数总是最多的一方）</p></blockquote><ul><li>记住有个两个数相加减2等于另一个数,然后立方体中边数为12,顶点数为8,面数为6,就能记住欧拉公式</li></ul><hr /><h1 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h1><p><strong>定义</strong></p><blockquote><p>不含回路的连通无向图称为树，平凡图(即一个点)称为平凡树,度数为 <code>1</code> 的顶点称为树叶，度数大于 <code>1</code> 的称为分支点</p></blockquote><ul><li><strong>注意!!!</strong><br /><strong>关于二叉树本教材默认第一层高度为0,第二层高度为1,以此类推!!!</strong></li></ul><h2 id="生成树"><a class="markdownIt-Anchor" href="#生成树"></a> 生成树</h2><p>生成树</p><blockquote><p><code>G</code> 是无向连通图，<code>T</code> 是 <code>G</code> 的生成子图且是树，则 <code>T</code> 为 <code>G</code> 的生成树（即连接了所有节点），<code>G</code> 在 <code>T</code> 中的边称为 <code>T</code> 的树枝，不在 <code>T</code> 中的边称为 <code>T</code> 的弦，<code>T</code> 中所有弦生成的导出子图称为 <code>T</code> 的余树(不一定是树,也未必连通)</p></blockquote><h3 id="定理任何无向连通图g都有生成树"><a class="markdownIt-Anchor" href="#定理任何无向连通图g都有生成树"></a> 定理:任何无向连通图G都有生成树</h3><blockquote><p>证明:若G无回路,则本身就是生成树,若含有回路,则删去回路上任意一条边,直到图中不再有回路,这不影响G的连通性,从而得到生成树</p></blockquote><h3 id="推论n阶无向连通图g的边数大于等于n-1"><a class="markdownIt-Anchor" href="#推论n阶无向连通图g的边数大于等于n-1"></a> 推论:n阶无向连通图G的边数大于等于n-1</h3><blockquote><p>证明:其生成树的边数为n-1</p></blockquote><h3 id="基本回路和基本割集"><a class="markdownIt-Anchor" href="#基本回路和基本割集"></a> 基本回路和基本割集</h3><blockquote><p><strong>基本回路（Fundamental Circuit）</strong><br />设 <code>T</code> 是连通图 <code>G</code> 的一棵生成树。<br />对任意一条不属于 <code>T</code> 的边 <code>e</code>(弦)，将 <code>e</code> 加入 <code>T</code> 中，<br />则在 <code>T ∪ &#123;e&#125;</code> 中产生且<strong>唯一</strong>的回路，称为关于生成树 <code>T</code> 的一个基本回路。</p></blockquote><hr /><blockquote><p><strong>基本回路系统</strong><br />由生成树 <code>T</code> 中<strong>所有弦</strong>各自对应的基本回路所组成的集合，<br />称为图 <code>G</code> 的一个基本回路系统。</p></blockquote><hr /><blockquote><p><strong>基本割集（Fundamental Cutset）</strong><br />设 <code>T</code> 是连通图 <code>G</code> 的一棵生成树。<br />对任意一条属于 <code>T</code> 的边 <code>e</code>，从 <code>T</code> 中删去 <code>e</code>，<br />生成树被分成两个连通分量。<br />在原图 <code>G</code> 中，所有连接这两个分量的边构成的集合，<br />称为关于生成树 <code>T</code> 和边 <code>e</code> 的基本割集。</p></blockquote><hr /><blockquote><p><strong>基本割集系统</strong><br />由生成树 <code>T</code> 中<strong>每一条树边</strong>所对应的基本割集组成的集合，<br />称为图 <code>G</code> 的一个基本割集系统。</p></blockquote><hr /><ul><li><strong>加一条非树边 → 一个基本回路</strong></li><li><strong>删一条树边 → 一个基本割集</strong></li><li>基本回路数 = 非树边数  (m-n+1)</li><li>基本割集数 = 树边数    (n-1)</li></ul><hr /><p><strong>真整理完了发现确实是文科,基本上所有例题只要懂了概念就能做,唯一难的地方就是证明题,很多证明想破脑袋都想不到,只好继续背书了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图的基本概念&quot;&gt;&lt;/a&gt; 图的基本概念&lt;/h1&gt;
&lt;h2 id=&quot;有向图&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#有向图&quot;&gt;&lt;/a&gt; 有向图&lt;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-01 浏览器实用插件</title>
    <link href="https://revival-of-hope.github.io/2026/01/01/dynamic-2026-01-01-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>https://revival-of-hope.github.io/2026/01/01/dynamic-2026-01-01-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</id>
    <published>2026-01-01T00:00:00.000Z</published>
    <updated>2026-01-01T09:25:11.705Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://microsoftedge.microsoft.com/addons/detail/gitzip-for-github/iemilfmlaliblejogfofhmjbfiaiegnd">GitZip for github</a></h1><h1><a href="https://www.octotree.io/">Octotree</a></h1><h1><a href="https://github.com/xuejianxianzun/PixivBatchDownloader">Pixiv Downloader</a></h1><h1><a href="https://github.com/lnw143/competitive-companion-customized">Competitive Companion customed</a></h1><h1><a href="https://microsoftedge.microsoft.com/addons/detail/lingvanex-%E7%BF%BB%E8%AF%91%E5%92%8C%E8%AF%8D%E5%85%B8%E3%80%82%E5%97%93%E9%9F%B3/pppgidljpojmcjehgdnfmmffbhifdloh">Lingvanex</a></h1><h1><a href="https://chromewebstore.google.com/detail/unpaywall/iplffkdpngmdjhlpjmppncnlhomiipha">unpaywall</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://microsoftedge.microsoft.com/addons/detail/gitzip-for-github/iemilfmlaliblejogfofhmjbfiaiegnd&quot;&gt;GitZip for github&lt;/a&gt;&lt;/h1</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-01 离散数学整理-群论</title>
    <link href="https://revival-of-hope.github.io/2026/01/01/archives-2025-2026-01-01-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E7%BE%A4%E8%AE%BA/"/>
    <id>https://revival-of-hope.github.io/2026/01/01/archives-2025-2026-01-01-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E7%BE%A4%E8%AE%BA/</id>
    <published>2026-01-01T00:00:00.000Z</published>
    <updated>2026-01-12T01:21:11.294Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113979489780353&bvid=BV1H2NoeiE1K&cid=28736228422&p=1"        width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe><p>由于学校规定的那本臭不可闻的ts离散教材已经沉浸在自己的优越感里了,找不到一点点系统性,只好我自己从头开始梳理,大多数定义都是直接引用的wiki</p><h2 id="运算律"><a class="markdownIt-Anchor" href="#运算律"></a> 运算律</h2><h3 id="结合律"><a class="markdownIt-Anchor" href="#结合律"></a> 结合律</h3><ul><li><code>a+(b+c)=(a+b)+c</code><br />结合律是群论中最为重要的部分,只有满足结合律的代数系统才可以进行两项以上的计算,例如计算a+b+c.如果(a+b)+c!=q+(b+c),那就无法得出唯一的结果了</li></ul><h3 id="交换律"><a class="markdownIt-Anchor" href="#交换律"></a> 交换律</h3><ul><li><code>a+b=b+a</code><br />很多代数系统不满足交换律,例如矩阵乘法</li></ul><h3 id="分配律"><a class="markdownIt-Anchor" href="#分配律"></a> 分配律</h3><p>如果<em>对+满足以下式子,则称</em>对+满足分配律</p><ul><li><code>a*(b+c)=a*b+a*c</code></li></ul><h3 id="幂等律"><a class="markdownIt-Anchor" href="#幂等律"></a> 幂等律</h3><ul><li><code>a+a=a</code><br />在幂等律成立的代数系统中，对同一元素重复运算不会产生新的结果，常见于集合的并运算与交运算中。</li></ul><h3 id="吸收律"><a class="markdownIt-Anchor" href="#吸收律"></a> 吸收律</h3><p>需要同时满足下面两个式子</p><ul><li><code>a+(a*b)=a</code></li><li><code>a*(a+b)=a</code></li></ul><h3 id="消去律"><a class="markdownIt-Anchor" href="#消去律"></a> 消去律</h3><p><img src="/images/archives/2026-01-01/PixPin_2026-01-01_15-47-28.webp" alt="例题" /><br />逆元和结合律保证了消去律的存在</p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><img src="/images/archives/2026-01-01/PixPin_2026-01-01_10-35-05.webp" alt="" /></p><h2 id="代数系统"><a class="markdownIt-Anchor" href="#代数系统"></a> 代数系统</h2><h3 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h3><p>半群满足加法,群还满足减法,环还满足乘法,域还满足除法<br /><img src="/images/archives/2026-01-01/PixPin_2026-01-02_23-06-11.webp" alt="" /></p><h3 id="子代数"><a class="markdownIt-Anchor" href="#子代数"></a> 子代数</h3><p>子代数与原代数系统含有相同的代数常数,且对于所有运算都是封闭的</p><h3 id="封闭性"><a class="markdownIt-Anchor" href="#封闭性"></a> 封闭性</h3><p><img src="/images/archives/2026-01-01/PixPin_2026-01-02_23-12-44.webp" alt="" /></p><blockquote><p>封闭性其实是非常重要的性质,保证了集合内的运算结果保留在集合内,而不会出现任何特殊情况,而由于作为整个群论基础的半群具有封闭性,故下文讨论到的所有代数系统都具有封闭性.</p></blockquote><h3 id="同态和同构"><a class="markdownIt-Anchor" href="#同态和同构"></a> 同态和同构</h3><p><img src="/images/archives/2026-01-01/PixPin_2026-01-02_22-38-55.webp" alt="" /></p><p>如果同态满足单射,称为单同态,满足满射,称为满同态,满足双射,则称为同构</p><h4 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h4><p><img src="/images/archives/2026-01-01/PixPin_2026-01-01_14-30-58.webp" alt="" /><br />通过这个例题可以明确几点关于映射的知识</p><ul><li>没参与映射的元素不会计入原像集合,例如这里的0在原像集合中,故一定有像存在</li><li>双射时像和原像一定是一一对应的</li></ul><h3 id="半群"><a class="markdownIt-Anchor" href="#半群"></a> 半群</h3><p>满足结合律的封闭代数系统称为半群</p><p>例子: 自然数下的加法</p><p>含有幺元的半群称为独异点(垃圾翻译)</p><h3 id="群"><a class="markdownIt-Anchor" href="#群"></a> 群</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p>存在一个数e,使得对于集合S内所有的元素a都满足以下公式,则称e为集合S的幺元</p><ul><li><code>e+a=a,a+e=a</code></li></ul><p>若一个半群S存在幺元e,且对于集合S内所有的元素a都有逆元b满足以下公式,则称S为群</p><ul><li><code>b+a=a+b=e</code></li></ul><ol><li>由于零元不存在逆元,故群都不含零元</li><li>除单位元素e外群不存在等幂元素</li></ol><h4 id="群的阶数"><a class="markdownIt-Anchor" href="#群的阶数"></a> 群的阶数</h4><p>群G中元素的个数称为阶数,记作|G|,若个数有限,称为有限群,否则为无限群,若G只有一个单位元素e,则称为平凡群</p><h4 id="交换群阿贝尔群"><a class="markdownIt-Anchor" href="#交换群阿贝尔群"></a> 交换群(阿贝尔群)</h4><blockquote><p>满足交换律的群称为交换群</p></blockquote><h4 id="klein四元群"><a class="markdownIt-Anchor" href="#klein四元群"></a> Klein四元群</h4><p><img src="/images/archives/2026-01-01/PixPin_2026-01-01_15-36-07.webp" alt="" /></p><blockquote><p>Klein四元群G的运算具有以下特点:</p></blockquote><ol><li>e为G中的幺元</li><li>.是可交换的</li><li>任何G中元素与自己运算的结果都为e</li><li>除幺元外任意两个元素的运算结果都等于另一个元素</li></ol><blockquote><p>可以看出Klein四元群既是交换群又是有限群</p></blockquote><h4 id="子群"><a class="markdownIt-Anchor" href="#子群"></a> 子群</h4><p>显然只要是群S的子集,并满足群的性质就可以称为子群,重点在于证明一个子集是一个群的子群<br /><img src="/images/archives/2026-01-01/PixPin_2026-01-02_23-22-23.webp" alt="" /></p><blockquote><p>关键在于一点点补全群的定义,首先找到幺元,接着找到逆元存在,由于集合被划分,故原来的封闭性可能被破坏,还需要证明封闭性,而结合律不用证明,因为所有半群的子集都是满足结合律的</p></blockquote><h4 id="循环群"><a class="markdownIt-Anchor" href="#循环群"></a> 循环群</h4><p><img src="/images/archives/2026-01-01/PixPin_2026-01-02_22-54-02.webp" alt="定义" /></p><ul><li>这里的幂次不一定是乘方,只是表示对g进行多次运算</li><li>生成元g与群G的阶数是一样的,无限循环群的生成元是a和a^-1,而n阶循环群的生成元是与a所有与n互质的幂次(互质:最大公约数为1,因此1也包含在互质的幂次里)</li><li>从定义可以知道循环群一定是交换群</li><li><blockquote><p>由于要满足封闭性,故n阶循环群子群的生成元的幂次一定都是n的因数,可以把g的n次方计为幺元e,这个刚看到时很难理解,但如果没有幺元,那么就可以一直运算下去,就不是有限群了,故一定存在一个边界保证阶数不超过n,那么把g的n次方看作e就非常合适了.</p></blockquote></li></ul><h4 id="置换群"><a class="markdownIt-Anchor" href="#置换群"></a> 置换群</h4><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">置换通常写作轮换形式。例如，在轮换表示法中，给定集合  </span><br><span class="line">M = &#123;1, 2, 3, 4&#125;。</span><br><span class="line"></span><br><span class="line">设 M 的一个置换 g 满足：</span><br><span class="line"><span class="bullet">-</span> g(1) = 2  </span><br><span class="line"><span class="bullet">-</span> g(2) = 4  </span><br><span class="line"><span class="bullet">-</span> g(4) = 1  </span><br><span class="line"><span class="bullet">-</span> g(3) = 3  </span><br><span class="line"></span><br><span class="line">则该置换可以写作：</span><br><span class="line">(1, 2, 4)(3)</span><br><span class="line"></span><br><span class="line">或者更常见地写作：</span><br><span class="line">(1, 2, 4)</span><br><span class="line"></span><br><span class="line">因为元素 3 在该置换下保持不变。</span><br><span class="line"></span><br><span class="line">当对象用单个字母或数字表示时，逗号通常也可以省略，因此也可记作：</span><br><span class="line">(1 2 4)</span><br></pre></td></tr></table></figure><ul><li>涉及集合S中m个不同数的置换称为m阶轮换</li></ul><h3 id="环和域"><a class="markdownIt-Anchor" href="#环和域"></a> 环和域</h3><p>显然wiki上定义的环是真环,乘法有幺元;教材里用的定义是伪环,乘法不含幺元</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个环是一个集合 R，具有两个二元运算（+ 和 ·），分别称为“加法”和“乘法”。</span><br><span class="line"></span><br><span class="line">其中，乘法对加法满足分配律,并且满足以下代数结构条件：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> (R, +) 是一个阿贝尔群  </span><br><span class="line"><span class="bullet">-</span> (R, ·) 是一个半群</span><br></pre></td></tr></table></figure><p><strong>零因子</strong>:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对所有 (a, b) ∈ R × R， 若当a,b都不为0时存在a × b = 0</span><br><span class="line">则a称为左零因子,b称为右零因子</span><br></pre></td></tr></table></figure><p><strong>证明零因子可以用消去律代替</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">假设 R 中没有零因子。</span><br><span class="line"></span><br><span class="line">已知：</span><br><span class="line">a ≠ 0 </span><br><span class="line">a x b = a x c</span><br><span class="line"></span><br><span class="line">两边相减，得到：</span><br><span class="line">a x (b − c) = 0</span><br><span class="line"></span><br><span class="line">由于 a ≠ 0，</span><br><span class="line">又因为没有零因子，</span><br><span class="line"></span><br><span class="line">只能推出：</span><br><span class="line">b − c = 0</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">b = c</span><br></pre></td></tr></table></figure><ul><li>只有所有非零数相乘都不为0才可以说环不存在零因子,称为无零因子环</li><li>若环R中乘法满足交换律,含有幺元,无零因子,则R称为整环</li><li>若环R至少含有两个元素且含有幺元,无零因子,所有非零元素都存在乘法逆元,则称R为除环</li></ul><blockquote><ul><li>简短说来,环中多了一个对有无零因子的考察,因为如果不满足消去律的话研究这个代数系统就很困难了,而整环中乘法是一个可交换独异点,除环除开零以外是一个群</li></ul></blockquote><blockquote><ul><li>若环R既是整环又是除环,则称R是域</li></ul></blockquote><h3 id="格与布尔代数"><a class="markdownIt-Anchor" href="#格与布尔代数"></a> 格与布尔代数</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">考虑一个偏序集合 (L, ≤)。  </span><br><span class="line">如果对集合 L 中的任意两个元素 a、b，  </span><br><span class="line">它们在 L 中都存在最大下界和最小上界，  </span><br><span class="line">则称 (L, ≤) 是一个格。</span><br><span class="line">(由于偏序符号不好打,这里的小于等于都是偏序符号,表示可比,可比要求两个元素在哈斯图里处于同一分支上)</span><br><span class="line">从这个定义可以看出：</span><br><span class="line">格并不要求像全序集合那样，任意两个元素都必须可比；</span><br><span class="line">但仍要求任意两个元素都具有最大下界和最小上界。</span><br></pre></td></tr></table></figure><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在这里，取 a、b 的最大下界的运算记作  </span><br><span class="line">a ∧ b；</span><br><span class="line"></span><br><span class="line">取 a、b 的最小上界的运算记作  </span><br><span class="line">a ∨ b。</span><br></pre></td></tr></table></figure><hr /><blockquote><ul><li>格和全序集的区别:<br />简单画哈斯图便可以知道,全序集是一条线,而格可以有多个分支,只要分支最后能汇合到一点就可以</li></ul></blockquote><blockquote><ul><li>格满足交换律,结合律,幂等律和吸收律,这些从定义来看就很好理解,故无需证明</li></ul></blockquote><h4 id="补充概念"><a class="markdownIt-Anchor" href="#补充概念"></a> 补充概念</h4><p><strong>最大元和最小元</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">设 (P, ≤) 为一个偏序集 ，S 为其子集。</span><br><span class="line"></span><br><span class="line">若 S 中的元素 g 满足：  </span><br><span class="line">对 S 的任意元素 s，都有 s ≤ g，  </span><br><span class="line">则称 g 为 S 的最大元（greatest element）。</span><br><span class="line"></span><br><span class="line">对偶地，若 S 中的元素 l 满足：  </span><br><span class="line">对 S 的任意元素 s，都有 l ≤ s，  </span><br><span class="line">则称 l 为 S 的最小元（least element）。</span><br><span class="line"></span><br><span class="line">由定义可知，S 的最大元（最小元）必定是 S 的上界（下界）。</span><br><span class="line"></span><br><span class="line">并且集合 S 至多只能有一个最大元：  </span><br><span class="line">若 g₁ 和 g₂ 都是 S 的最大元，则由定义有  </span><br><span class="line">g₁ ≤ g₂，且 g₂ ≤ g₁，  </span><br><span class="line">由反对称性可得 g₁ = g₂。</span><br><span class="line"></span><br><span class="line">因此，若 S 存在最大元,则该最大元必定是唯一的,最小元同理</span><br></pre></td></tr></table></figure><p><strong>最小上界和最大上界</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设 (A, ≤) 为一个偏序集，B ⊆ A。</span><br><span class="line"></span><br><span class="line">若存在 y ∈ A，使得对任意 x ∈ B 都有  </span><br><span class="line">x ≤ y，  </span><br><span class="line">则称 y 为集合 B 的上界。</span><br><span class="line"></span><br><span class="line">对称地，若存在 z ∈ A，使得对任意 x ∈ B 都有  </span><br><span class="line">z ≤ x，  </span><br><span class="line">则称 z 为集合 B 的下界。</span><br><span class="line"></span><br><span class="line">偏序集A的子集B在A中的上界集合的最小元称为最小上界,对偶概念即为最大下界</span><br></pre></td></tr></table></figure><h4 id="特殊的格"><a class="markdownIt-Anchor" href="#特殊的格"></a> 特殊的格</h4><p><strong>分配格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个格。  </span><br><span class="line">若对任意 a、b、c ∈ L，都有：</span><br><span class="line"></span><br><span class="line">a ∧ (b ∨ c) = (a ∧ b) ∨ (a ∧ c)  </span><br><span class="line">a ∨ (b ∧ c) = (a ∨ b) ∧ (a ∨ c)</span><br><span class="line"></span><br><span class="line">则称 L 为一个分配格。</span><br></pre></td></tr></table></figure><hr /><p><strong>有界格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个格。  </span><br><span class="line">若 L 有最小元0和最大元1,即对任意 a ∈ L 都满足  </span><br><span class="line">a ∨ 0 = a 和 a ∧ 1 = a，  </span><br><span class="line">则称 L 为一个有界格,这里的最小元称为全下界,最大元称为全上界</span><br></pre></td></tr></table></figure><ul><li>可以认为所有元素有限的格都是有界格,因为格的定义就要求了哈斯图的两端是封闭的,故一定有上下界</li></ul><hr /><p><strong>有补格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个有界格  </span><br><span class="line">并且 L 中的每个元素 a 都存在一个b ∈ L 使得  </span><br><span class="line">a ∨ b = 1 且 a ∧ b = 0。  </span><br><span class="line">这样的 b 称为 a 的补元。</span><br><span class="line">L则称为有补格</span><br></pre></td></tr></table></figure><p><em>证明分配格中任意元素的补元唯一</em></p><blockquote><p>设 L 是一个分配格，有界格，且 a ∈ L 有两个补元 b 和 c。<br />根据补元的定义：</p><ol><li>a ∨ b = 1 且 a ∧ b = 0</li><li>a ∨ c = 1 且 a ∧ c = 0</li></ol><p>要证明 b = c。</p><p>步骤 1：利用分配律</p><p>考虑 b ∧ (a ∨ c)：</p><p>b ∧ (a ∨ c) = (b ∧ a) ∨ (b ∧ c)  （分配律）</p><p>代入已知 a ∧ b = 0：</p><p>0 ∨ (b ∧ c) = b ∧ c</p><p>而 a ∨ c = 1，所以：</p><p>b ∧ 1 = b</p><p>所以 b = b ∧ c。</p><p>步骤 2：对称地</p><p>同理，c = a ∨ b ∧ c，经过类似推导可得：</p><p>c = b ∧ c</p><p>步骤 3：结合得到</p><p>b = b ∧ c = c</p><p>因此，补元是唯一的。</p></blockquote><p><strong>布尔格(布尔代数)</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">布尔格是一个有补分配格,换句话说，它是一个有最小元 0 和最大元 1 的格,</span><br><span class="line">满足分配律，并且每个元素都有补元</span><br></pre></td></tr></table></figure><ul><li>由上述证明可以明确布尔代数每个元素的补元唯一,求补元可以看成是一元运算</li></ul><hr /><p><strong>仔细一看就算都理解透了,还是有一堆要背的,因为不可能到考试的时候现推啊,能把数学课教成文科也是挺nb的.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=113979489780353&amp;bvid=BV1H2NoeiE1K&amp;cid=28736228422&amp;p=1&quot;        width=&quot;100%&quot;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2025 年终总结</title>
    <link href="https://revival-of-hope.github.io/2025/12/31/archives-2025-2025-12-31-%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <id>https://revival-of-hope.github.io/2025/12/31/archives-2025-2025-12-31-%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%A7%E4%BD%9C%E4%B8%9A/</id>
    <published>2025-12-31T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周都在忙cocos大作业,差点在30号晚上熬通宵.今天下午答辩,答辩前五分钟才把ppt写完,而项目到演示时都没能完整运行,还好老师们都不怎么在意真正的成品,反而是一直拷打代码中继承和多态的应用,侥幸过关,如果真的要当场演示,那估计就有大问题了.</p><p>究其原因,是小组合作的环节出了问题,我们组有一个本来能自己单干的大佬,而剩下的两人包括我则是不一般的菜鸡,大多数代码都是由AI完成的,很多报错也只有问AI才能解决,因为我之前根本就没接触过CPP的工程构建,多文件的集成也都是靠AI解决的.</p><p>尽管大佬给了很详细的接口文档,但由于文档全是英文,于是我们就直接贴给AI让它翻译,又没好意思让他一个人帮我们看代码,那样他就把活儿都干了.于是就悲剧了.尽管UI层的隔离测试可以跑通,Gameplay和Engine部分单独跑也可以,但由于我们这边的实现不够完全,接口没能全部写完整,于是在答辩前三天的合并时就出问题了,而且在大佬很早就提出要对齐接口的时候我们不够重视,导致接口一直有偏差,等发现是由于接口没对齐导致报错的时候离答辩只有不到一天了.而大佬以为我们都实现好了,只是路径包含或者平台差异导致报错,之前就没有来帮我们改代码,而这个时候再改就已经来不及了.</p><p><strong>复盘</strong><br>小组项目成功的必要条件:</p><ul><li>组员之间关系平等,不存在不好意思说话的情况,只有好好的沟通交流才能保证项目协作正常</li><li>组员之间能力不能相差太大,如果能力都有限反而更好团队协作,光是抱大腿未免有些太要不得了</li><li>组员需要掌握基本的Debug能力,光是靠AI或者求爷爷告奶奶是不行的,而是要能够自己独立解决基本的技术问题</li><li>每次更新都需要及时通过文档告知其他组员,详细写明更改的地方,以及对合作者的接口要求,最好是中文(😀)</li><li>在开始项目之前就要搭出一个最基本的框架,即使再抽象也可以,把所有必须要实现的功能要求先列出来,才可以保证后续运行的时候不跑偏</li><li>分工不合理很有可能导致组员间暗藏怨气,需要找到一个合理的分工方式和架构保证工作量分配均匀</li><li>使用git进行版本控制,每次commit时不要偷懒,多打几个字把本次commit好好说清楚,才不会在日后受罪</li><li>需要尽早进行合并,才能确认基本功能有没有正常实现,否则后期的合并会极其痛苦</li><li>永远不要孤军奋战,给代码一通乱改,而是虚心请教他人,如果拉不下脸,想想项目失败的后果</li></ul><p>想来这也是对我这一个学期课业的一个糟糕的总结吧,学的不够精,学的不够多,到最后啥都没剩下,还有三个小时就跨年了,祝新的一年我能更成熟一点,更好学一点,更活泼一点,更努力一点,不用太多,一点点就够了,能让我自己感觉到就够了.</p><p><strong>目标</strong></p><ul><li>[ ] cpp工程学习</li><li>[ ] 后端学习(数据库+Java)</li><li>[ ] 网络安全学习</li><li>[ ] 编写一个开源项目</li><li>[ ] 参加十场以上的比赛</li><li>[ ] 明确就业还是读研</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一周都在忙cocos大作业,差点在30号晚上熬通宵.今天下午答辩,答辩前五分钟才把ppt写完,而项目到演示时都没能完整运行,还好老师们都不怎么在意真正的成品,反而是一直拷打代码中继承和多态的应用,侥幸过关,如果真的要当场演示,那估计就有大问题了.&lt;/p&gt;
&lt;p&gt;究其原因</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-27 各种grammar集合</title>
    <link href="https://revival-of-hope.github.io/2025/12/27/dynamic-2025-12-27-grammar/"/>
    <id>https://revival-of-hope.github.io/2025/12/27/dynamic-2025-12-27-grammar/</id>
    <published>2025-12-27T00:00:00.000Z</published>
    <updated>2026-01-21T03:11:33.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cpp语法"><a class="markdownIt-Anchor" href="#cpp语法"></a> cpp语法</h2><h3 id="面向对象中的和"><a class="markdownIt-Anchor" href="#面向对象中的和"></a> 面向对象中的:和::</h3><p><strong>:</strong><br />类继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数初始化列表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> v) : <span class="built_in">x</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>::</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>类外定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板作用域限定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt;::iterator</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt;::iterator</span><br></pre></td></tr></table></figure><h3 id="c-里的别名alias"><a class="markdownIt-Anchor" href="#c-里的别名alias"></a> C++ 里的别名（Alias）</h3><h4 id="1️⃣-typedef-传统类型别名c-兼容"><a class="markdownIt-Anchor" href="#1️⃣-typedef-传统类型别名c-兼容"></a> 1️⃣ <code>typedef</code> —— 传统类型别名（C 兼容）</h4><ul><li><strong>层级</strong>：类型系统</li><li><strong>性质</strong>：真正的类型别名</li><li><strong>限制</strong>：不可模板化，可读性一般</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> ulong;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* IntPtr;</span><br></pre></td></tr></table></figure><p>⚠️ 经典陷阱：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* P;</span><br><span class="line">P a, b;   <span class="comment">// int* a; int* b;</span></span><br></pre></td></tr></table></figure><hr /><h4 id="2️⃣-define-宏替换不是语言级别名"><a class="markdownIt-Anchor" href="#2️⃣-define-宏替换不是语言级别名"></a> 2️⃣ <code>#define</code> —— 宏替换（不是语言级别名）</h4><ul><li><strong>层级</strong>：预处理（文本替换）</li><li><strong>性质</strong>：纯文本，无类型、无作用域</li><li><strong>风险</strong>：易产生歧义与隐式错误</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> U32 unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR int*</span></span><br></pre></td></tr></table></figure><p>❌ 危险示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> P int*</span></span><br><span class="line">P a, b;   <span class="comment">// int* a; int b;</span></span><br></pre></td></tr></table></figure><p>结论：<strong>不属于 C++ 类型系统，不推荐用于类型别名</strong></p><hr /><h4 id="3️⃣-using-现代-c-别名推荐"><a class="markdownIt-Anchor" href="#3️⃣-using-现代-c-别名推荐"></a> 3️⃣ <code>using</code> —— 现代 C++ 别名（推荐）</h4><ul><li><p><strong>层级</strong>：类型系统</p></li><li><p><strong>性质</strong>：类型别名的一等公民</p></li><li><p><strong>优势</strong>：</p><ul><li>可模板化</li><li>可读性强</li><li>与复杂类型天然兼容</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> U32 = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> IntPtr = <span class="type">int</span>*;</span><br></pre></td></tr></table></figure><p>模板别名（C++11）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T&gt;;</span><br></pre></td></tr></table></figure><p>成员别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="搜索引擎命令"><a class="markdownIt-Anchor" href="#搜索引擎命令"></a> 搜索引擎命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">设关键词为计算机</span><br><span class="line"><span class="string">&quot;计算机&quot;</span>:        <span class="comment"># 必须含有计算机三个字</span></span><br><span class="line">计算机 after:2023-01-01 before:2024-01-01 <span class="comment"># 限定日期</span></span><br><span class="line">计算机 past:1y <span class="comment"># 过去一年</span></span><br><span class="line">计算机 filetype:pdf <span class="comment"># 限定文件类型</span></span><br><span class="line">计算机 site:baidu.com <span class="comment"># 限定网站  </span></span><br><span class="line">计算机 -考研 <span class="comment">#排除关键词</span></span><br><span class="line">site:.edu        （教育机构）</span><br><span class="line">site:.gov        （政府网站）</span><br><span class="line">site:.org        （组织机构）</span><br><span class="line">site:.cn         （中国网站）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="git命令"><a class="markdownIt-Anchor" href="#git命令"></a> git命令</h2><p>windows端先设置代理端口</p><figure class="highlight plaintext"><figcaption><span>http_proxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>git init //初始化git,只运行一次<br />git add . //所有文件加入本地git<br />git commit -m “first commit” //提交到本地<br />git branch -M main //设置提交分支为main,之后可以不必运行<br />git remote add origin <a href="https://github.com/revival-of-hope/Clash_of_Clans.git">https://github.com/revival-of-hope/Clash_of_Clans.git</a> //关联选定仓库并在本地设置标签为origin,只要运行一次<br />git push -u origin main //-u(upstream)设置上游分支为origin的main分支,以后默认提交到origin仓库的main分支,以后只写git push就行</p><p>之后再修改只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">#可加上origin main关键字,但由于已经设置默认上游,故可以省略</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;描述修改&quot;</span> <span class="comment">#不加引号也可以</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>即可</p><h2 id="hexo命令行"><a class="markdownIt-Anchor" href="#hexo命令行"></a> hexo命令行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hexo new post/draft/page</span><br><span class="line">hexo publish draft&quot;文章名&quot;</span><br><span class="line">hexo d           --push my blog  deploy</span><br><span class="line">hexo new  +name     --new blog</span><br><span class="line">hexo g            --apply changes  generate</span><br><span class="line">hexo s            --local static html #预览</span><br><span class="line">hexo g -d   #一次完成</span><br><span class="line"></span><br><span class="line">draft也就是草稿，在使用hexo创建文章时，可以先指定为草稿。</span><br><span class="line">hexo new draft &lt;title&gt;</span><br><span class="line">然后在完成之后，使用publish命令将draft转移到post下。</span><br><span class="line">hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure><h2 id="markdown"><a class="markdownIt-Anchor" href="#markdown"></a> markdown</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">##</span><br><span class="line">###</span><br><span class="line">####</span><br></pre></td></tr></table></figure><p>均为标题</p><p><code>[]() 插入链接和说明</code><br /><code>![]() 插入图片</code><br />`</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113979489780353&bvid=BV1H2NoeiE1K&cid=28736228422&p=1"        width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe> 插入图片`<figure class="highlight plaintext"><figcaption><span>插入代码块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`代码` 行内代码</span><br><span class="line">`*斜体*`</span><br><span class="line">`**粗体** `</span><br><span class="line">`~~删除线~~`</span><br><span class="line">`==高亮==`</span><br></pre></td></tr></table></figure><ul><li>项目</li></ul><ul><li>项目</li></ul><ul><li>项目</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三种方式均可以表示列表</span><br></pre></td></tr></table></figure><ul><li>[ ] 未完成</li><li>[x] 已完成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ol><li>项目</li><li>项目</li><li>项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&gt; 引用内容</span><br><span class="line">&gt;&gt; 嵌套引用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br><span class="line">___</span><br><span class="line">三种方式均可以表示分割线</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 列1 | 列2 | 列3 |</span><br><span class="line">| --- | --- | --- |</span><br><span class="line">| A   | B   | C   |</span><br><span class="line"></span><br><span class="line">表格</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>有趣的是<br /><code>&lt;3</code>会变成红心<br />❤️</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cpp语法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cpp语法&quot;&gt;&lt;/a&gt; cpp语法&lt;/h2&gt;
&lt;h3 id=&quot;面向对象中的和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面向对象中的和&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-26 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/26/archives-2025-2025-12-26-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/26/archives-2025-2025-12-26-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-26T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://ipotato.me/article/65">来源</a><br>说实话大三上就开始找实习其实是一个有些冒险，但相应收益会比较高的做法。风险点在于学校的课程安排趋近于收尾，一些比较难的专业课也会集中在这个学期，如何平衡好学习和工作是一个首先要考虑的因素，这一点上我的做法比较粗暴：直接翘课。一是因为成绩也够不着保研的尾巴，无需那么在意绩点，二是因为除了体育课这种比较难逃的课，其他一律统统全翘，只是为了挤出了一周 4 天的实习时长，至于课业，只能安排到工作日下班，周末以及考试临近时的请假进行学习。但即便是翘课，对于一些专业课程还是要用心，比如 OS 以及编译原理等课程，可以说是专业的重中之重，不光学习会接触，在面试以及工作中也是非常核心的内容。好在一个学期下来课虽然都翘了，但最后的结果也不坏，没有顾此失彼而整出来个挂科。</p></blockquote><ul><li>其实如果没打算读研的话就可以这么做,既然是本科毕业就工作,那绩点的意义就消失了.</li></ul><p>这几天用<a href="https://rawweb.org/">rawweb</a>不知道看了多少博客,足够大的体量保证了我搜任何一个关键词基本都能找到答案,每一个博客对我来说都是一个全新的领域,仿佛博主的生活就是我的生活,他们的迷惘和彷徨就是我的迷惘和彷徨.就比如我搜索关键词保研,一下就得到了一千多条结果,里面的很多文章对我来说都是对读研和工作这一抉择的重新认识.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ipotato.me/article/65&quot;&gt;来源&lt;/a&gt;&lt;br&gt;
说实话大三上就开始找实习其实是一个有些冒险，但相应收益会比较高的做法。风险点在于学校的课程安排趋近于收尾，一些比较难的专业课也会集中在这个学期，如</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25 cocos模块学习</title>
    <link href="https://revival-of-hope.github.io/2025/12/25/archives-2025-2025-12-25-cocos%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/25/archives-2025-2025-12-25-cocos%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-12-25T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cocos命令">cocos命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143 -DUSE_COCOS_ENGINE=OFF -DBUILD_APP=OFF -DBUILD_TESTS=ON</span><br><span class="line">cmake --build build -j10</span><br><span class="line">ctest --test-dir build --output-on-failure</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143 -DUSE_COCOS_ENGINE=ON -DBUILD_APP=ON -DBUILD_TESTS=OFF</span><br><span class="line">cmake --build build --config Debug -j12</span><br></pre></td></tr></table></figure><p><code>cocos new &lt;项目名&gt;  -l cpp</code><br>当前目录下生成<br><code>cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143</code><br>在新项目里强制改cmake方式,其中-s指定cmakelists目录,-b指定build生成文件夹名字,-g指定编译器<br><code>cmake --build build j10</code></p><p>新增加文件时,在cmake里面加入对应的文件路径<br>再运行<code>cmake .</code>就行了<br>resource目录下的文件默认会全部添加,不用改cmakelists,而cpp和头文件需要手动添加,或者换成默认全部添加的代码<br>之后在build文件夹运行cmake …后即可<br>单纯修改文件时会同步修改,不用担心</p><p><code>cmake -S . -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143</code></p><h2 id="概念部分">概念部分</h2><p>精灵:可以理解为人物和物品,是可操作的对象<br>label: 可以理解为字幕,大到开始界面标题,小到物品资源名字,都能用</p><h2 id="初始化部分">初始化部分</h2><p>写好场景的h文件和cpp文件后,在AppDelegate.cpp里使用并运行</p><h3 id="加载场景">加载场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myScene = Scene::<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//runWithScene() 用于开始游戏，加载第一个场景。只用于第一个场景！</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">runWithScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//replaceScene() 使用传入的场景替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">replaceScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pushScene() 将当前运行中的场景暂停并压入到场景栈中，再将传入的场景设置为当前运行场景。只有存在正在运行的场景时才能调用该方法。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">pushScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//popScene() 释放当前场景，再从场景栈中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">popScene</span>();</span><br></pre></td></tr></table></figure><h2 id="窗口部分">窗口部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> visibleSize = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleSize</span>();</span><br><span class="line">    <span class="comment">//窗口对角线向量,这个向量可以调用visibleSize.width</span></span><br><span class="line">    <span class="comment">//和visibleSize.height两个子属性</span></span><br><span class="line">    <span class="keyword">auto</span> origin = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleOrigin</span>();</span><br><span class="line">    <span class="comment">//左下角坐标(0,0)</span></span><br></pre></td></tr></table></figure><p>在AppDelegate.cpp下有一行<br><code>glview = GLViewImpl::createWithRect(&quot;test&quot;, cocos2d::Rect(0, 0, designResolutionSize.width, designResolutionSize.height));</code><br>修改designResolutionSize为其他大小(如largeResolutionSize)即可修改窗口默认大小</p><h2 id="创建部分">创建部分</h2><h3 id="创建元素">创建元素</h3><p><strong>所有创建的精灵和场景,动作都会自动销毁</strong><br><em>创建精灵</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> child = Sprite::<span class="built_in">create</span>(<span class="string">&quot;Images/test.png&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> mySprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;mysprite.png&quot;</span>, <span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>));</span><br><span class="line"><span class="comment">//可以指定裁剪区域,(0,0)为左上角坐标,大小为200X200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多边形精灵.</span></span><br><span class="line"><span class="keyword">auto</span> pinfo = AutoPolygon::<span class="built_in">generatePolygon</span>(<span class="string">&quot;filename.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sprite with polygon info.</span></span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::<span class="built_in">create</span>(pinfo);</span><br></pre></td></tr></table></figure><p><a href="https://docs.cocos.com/cocos2d-x/manual/zh/sprites/spritesheets.html">还可以使用图集来创建</a></p><p><em>创建label</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> label = Label::<span class="built_in">createWithTTF</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, <span class="number">16.0f</span>);</span><br><span class="line"><span class="keyword">auto</span> label = Label::<span class="built_in">create</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, <span class="number">16.0f</span>);</span><br><span class="line"><span class="comment">//两种方法均可以,下面一种在字体不能正常加载时使用系统字体,那我肯定用下面一种啊</span></span><br></pre></td></tr></table></figure><p><em>创建menu</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最复杂的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建一个image对象</span></span><br><span class="line"><span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(</span><br><span class="line">                                        <span class="string">&quot;CloseNormal.png&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">                                        <span class="built_in">CC_CALLBACK_1</span>(HelloWorld::menuCloseCallback,<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//可以用回调函数,但用lamda表达式更像人类一点,官方例子如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 lambda 表达式作为菜单项的回调函数：</span></span><br><span class="line"><span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(<span class="string">&quot;CloseNormal.png&quot;</span>, <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">[&amp;](Ref* sender)&#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是看不懂的话有以下例子</span></span><br><span class="line"><span class="keyword">auto</span> showPlayerDlgItem = MenuItemImage::<span class="built_in">create</span>(<span class="string">&quot;Images/Pea.png&quot;</span>,</span><br><span class="line">                                               <span class="string">&quot;Images/Pea.png&quot;</span>,</span><br><span class="line">                                               [<span class="keyword">this</span>](Ref* sender)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_playerDlg-&gt;<span class="built_in">setVisible</span>(!<span class="keyword">this</span>-&gt;_playerDlg-&gt;<span class="built_in">isVisible</span>());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//简单说来就是点击这个菜单图片会发生什么</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在用图像来创建菜单</span></span><br><span class="line"><span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem,closeItem2,closeItem3, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//可以一直叠下去</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指定元素位置-菜单-ui组件通用">指定元素位置(菜单,UI组件通用)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(origin.x,origin.y));</span><br><span class="line">child-&gt;<span class="built_in">setPosition</span>(<span class="built_in">vec2</span>(visibleSize/<span class="number">2</span>));</span><br><span class="line"><span class="comment">//两种方法都可以</span></span><br></pre></td></tr></table></figure><p><strong>改变精灵的中心点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DEFAULT anchor point for all Sprites</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom left</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// top left</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom right</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// top right</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="将元素加入指定图层-通用">将元素加入指定图层(通用)</h3><p><code>this-&gt;addChild(child, 1,people);</code></p><blockquote><p>原定义部分<br>void Node::addChild(Node *child, int localZOrder, int tag)</p></blockquote><p>即第一个参数是元素名称,第二个参数是指定图层坐标,第三个参数是标签,<br>后两个均为可选</p><h2 id="动作部分">动作部分</h2><h3 id="旋转">旋转</h3><p>通过 setRotation() 方法，设置一个角度值可以控制精灵的旋转，正值精灵顺时针旋转，负值精灵逆时针旋转，默认位置的角度值是 0.0。<br><code>mySprite-&gt;setRotation(20.0f);</code></p><h3 id="缩放">缩放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// increases X and Y size by 2.0 uniformly</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScale</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increases just X scale by 2.0</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScaleX</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increases just Y scale by 2.0</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScaleY</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p><strong>动作中的缩放方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scale uniformly by 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleBy = ScaleBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleBy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale X by 2 and Y by 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleBy = ScaleBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleBy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale to uniformly to 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleTo = ScaleTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale X to 2 and Y to 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleTo = ScaleTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleTo);</span><br></pre></td></tr></table></figure><h3 id="移动">移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move sprite to position 50,10 in 2 seconds.</span></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">50</span>, <span class="number">10</span>));</span><br><span class="line">mySprite1-&gt;<span class="built_in">runAction</span>(moveTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move sprite 20 points to right in 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">20</span>,<span class="number">0</span>));</span><br><span class="line">mySprite2-&gt;<span class="built_in">runAction</span>(moveBy);</span><br></pre></td></tr></table></figure><p>注意到每个动作都要先创建为对象再用runAction执行</p><p><strong>可以创建一个移动序列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">500</span>, mySprite-&gt;<span class="built_in">getPositionY</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// MoveTo - lets move the new sprite to 300 x 256 over 2 seconds</span></span><br><span class="line"><span class="comment">// MoveTo is absolute - The sprite gets moved to 300 x 256 regardless of</span></span><br><span class="line"><span class="comment">// where it is located now.</span></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">300</span>, mySprite-&gt;<span class="built_in">getPositionY</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delay - create a small delay</span></span><br><span class="line"><span class="keyword">auto</span> delay = DelayTime::<span class="built_in">create</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> seq = Sequence::<span class="built_in">create</span>(moveBy, delay, moveTo, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(seq);</span><br></pre></td></tr></table></figure><p>注意到cocos里面用到数组对象时总要指定最后一位为空指针</p><p>查看源码发现runAction指接收一个参数,也就是说延迟动作只能显示写一个delay对象实现</p><h3 id="色彩混合">色彩混合</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;mysprite.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tints a node to the specified RGB values</span></span><br><span class="line"><span class="keyword">auto</span> tintTo = TintTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">120.0f</span>, <span class="number">232.0f</span>, <span class="number">254.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(tintTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tints a node BY the delta of the specified RGB values.</span></span><br><span class="line"><span class="keyword">auto</span> tintBy = TintBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">120.0f</span>, <span class="number">232.0f</span>, <span class="number">254.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(tintBy);</span><br></pre></td></tr></table></figure><p>可用于实现药水对兵种的作用效果</p><h2 id="瓦片地图">瓦片地图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建地图</span></span><br><span class="line">map=TMXTiledMap::<span class="built_in">create</span>(<span class="string">&quot;test.tmx&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//瓦片处理</span></span><br><span class="line">Size tileSize = map-&gt;<span class="built_in">getTileSize</span>();        <span class="comment">// 单个瓦片像素大小（如 64x64）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放地图</span></span><br><span class="line"><span class="comment">// Step 1: 计算横竖各能放多少个完整瓦片（向下取整）</span></span><br><span class="line"><span class="type">int</span> maxTilesX = (<span class="type">int</span>)(visibleSize.width / tileSize.width);</span><br><span class="line"><span class="type">int</span> maxTilesY = (<span class="type">int</span>)(visibleSize.height / tileSize.height);</span><br><span class="line"><span class="comment">//注意到这里的visiblesize根据需要选择获取全屏还是裁剪掉菜单栏的区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止除零或瓦片太大的情况</span></span><br><span class="line"><span class="keyword">if</span> (maxTilesX &lt;= <span class="number">0</span>) maxTilesX = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (maxTilesY &lt;= <span class="number">0</span>) maxTilesY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 计算两种缩放比例</span></span><br><span class="line"><span class="type">float</span> scaleIfFitWidth = visibleSize.width / (maxTilesX * tileSize.width);</span><br><span class="line"><span class="type">float</span> scaleIfFitHeight = visibleSize.height / (maxTilesY * tileSize.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 选择「宁可裁掉一点地图，也绝不留黑边」的策略 → 取较大值</span></span><br><span class="line"><span class="type">float</span> finalScale = std::<span class="built_in">max</span>(scaleIfFitWidth, scaleIfFitHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 应用缩放 + 严格左上角对齐 + 防1像素缝隙</span></span><br><span class="line">map-&gt;<span class="built_in">setScale</span>(finalScale);</span><br><span class="line">map-&gt;<span class="built_in">setAnchorPoint</span>(<span class="built_in">Vec2</span>(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">// 左上角为锚点</span></span><br><span class="line">map-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(<span class="number">-0.5f</span>, visibleSize.height + <span class="number">0.5f</span>));   </span><br></pre></td></tr></table></figure><p>尽管写了这么多,但最后我还是用AI完成绝大部分代码的,AI的文献阅读能力让期末周的我泪流满面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cocos命令&quot;&gt;cocos命令&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25 离散数学整理-逻辑关系</title>
    <link href="https://revival-of-hope.github.io/2025/12/25/archives-2025-2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/25/archives-2025-2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/</id>
    <published>2025-12-25T00:00:00.000Z</published>
    <updated>2026-01-11T06:29:44.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命题逻辑"><a class="markdownIt-Anchor" href="#命题逻辑"></a> 命题逻辑</h1><h2 id="逻辑联结词"><a class="markdownIt-Anchor" href="#逻辑联结词"></a> 逻辑联结词</h2><h3 id="析取与合取"><a class="markdownIt-Anchor" href="#析取与合取"></a> 析取与合取</h3><blockquote><p>析取符号: ∨<br />合取符号: ∧</p></blockquote><ul><li>想象合取就是两个条件都要满足,析取符号就像漏斗一样析取东西,因此朝上</li></ul><h3 id="蕴含与等价"><a class="markdownIt-Anchor" href="#蕴含与等价"></a> 蕴含与等价</h3><blockquote><p>p-&gt;q =¬p∨q</p></blockquote><ul><li>不要读作<code>如果p,那么q</code>,而是读作p蕴含q,表示p是q的充分条件,q是p的必要条件</li><li>我的理解:当p为真自然可以推出q为真,故p真q假真值为F,当p为假时无法得知q的情况,故只能默认为T</li></ul><p><strong>真值表</strong><br /><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/image.png" alt="来自知乎大佬" /></p><blockquote><p>p ↔ q=(¬p∨q)∧(¬q∨p)</p></blockquote><ul><li>由于p,q互为充要条件,故p与q真值相同时等价式为真</li></ul><h2 id="命题"><a class="markdownIt-Anchor" href="#命题"></a> 命题</h2><p>设A为一个命题公式</p><ul><li>若A在所有赋值下都为真,则为重言式</li><li>若A在所有赋值下都为假,则为矛盾式</li><li>若至少有一组成真赋值,则为可满足式</li></ul><hr /><blockquote><p><em>不能被分解</em>,<em>真值确定</em>的简单陈述句称为<strong>简单命题</strong>(<em>原子命题</em>,<em>命题常项</em>)</p></blockquote><ul><li>(真值未知但确定也是命题)</li><li>真值可以变化的简单陈述句称为命题变项(<strong>不是命题!!!</strong>)<br />使用联结词联结简单命题形成的命题称为复合命题</li></ul><h2 id="逻辑等值式汇总"><a class="markdownIt-Anchor" href="#逻辑等值式汇总"></a> 逻辑等值式汇总</h2><p><strong>双重否定律</strong></p><ul><li><code>¬¬A ⇔ A</code></li></ul><p><strong>幂等律</strong></p><ul><li><code>A ∧ A ⇔ A</code></li><li><code>A ∨ A ⇔ A</code></li></ul><p><strong>交换律</strong></p><ul><li><code>A ∨ B ⇔ B ∨ A</code></li><li><code>A ∧ B ⇔ B ∧ A</code></li></ul><p><strong>结合律</strong></p><ul><li><code>(A ∧ B) ∧ C ⇔ A ∧ (B ∧ C)</code></li><li><code>(A ∨ B) ∨ C ⇔ A ∨ (B ∨ C)</code></li></ul><p><strong>分配律</strong></p><ul><li><code>A ∨ (B ∧ C) ⇔ (A ∨ B) ∧ (A ∨ C)</code></li><li><code>A ∧ (B ∨ C) ⇔ (A ∧ B) ∨ (A ∧ C)</code></li></ul><p><strong>德·摩根律</strong></p><ul><li><code>¬(A ∨ B) ⇔ ¬A ∧ ¬B</code></li><li><code>¬(A ∧ B) ⇔ ¬A ∨ ¬B</code></li></ul><p><strong>吸收律</strong></p><ul><li><code>A ∨ (A ∧ B) ⇔ A</code></li><li><code>A ∧ (A ∨ B) ⇔ A</code></li></ul><p><strong>零律</strong></p><ul><li><code>A ∨ 1 ⇔ 1</code></li><li><code>A ∧ 0 ⇔ 0</code></li></ul><p><strong>同一律</strong></p><ul><li><code>A ∨ 0 ⇔ A</code></li><li><code>A ∧ 1 ⇔ A</code></li></ul><p><strong>排中律</strong></p><ul><li><code>A ∨ ¬A ⇔ 1</code></li></ul><p><strong>矛盾律</strong></p><ul><li><code>A ∧ ¬A ⇔ 0</code></li></ul><p><strong>蕴涵等值式</strong></p><ul><li><code>A → B ⇔ ¬A ∨ B</code></li></ul><p><strong>等价等值式</strong></p><ul><li><code>A ↔ B ⇔ (A → B) ∧ (B → A)</code></li></ul><p><strong>假言易位（逆否命题）</strong></p><ul><li><code>A → B ⇔ ¬B → ¬A</code></li></ul><p><strong>等价否定等值式</strong></p><ul><li><code>A ↔ B ⇔ ¬A ↔ ¬B</code></li></ul><p><strong>归谬论</strong></p><ul><li><code>(A → B) ∧ (A → ¬B) ⇔ ¬A</code></li></ul><p><strong>对称差等值式</strong></p><ul><li><code>A ⊕ B ⇔ (A ∨ B) ∧ ¬(A ∧ B)</code></li><li><code>A ⊕ B ⇔ (A ∧ ¬B) ∨ (¬A ∧ B)</code></li></ul><h2 id="联结词完备集"><a class="markdownIt-Anchor" href="#联结词完备集"></a> 联结词完备集</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><blockquote><p>设 S 是一个联结词集合。若任意真值函数都可以由<strong>仅含 S 中联结词</strong>构成的命题公式来表示，则称 S 为<strong>联结词完备集</strong></p></blockquote><ul><li>这里的真值函数可以看作是命题对应的函数,不同形式但等价的命题有相同的真值函数</li></ul><h3 id="与非和或非"><a class="markdownIt-Anchor" href="#与非和或非"></a> 与非和或非</h3><ul><li><p>与非:<code>p ↑ q = ¬(p ∧ q)</code></p></li><li><p>或非:<code>p ↓ q = ¬(p ∨ q)</code></p></li></ul><blockquote><p>可以把箭头想象成水流,自然要从开口进入,这样就好记忆了</p></blockquote><h3 id="联结词完备集整理"><a class="markdownIt-Anchor" href="#联结词完备集整理"></a> 联结词完备集整理</h3><table><thead><tr><th>编号</th><th>联结词集合</th><th>是否完备</th><th>证明思路 / 说明</th></tr></thead><tbody><tr><td>S1</td><td>{¬, ∧, ∨, →, ↔}</td><td>完备</td><td>包含 ¬（非）、∧（与）、∨（或）三种基本联结词，可表示所有 n 元真值函数（经典教材定理）。→ 和 ↔ 可由 ¬、∧、∨ 表示。</td></tr><tr><td>S2</td><td>{¬, ∧, ∨, →}</td><td>完备</td><td>包含 ¬、∧、∨，能表示任意 n 元真值函数；→ 可由 ¬、∨ 表示（p → q ≡ ¬p ∨ q）。</td></tr><tr><td>S3</td><td>{¬, ∧, ∨}</td><td>完备</td><td>经典完备集，¬、∧、∨ 可表示任意 n 元真值函数。</td></tr><tr><td>S4</td><td>{¬, ∧}</td><td>完备</td><td>通过与非公式可表示 ∨：p ∨ q ≡ ¬(¬p ∧ ¬q)。因此可表示 ¬、∧、∨ → 完备。</td></tr><tr><td>S5</td><td>{¬, ∨}</td><td>完备</td><td>通过或非公式可表示 ∧：p ∧ q ≡ ¬(¬p ∨ ¬q)。因此可表示 ¬、∧、∨ → 完备。</td></tr><tr><td>S6</td><td>{¬, →}</td><td>完备</td><td>通过 ¬ 与 → 可以表示 ∧ 和 ∨：</td></tr></tbody></table><blockquote><p>观察可以知道,只要有¬和基础联结词中三个中的一个就是完备集</p></blockquote><p>同时↑和↓可以单独作为完备集</p><h4 id="与非单独作为完备集"><a class="markdownIt-Anchor" href="#与非单独作为完备集"></a> 与非（↑）单独作为完备集</h4><ul><li>¬p ≡ p ↑ p</li><li>p ∧ q ≡ (p ↑ q) ↑ (p ↑ q)</li></ul><p><strong>证明提示</strong></p><ul><li>¬¬(p ∧ q)=¬(p↑q)</li></ul><h4 id="或非单独作为完备集"><a class="markdownIt-Anchor" href="#或非单独作为完备集"></a> 或非（↓）单独作为完备集</h4><ul><li>¬p ≡ p ↓ p</li><li>p ∨ q ≡ (p ↓ q) ↓ (p ↓ q)</li></ul><h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2><h3 id="合取范式和析取范式"><a class="markdownIt-Anchor" href="#合取范式和析取范式"></a> 合取范式和析取范式</h3><blockquote><p>析取范式:由有限个简单合取式构成的析取式<br />合取范式:由有限个简单析取式构成的合取式</p></blockquote><p><code>极小项:简单合取式中每个命题变项及其否定有且只有一个出现过一次</code><br /><code>极大项:简单析取式中每个命题变项及其否定有且只有一个出现过一次</code></p><blockquote><p>为什么说是极小项,因为所有命题的交集覆盖范围是最小的,效力最弱;而极大则是因为所有命题的并集覆盖范围是最大的,效力最强</p></blockquote><ul><li>若命题A的析取范式中所有合取式都是极小项,则称为A的<strong>主析取范式</strong></li><li>若命题A的合取范式中所有析取式都是极大项,则称为A的<strong>主合取范式</strong></li></ul><blockquote><p>这时可以对每个极小项进行编码成m(001),每个极大项为M(001)这样的形式,用角标来表示主析取范式和主合取范式</p></blockquote><h4 id="计算方法"><a class="markdownIt-Anchor" href="#计算方法"></a> 计算方法</h4><p>求A的主析取范式的方法</p><blockquote><p>若合取式B中不含命题变项p及其否定,则将B展开为合取形式B ∧ (p ∨ ¬p),消去重复出现的命题和极小项,将极小项按照角标由小到大的形式排列</p></blockquote><ul><li>至于为什么用合取形式而不是用析取形式B ∨(p ∧ ¬p),是因为要保证每个字式仍然是简单合取式</li></ul><blockquote><p>求出主析取范式后就可以求主合取范式了,主析取范式中没出现的极小项的角标作为极大项的角标,这些极大项构成的合取式为A的主合取范式.</p></blockquote><ul><li>当然反过来也是可以的</li></ul><h1 id="一阶逻辑"><a class="markdownIt-Anchor" href="#一阶逻辑"></a> 一阶逻辑</h1><h2 id="个体与谓词"><a class="markdownIt-Anchor" href="#个体与谓词"></a> 个体与谓词</h2><blockquote><ul><li>个体常项:表示具体或特定个体的词,用a,b,c…表示</li><li>个体变项:表示抽象或泛指个体的词,用x,y,z…表示</li><li>个体变项的取值范围称为个体域<br />当无特殊声明时,个体域可以表示所有事物,称为全总个体域</li><li>谓词常项与谓词变项和上述概念对应,用F,G,H…表示<br />谓词中包含的个体数称为元数,n元谓词含有n个个体词,0元谓词就是简单命题</li></ul></blockquote><h2 id="合式公式"><a class="markdownIt-Anchor" href="#合式公式"></a> 合式公式</h2><blockquote><p>合式公式:也叫谓词公式,简称<strong>公式</strong>,看做是命题A加上量词或者个体变项后的形态例如&quot;∀x(A∧B)&quot;就行了</p><p>在&quot;∀xA&quot;,&quot;∃xA&quot;中的x称为指导变项,A为相应量词的辖域,在辖域x的所有出现称为约束出现,不受辖域约束的出现称为自由出现</p></blockquote><ul><li>若公式A中<strong>无自由出现的个体变项</strong>,则称A为封闭的合式公式,简称闭式</li></ul><blockquote><p><strong>换名规则</strong>: 将一个指导变项及其在辖域中所有的约束出现替换成没出现过的个体变项符号</p></blockquote><ul><li>换句话说换名就是让公式中不存在既是自由出现又是约束出现的个体变项</li></ul><p>解释: 对公式A中出现的每个个体常项和谓词变项进行赋值,由以下四部分构成</p><ol><li>非空个体域D</li><li>给个体常项指定一个D中的元素</li><li>给函数变项指定一个D上的函数</li><li>给谓词变项指定一个D上的谓词</li></ol><blockquote><p>这个时候∀可以看作是∧,∃就看作是∨,这个通过下面的例题就很好理解了</p></blockquote><p><strong>例子</strong><br /><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2026-01-05_12-59-09.webp" alt="alt text" /></p><ul><li>(1)中直接把x=2和x=3的情况用∧连接了</li></ul><h2 id="等值式和前束范式"><a class="markdownIt-Anchor" href="#等值式和前束范式"></a> 等值式和前束范式</h2><blockquote><p>等值式:若A ↔ B为永真式,则称A与B是等值的,记作<code>A⇔B</code><br />前束范式:A=QB,其中Q为∀x或者∃x这样的形式,B为不含量词的谓词公式</p></blockquote><h3 id="一-量词否定等值式"><a class="markdownIt-Anchor" href="#一-量词否定等值式"></a> 一、量词否定等值式</h3><ul><li><code>¬∀xA(x) ⇔ ∃x¬A(x)</code></li><li><code>¬∃xA(x) ⇔ ∀x¬A(x)</code></li></ul><h3 id="二-量词辖域收缩与扩张等值式b-中不含-x"><a class="markdownIt-Anchor" href="#二-量词辖域收缩与扩张等值式b-中不含-x"></a> 二、量词辖域收缩与扩张等值式（B 中不含 x）</h3><ul><li><p><code>∀x(A(x) ∨ B) ⇔ ∀xA(x) ∨ B</code></p></li><li><p><code>∀x(A(x) ∧ B) ⇔ ∀xA(x) ∧ B</code></p></li><li><p><code>∀x(A(x) → B) ⇔ ∃xA(x) → B</code></p></li><li><p><code>∀x(B → A(x)) ⇔ B → ∀xA(x)</code></p></li><li><p><code>∃x(A(x) ∨ B) ⇔ ∃xA(x) ∨ B</code></p></li><li><p><code>∃x(A(x) ∧ B) ⇔ ∃xA(x) ∧ B</code></p></li><li><p><code>∃x(A(x) → B) ⇔ ∀xA(x) → B</code></p></li><li><p><code>∃x(B → A(x)) ⇔ B → ∃xA(x)</code></p></li></ul><h3 id="三-量词分配等值式"><a class="markdownIt-Anchor" href="#三-量词分配等值式"></a> 三、量词分配等值式</h3><ul><li><code>∀x(A(x) ∧ B(x)) ⇔ ∀xA(x) ∧ ∀xB(x)</code></li><li><code>∃x(A(x) ∨ B(x)) ⇔ ∃xA(x) ∨ ∃xB(x)</code></li></ul><p>注意到∀对∨是不可分配的,∃对∧是不可分配的,这也很好理解.</p><blockquote><p>因为含有B的公式中的约束变元x都本应该写成y(防止与A中的x相同),但在<code>∀xA(x) ∧ ∀yB(y)</code>中由于<code>∧</code>需要满足两边式子都成立,因此x=y时也要成立,所以可以写成<code>∀x(A(x) ∧ B(x))</code>,而若 是<code>∀xA(x) ∨ ∀yB(y)</code>只需要有一边式子成立,故当x=y时可能有一边不满足.</p><p>同时,<code>∃xA(x) ∨ ∃yB(y)</code>由于只要找到一个数z满足一边条件就能让式子成立,无论是x=z还是y=z都可以,因此可以写成<code>∃x(A(x) ∨ B(x)) </code>,而<code>∃xA(x) ∧ ∃yB(y)</code>中由于需要找到两个数z1,z2使得这个式子满足,而这两个数不一定相等,故不能合并.</p></blockquote><h1 id="集合与关系"><a class="markdownIt-Anchor" href="#集合与关系"></a> 集合与关系</h1><h2 id="集合概念"><a class="markdownIt-Anchor" href="#集合概念"></a> 集合概念</h2><h3 id="真包含"><a class="markdownIt-Anchor" href="#真包含"></a> 真包含</h3><ul><li><p>A ⊂ B 当且仅当</p><ul><li>对任意 x，若 x ∈ A，则 x ∈ B</li><li>且 A ≠ B</li></ul></li></ul><h3 id="幂集"><a class="markdownIt-Anchor" href="#幂集"></a> 幂集</h3><blockquote><p>P(A)：A 的所有子集组成的集合</p></blockquote><p><strong>公式：</strong><br />P(A) = { B | B ⊆ A }<br />|p(A)|=2^|A|</p><h2 id="集合运算"><a class="markdownIt-Anchor" href="#集合运算"></a> 集合运算</h2><h3 id="相对补"><a class="markdownIt-Anchor" href="#相对补"></a> 相对补</h3><ul><li><code>A - B = A ∩ ~B</code></li></ul><h3 id="对称差"><a class="markdownIt-Anchor" href="#对称差"></a> 对称差</h3><ul><li><code>A ⊕ B = (A − B) ∪ (B − A)</code></li><li><code>A ⊕ B = (A ∪ B) − (A ∩ B)</code></li></ul><blockquote><p>对称差运算满足结合律,交换律,分配律,消去律<br />其中分配律最难理解</p></blockquote><p>证明：<code>A ∩ (B ⊕ C) = (A ∩ B) ⊕ (A ∩ C)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A ∩ (B ⊕ C)</span><br><span class="line">= A ∩ [(B − C) ∪ (C − B)]</span><br><span class="line">= [A ∩ (B − C)] ∪ [A ∩ (C − B)]</span><br><span class="line">= [(A ∩ B) − (A ∩ C)] ∪ [(A ∩ C) − (A ∩ B)]</span><br><span class="line">= (A ∩ B) ⊕ (A ∩ C)</span><br></pre></td></tr></table></figure><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-25_21-34-39.webp" alt="" /></p><h2 id="关系的定义"><a class="markdownIt-Anchor" href="#关系的定义"></a> 关系的定义</h2><p><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-49-58.webp" alt="定义" /></p><ul><li>A到A的关系R称为A上的关系<br /><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-53-32.webp" alt="" /></li></ul><h3 id="全域关系与恒等关系"><a class="markdownIt-Anchor" href="#全域关系与恒等关系"></a> 全域关系与恒等关系</h3><ul><li><strong>全域关系（EA）</strong>：集合 A 上的全体可能的有序对，即 EA = A × A。</li><li><strong>恒等关系（IA）</strong>：集合 A 上所有元素与自身配对的关系，即 IA = {&lt;x, x&gt; | x ∈ A}</li></ul><h2 id="关系的几种性质"><a class="markdownIt-Anchor" href="#关系的几种性质"></a> 关系的几种性质</h2><p>这里都是对于A上的关系R进行展开的</p><table><thead><tr><th><strong>性质名称</strong></th><th><strong>定义</strong></th><th><strong>关系矩阵特点</strong></th><th><strong>关系图特点</strong></th></tr></thead><tbody><tr><td><strong>自反性</strong></td><td><code>∀x∈A，(x,x)∈R</code></td><td><strong>主对角线元素全为 <code>1</code></strong></td><td><strong>每个结点都有自环</strong></td></tr><tr><td><strong>反自反性</strong></td><td><code>∀x∈A，(x,x)∉R</code></td><td><strong>主对角线元素全为 <code>0</code></strong></td><td><strong>所有结点均无自环</strong></td></tr><tr><td><strong>对称性</strong></td><td><code>∀x,y∈A，(x,y)∈R ⇒ (y,x)∈R</code></td><td><strong>矩阵关于主对角线对称</strong></td><td><strong>任一有向边必有反向边</strong></td></tr><tr><td><strong>反对称性</strong></td><td><code>∀x,y∈A，(x,y)∈R 且 (y,x)∈R ⇒ x=y</code></td><td><strong>主对角线外不出现对称的 <code>1</code></strong></td><td><strong>不同结点间不能出现双向边</strong></td></tr><tr><td><strong>传递性</strong></td><td><code>∀x,y,z∈A，(x,y)∈R 且 (y,z)∈R ⇒ (x,z)∈R</code></td><td><strong>若 <code>m_xy=1</code> 且 <code>m_yz=1</code>，则 <code>m_xz=1</code></strong></td><td><strong>存在长度为 2 的路径则必须有直接边</strong></td></tr></tbody></table><p>注意到反对称和对称可以是在单位矩阵中同时存在,因为两个对称位置都为0也可以认为是反对称的</p><h2 id="关系的运算"><a class="markdownIt-Anchor" href="#关系的运算"></a> 关系的运算</h2><h3 id="关系的逆"><a class="markdownIt-Anchor" href="#关系的逆"></a> 关系的逆</h3><p>设关系 ® 是集合 (A) 到集合 (B) 的一个二元关系，即 R ⊆ A × B，则关系 R 的逆关系记作 R⁻¹，定义为：</p><ul><li>R⁻¹ = {(b, a) | (a, b) ∈ R}<br />即将 R 中每一对元素的顺序交换。</li></ul><p><strong>性质</strong>：</p><ul><li>(R⁻¹)⁻¹ = R</li><li>如果 R 是 A 上的关系，则 R⁻¹ 仍是 A 上的关系</li></ul><hr /><h3 id="关系合成"><a class="markdownIt-Anchor" href="#关系合成"></a> 关系合成</h3><p>设 R 是集合 A 到 B 的关系，S 是集合 B 到 C 的关系，则关系 S 与 R 的合成（或复合）记作 S ∘ R，定义为：</p><ul><li>S ∘ R = {(a, c) | 存在 b ∈ B，使得 (a, b) ∈ R 且 (b, c) ∈ S}</li></ul><p><strong>性质</strong>：</p><blockquote><p><code>(F ∘ G) ∘ H = F ∘ (G ∘ H)</code><br /><code>(F ∘ G)⁻¹ = G⁻¹ ∘ F⁻¹</code></p></blockquote><h4 id="关系合成结合律的证明"><a class="markdownIt-Anchor" href="#关系合成结合律的证明"></a> 关系合成结合律的证明</h4><p>要证：(F ∘ G) ∘ H = F ∘ (G ∘ H)</p><p><strong>证明思路</strong>：通过任意元素对 &lt;x, y&gt; 来判断两边是否相等。</p><ol><li><p>任取一对 &lt;x, y&gt;，假设 &lt;x, y&gt; ∈ (F ∘ G) ∘ H。<br />根据关系合成的定义，存在 t 使得：</p><ul><li>&lt;x, t&gt; ∈ F ∘ G</li><li>&lt;t, y&gt; ∈ H</li></ul></li><li><p>进一步展开 &lt;x, t&gt; ∈ F ∘ G 的定义，存在 s 使得：</p><ul><li>&lt;x, s&gt; ∈ F</li><li>&lt;s, t&gt; ∈ G</li></ul></li><li><p>现在我们有：</p><ul><li>&lt;x, s&gt; ∈ F</li><li>&lt;s, t&gt; ∈ G</li><li>&lt;t, y&gt; ∈ H</li></ul><p>也就是存在 s 和 t，使得上述三条都成立。</p></li><li><p>可以先固定 s，再看 t 是否存在：</p><ul><li>对于固定的 s，存在 t 使得 &lt;s, t&gt; ∈ G 且 &lt;t, y&gt; ∈ H</li><li>根据合成定义，这说明 &lt;s, y&gt; ∈ G ∘ H</li></ul></li><li><p>因此我们得到：</p><ul><li>&lt;x, s&gt; ∈ F</li><li>&lt;s, y&gt; ∈ G ∘ H</li><li>所以 &lt;x, y&gt; ∈ F ∘ (G ∘ H)</li></ul></li><li><p>反向也类似（从 F ∘ (G ∘ H) → (F ∘ G) ∘ H），所以两边相等。</p></li></ol><hr /><h3 id="关系的幂"><a class="markdownIt-Anchor" href="#关系的幂"></a> 关系的幂</h3><p>设 R 是集合 A 上的关系，n 为自然数，则定义 R 的 n 次幂如下：</p><ol><li><p><strong>零次幂</strong><br />R⁰ = {&lt;x, x&gt; | x ∈ A} = IA（恒等关系）</p></li><li><p><strong>递推定义</strong><br />Rⁿ⁺¹ = Rⁿ ∘ R（与矩阵乘法类似，用关系合成定义）</p></li></ol><h2 id="集合-a-上关系的个数"><a class="markdownIt-Anchor" href="#集合-a-上关系的个数"></a> 集合 A 上关系的个数</h2><p>设集合 A 有 n 个元素，即 |A| = n。</p><ol><li><p><strong>关系的定义</strong><br />A 上的一个关系 R 是 A × A 的任意子集。</p><ul><li>因为 A × A 有 n² 个有序对</li><li>每个有序对可以选择“在关系中”或“不在关系中”</li></ul></li><li><p><strong>关系数计算</strong></p><ul><li>对每个有序对有 2 种选择</li><li>总共有 n² 个有序对</li><li>因此关系的总数为 2^(n²)</li></ul></li></ol><p><strong>结论</strong>：<br />集合 A 上关系的总数 = 2^(n²)</p><hr /><h2 id="关系闭包"><a class="markdownIt-Anchor" href="#关系闭包"></a> 关系闭包</h2><p><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_16-02-46.webp" alt="" /></p><h3 id="自反闭包reverse"><a class="markdownIt-Anchor" href="#自反闭包reverse"></a> 自反闭包(reverse)</h3><ul><li><code>r(R) = R ∪ &#123;(x,x) | x ∈ A&#125;</code><br />相当于加上单位矩阵I</li></ul><h3 id="对称闭包symmetry"><a class="markdownIt-Anchor" href="#对称闭包symmetry"></a> 对称闭包(symmetry)</h3><ul><li><code>s(R) = R ∪ R⁻¹</code><br />补全另一半即可</li></ul><h3 id="传递闭包transfer"><a class="markdownIt-Anchor" href="#传递闭包transfer"></a> 传递闭包(transfer)</h3><ul><li><code>t(R) = R ∪ R² ∪ R³ ∪ ···</code><br />这个只好一个个推了,不出错就行’</li></ul><h2 id="等价类-商集与划分"><a class="markdownIt-Anchor" href="#等价类-商集与划分"></a> 等价类, 商集与划分</h2><h3 id="等价类"><a class="markdownIt-Anchor" href="#等价类"></a> 等价类</h3><p><strong>定义</strong></p><blockquote><p>设 R 是集合 A 上的等价关系，对任意 a ∈ A，<br />a 的等价类定义为<br />[a] = { x ∈ A | (a, x) ∈ R }</p></blockquote><h4 id="四条性质及其证明"><a class="markdownIt-Anchor" href="#四条性质及其证明"></a> 四条性质及其证明</h4><hr /><p><strong>性质一：a ∈ [a]</strong></p><blockquote><p>即每个元素属于自己的等价类</p></blockquote><p><strong>证明</strong></p><blockquote><p>因为 R 是等价关系，满足自反性，<br />所以 (a, a) ∈ R，<br />由等价类定义可知 a ∈ [a]。</p></blockquote><hr /><p><strong>性质二：若 b ∈ [a]，则 [b] = [a]</strong></p><p><strong>证明</strong></p><blockquote><p>b ∈ [a] 等价于 (a, b) ∈ R。</p><p>先证 [b] ⊆ [a]：<br />任取 x ∈ [b]，则 (b, x) ∈ R。<br />又因 (a, b) ∈ R，R 具有传递性，<br />得 (a, x) ∈ R，故 x ∈ [a]。</p><p>再证 [a] ⊆ [b]：<br />由 (a, b) ∈ R 且 R 具有对称性，<br />得 (b, a) ∈ R，<br />同理可证任意 x ∈ [a] 有 x ∈ [b]。</p><p>因此 [a] = [b]。</p></blockquote><hr /><p><strong>性质三：若 [a] ∩ [b] ≠ ∅，则 [a] = [b] (即aRy)</strong></p><p><strong>证明</strong></p><blockquote><p>设存在 c ∈ [a] ∩ [b]，<br />则 (a, c) ∈ R 且 (b, c) ∈ R。</p><p>由 (b, c) ∈ R 和对称性得 (c, b) ∈ R，<br />再由 (a, c) ∈ R 和传递性得 (a, b) ∈ R。</p><p>于是 b ∈ [a]，由性质二可得 [a] = [b]。</p></blockquote><hr /><p><strong>性质四：所有等价类的并集等于原集合 A</strong></p><p><strong>证明</strong></p><blockquote><p>任取 x ∈ A，<br />由于 R 是等价关系，满足自反性，<br />有 (x, x) ∈ R，<br />因而 x ∈ [x]。</p><p>又因为 [x] 是 A 上的一个等价类，<br />所以 x 属于所有等价类的并集中。</p><p>由 x 的任意性可得<br />⋃{ [a] | a ∈ A } = A。</p></blockquote><h3 id="商集"><a class="markdownIt-Anchor" href="#商集"></a> 商集</h3><p><strong>定义</strong></p><blockquote><p>设 R 是集合 A 上的等价关系,<br />A 关于 R 的商集定义为<br />A / R = { [a] | a ∈ A }</p></blockquote><ul><li>也就是说把A划分成多个等价类</li></ul><hr /><h3 id="划分"><a class="markdownIt-Anchor" href="#划分"></a> 划分</h3><p><strong>定义</strong></p><blockquote><p>设 A 为非空集合, 若 A 的一个子集族 P 满足</p><ol><li>任意 B ∈ P, B ≠ ∅</li><li>任意 B1, B2 ∈ P, 若 B1 ≠ B2, 则 B1 ∩ B2 = ∅</li><li>⋃P = A</li></ol></blockquote><p><strong>则称 P 是 A 的一个划分</strong></p><hr /><h4 id="由集合-a-的一个划分得到-a-上的等价关系"><a class="markdownIt-Anchor" href="#由集合-a-的一个划分得到-a-上的等价关系"></a> 由集合 A 的一个划分得到 A 上的等价关系</h4><blockquote><p>设 A 为非空集合，<br />π = { A₁, A₂, … } 是 A 的一个划分。</p></blockquote><p><strong>定义关系 R：</strong></p><blockquote><p>R = { &lt;x, y&gt; | x, y ∈ A，且 x 与 y 属于 π 中的同一划分块 }</p></blockquote><p><strong>说明：</strong></p><ul><li>对任意 x ∈ A，x 与自身属于同一划分块，故 &lt;x, x&gt; ∈ R</li><li>若 &lt;x, y&gt; ∈ R，则 x、y 在同一划分块中，对称性显然成立</li><li>若 &lt;x, y&gt; ∈ R 且 &lt;y, z&gt; ∈ R，则 x、y、z 属于同一划分块，传递性成立</li></ul><blockquote><p>因此，R 是集合 A 上的等价关系。</p></blockquote><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><blockquote><p>给出 A = {1, 2, 3} 上所有的等价关系</p></blockquote><ul><li><strong>求解思路</strong><br />先写出 A 的所有划分，再由每个划分得到对应的等价关系。</li></ul><hr /><h4 id="第一步列出-a-的所有划分"><a class="markdownIt-Anchor" href="#第一步列出-a-的所有划分"></a> 第一步：列出 A 的所有划分</h4><p>A = {1, 2, 3} 的所有划分共有 5 种：</p><ol><li>π₁ = { {1}, {2}, {3} }</li><li>π₂ = { {1, 2}, {3} }</li><li>π₃ = { {1, 3}, {2} }</li><li>π₄ = { {2, 3}, {1} }</li><li>π₅ = { {1, 2, 3} }</li></ol><hr /><h4 id="第二步由划分写出对应的等价关系"><a class="markdownIt-Anchor" href="#第二步由划分写出对应的等价关系"></a> 第二步：由划分写出对应的等价关系</h4><p><strong>π₁ = { {1}, {2}, {3} }</strong></p><blockquote><p>R₁ = { &lt;1,1&gt;, &lt;2,2&gt;, &lt; 3,3&gt; }</p></blockquote><hr /><p><strong>π₂ = { {1,2}, {3} }</strong></p><blockquote><p>R₂ = {<br />&lt;1,1&gt;, &lt;2,2&gt;, &lt; 3,3&gt;,<br />&lt;1,2&gt;, &lt;2,1&gt;<br />}</p></blockquote><hr /><p><strong>π₃ = { {1,3}, {2} }</strong></p><blockquote><p>R₃ = {<br />&lt;1,1&gt;, &lt; 3,3&gt;, &lt;2,2&gt;,<br />&lt;1,3&gt;, &lt; 3,1&gt;<br />}</p></blockquote><hr /><p><strong>π₄ = { {2,3}, {1} }</strong></p><blockquote><p>R₄ = {<br />&lt;2,2&gt;, &lt; 3,3&gt;, &lt;1,1&gt;,<br />&lt;2,3&gt;, &lt; 3,2&gt;<br />}</p></blockquote><hr /><p><strong>π₅ = { {1,2,3} }</strong></p><blockquote><p>R₅ = {<br />&lt;1,1&gt;, &lt;2,2&gt;, &lt; 3,3&gt;,<br />&lt;1,2&gt;, &lt;2,1&gt;,<br />&lt;1,3&gt;, &lt; 3,1&gt;,<br />&lt;2,3&gt;, &lt; 3,2&gt;<br />}</p></blockquote><hr /><p><strong>结论</strong></p><blockquote><p>集合 A = {1,2,3} 上一共有 <strong>5 个等价关系</strong>，<br />与 A 的 <strong>5 种划分一一对应</strong>。</p></blockquote><h2 id="等价关系与偏序关系"><a class="markdownIt-Anchor" href="#等价关系与偏序关系"></a> 等价关系与偏序关系</h2><blockquote><p>等价关系:要求集合A上的R关系是自反,对称,传递的.<br />偏序关系:要求集合A上的R关系是自反,反对称,传递的.</p></blockquote><ul><li><em>从定义可以知道偏序关系图中不存在双向箭头.</em></li><li><em>注意下面的小于等于只是表示偏序关系中的上下级关系</em></li></ul><blockquote><p><strong>偏序集</strong>:A与A上的偏序关系R一起称做偏序集,记为&lt;A,R&gt;,对于任意的x,y∈A,若x&lt;=y或者y&lt;=x成立,则称x与y是可比的,若x&lt;y,且x与y之间不存在z∈A使得x&lt;z&lt;y,则称y盖住x.</p></blockquote><ul><li>简略一点说,y盖住x表示y是x的直属上司,y与x可比表示二者在同一条分支上,具有亲缘关系</li></ul><blockquote><p><strong>全序集</strong>:若偏序集中∀x,y∈A,x与y都可比,则称(A,&lt;=)是全序集</p></blockquote><blockquote><p>设 (A, ≤) 为偏序集，B ⊆ A。</p><ul><li><strong>最小元</strong>：若存在 m ∈ B，使得 ∀x ∈ B，都有 m ≤ x，则称 m 为 B 的最小元。</li><li><strong>最大元</strong>：若存在 M ∈ B，使得 ∀x ∈ B，都有 x ≤ M，则称 M 为 B 的最大元。</li><li><strong>极小元</strong>：若 m ∈ B，且不存在 x ∈ B 使得 x &lt; m，则称 m 为 B 的极小元。</li><li><strong>极大元</strong>：若 M ∈ B，且不存在 x ∈ B 使得 M &lt; x，则称 M 为 B 的极大元。</li></ul><hr /><ul><li><strong>上界</strong>：若 u ∈ A，使得 ∀x ∈ B，都有 x ≤ u，则称 u 为 B 的一个上界。</li><li><strong>下界</strong>：若 l ∈ A，使得 ∀x ∈ B，都有 l ≤ x，则称 l 为 B 的一个下界。</li><li><strong>最小上界</strong>：u是B的上界集合中的最小元，则称 u 为 B 的最小上界。</li><li><strong>最大下界</strong>：l是B的下界集合中的最大元，则称 l 为 B 的最大下界。</li></ul></blockquote><ul><li>简单一点说,最大元就是跟所有元素都可比,故需要位于哈斯图的上顶点,约束所有分支,故只能有一个,同理,最小元位于哈斯图的下顶点,只能有一个</li><li>极小元和极大元可以有多个,只要位于某一条分支的上顶点或者下顶点就可以了,因此最大元也是极小元,最小元也是极大元.</li><li>如果有多个极大元,就一定没有最大元,有多个极小元,就一定没有最小元,因为分支没有收束.</li><li>上界可以看成是偏序集中所有元素的上司,可以有多个,但最小上界只能有一个</li></ul><blockquote><p>我想到的问题:如果一个偏序子集B上方连接的两个直属上司构成了一个三角形时还会有最小上界吗</p></blockquote><ul><li>经过思考后我发现偏序关系图中<strong>不存在三角形</strong>,因为反对称性决定了<code>如果a&lt;=b,b&lt;=a则a=b</code>,故不会有两个分支在同级连接的情况,否则两个元素就相互可比了.</li></ul><h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1><h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2><blockquote><p>设 f 是集合 A 与 B 之间的二元关系，<br />若满足：<br />对任意 x ∈ dom(f)，存在<strong>唯一</strong>的 y ∈ ran(f) 使得 x f y 成立，<br />则称 f 为 <strong>函数</strong>（从 A 到 B 的函数）。</p></blockquote><blockquote><p>对于函数 f，如果 x f y，则通常记作<br />y = f(x)</p></blockquote><h3 id="单射-满射-双射"><a class="markdownIt-Anchor" href="#单射-满射-双射"></a> 单射 / 满射 / 双射</h3><blockquote><p>设 f : A → B 为函数。</p></blockquote><ul><li><p><strong>单射</strong></p><blockquote><p>若对任意 x₁, x₂ ∈ A，<br />f(x₁) = f(x₂) ⟹ x₁ = x₂，<br />则称 f 为从 A 到 B 的单射。</p></blockquote></li><li><p><strong>满射</strong></p><blockquote><p>若对任意 y ∈ B，<br />存在 x ∈ A，使得 f(x) = y，<br />则称 f 为从 A 到 B 的满射。</p></blockquote></li><li><p><strong>双射</strong></p><blockquote><p>若 f 既是单射又是满射，<br />则称 f 为从 A 到 B 的双射。</p></blockquote></li></ul><hr /><h3 id="特征函数"><a class="markdownIt-Anchor" href="#特征函数"></a> 特征函数</h3><blockquote><p>设 A 为集合，B ⊆ A，<br />定义函数 χ_B : A → {0, 1} 为</p></blockquote><blockquote><p>χ_B(x) = 1，当 x ∈ B<br />χ_B(x) = 0，当 x ∉ B</p></blockquote><blockquote><p>χ_B 称为集合 B 在 A 上的特征函数。</p></blockquote><h3 id="b-上-a"><a class="markdownIt-Anchor" href="#b-上-a"></a> B 上 A</h3><blockquote><p><strong>定义</strong></p></blockquote><blockquote><p>所有从集合 A 到集合 B 的函数所组成的集合，记作 B 上 A，<br />读作“B 上 A”。</p></blockquote><p><strong>符号化表示</strong></p><blockquote><p>B^A = { f | f : A → B }</p></blockquote><p><strong>计数性质</strong></p><ul><li><p>设 |A| = m，|B| = n，且 m，n &gt; 0，<br />则</p><blockquote><p>|B^A| = n^m</p></blockquote></li></ul><p><strong>特殊情况</strong></p><ul><li><p>若 A = ∅，则</p><blockquote><p>B^∅ = { ∅ }</p></blockquote></li><li><p>若 A ≠ ∅ 且 B = ∅，则</p><blockquote><p>∅^A = ∅</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命题逻辑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#命题逻辑&quot;&gt;&lt;/a&gt; 命题逻辑&lt;/h1&gt;
&lt;h2 id=&quot;逻辑联结词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#逻辑联结词&quot;&gt;&lt;/a&gt; 逻辑联结词&lt;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-24 病毒攻击</title>
    <link href="https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/</id>
    <published>2025-12-24T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>下了一个破解版游戏,结果火绒直接弹出窗口提示我有三百多个exe感染了jadtre ax 病毒<br><img src="/images/archives/2025/2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/PixPin_2025-12-24_09-58-14.webp" alt=""></p><p>到这个时候我才发现我对网络安全实际上是一窍不通,<br>只好先用火绒把所有感染的exe放到隔离区,然后来了一个全盘扫描,我以后一定要好好研究一下计算机的底层知识和病毒攻击原理.</p><p>首先我找到了<a href="https://www.virusview.net/malware/Virus/Win32/Jadtre">计算机病毒百科</a>里关于这个病毒的详细信息</p><blockquote><p>它会修改系统文件，包括操作系统的关键文件，以隐藏自身并且避免被杀软检测到。<br>该病毒会通过劫持用户的浏览器、修改主页和搜索引擎设置等方式，进行钓鱼攻击，诱导用户点击恶意链接，从而进一步传播病毒。<br>它会窃取用户的个人敏感信息，如登录密码、银行账号等，并将这些信息发送到黑客的服务器上。<br>病毒会利用系统的漏洞，进行远程控制，从而盗取用户的隐私信息或者操控计算机进行其他恶意行为。<br>该病毒还会利用系统资源进行挖矿或者进行分布式拒绝服务（DDoS）攻击。<br>它会禁用或损坏杀软程序的功能，以保证自身不被杀软识别和清除。</p></blockquote><p>发现它主要是诱导用户点击恶意链接,还好火绒直接帮我拦截了网页跳转.</p><p>顺藤摸瓜找到了这个<a href="https://www.antiycloud.com/#/antiy/safeinfor">网站</a>,我才发现网络安全确实是一个壁垒高却极为重要的领域,<br>想着在网上找一点入门教程,结果用中文搜全是AI文章或者垃圾文字,再一次体会到中文互联网的封闭性,只好问gpt,找到了以下网站:</p><blockquote><p>By Sunday evening, you could have taken your first real step into cybersecurity.<br>Here are 15 websites to kick-start your cybersecurity journey (all beginner-friendly):<br>1.TryHackMe  – Hands-on labs for all skill levels<br><a href="https://tryhackme.com">https://tryhackme.com</a><br>2.Hack The Box  – Gamified hacking challenges<br><a href="https://www.hackthebox.com">https://www.hackthebox.com</a><br>3.Blue Team Labs Online  – Defensive security scenarios<br><a href="https://lnkd.in/dckAehnQ">https://lnkd.in/dckAehnQ</a><br>4.OverTheWire – Fun war games to learn Linux &amp; networking<br><a href="https://lnkd.in/d66wAqDb">https://lnkd.in/d66wAqDb</a><br>5.PortSwigger Web Security Academy – Web app hacking from the pros<br><a href="https://lnkd.in/dyrBGjRh">https://lnkd.in/dyrBGjRh</a><br>6.VulnHub – Download vulnerable machines and hack away<br><a href="https://www.vulnhub.com">https://www.vulnhub.com</a><br>7.LetsDefend  – SOC analyst simulation<br><a href="https://letsdefend.io">https://letsdefend.io</a><br>8.CyberDefenders  – Threat hunting and forensics labs<br><a href="https://cyberdefenders.org">https://cyberdefenders.org</a><br>9.CTFtime – Find Capture the Flag competitions<br><a href="https://ctftime.org">https://ctftime.org</a><br>10.Security Blue Team  – Blue teaming certifications and practice<br><a href="https://lnkd.in/dmuUFfQX">https://lnkd.in/dmuUFfQX</a><br>11.PentesterLab – Web security training<br><a href="https://pentesterlab.com">https://pentesterlab.com</a><br>12.MITRE ATT&amp;CK – Learn real adversary tactics and techniques<br><a href="https://attack.mitre.org">https://attack.mitre.org</a><br>13.OWASP – Secure coding &amp; app security resources<br><a href="https://owasp.org">https://owasp.org</a><br>14.DFIR Diva – Free digital forensics resources<br><a href="https://dfirdiva.com">https://dfirdiva.com</a><br>15.Flare-On Challenges – Reverse engineering practice<br><a href="https://flare-on.com">https://flare-on.com</a></p></blockquote><blockquote><p><a href="https://github.com/404notf0und/Security-Data-Analysis-and-Visualization">找到了一个汇总链接</a><br>不多说了,尽管期末周快来了,兴趣学习的时间还是有的,开练.</p></blockquote><hr><p><strong>25号更新</strong><br>一开始我觉得这个病毒没什么危害性,就又把火绒隔离区里的exe给恢复了,现在发现我确实是智障,今晚扫描全盘发现基本所有的exe文件都被感染了,<br>里面有几百款游戏exe和工具exe,受不了了,太蠢了这也.我决定不再点击恢复文件,只能把这些文件全部删掉了.<br>好的,这下真的激发我对网络安全的兴趣了,做病毒真有这么好玩吗(😡)</p><p>这件事还让我看到火绒并不好用,虽然平时没什么弹窗打扰我,但是一但出事一点都救不了我.<br>病急乱投医,我甚至下载了360来试试,果不其然,连安装页面都没弹出来,就已经在修改我的注册表了,去你的吧!</p><p>然后看了看别人的推荐,又综合了各种考虑,先拿卡巴斯基来试试全盘扫描,竟然要花9个小时多.</p><p><strong>26号更新</strong><br>今天早上来看,发现问题并没有那么严重,大多数都是火绒的误报,我把那些隔离区里的exe上传到<a href="https://internxt.com/virus-scanner">文件病毒检测网站</a>里发现根本没有病毒,受不了了.而卡巴斯基也成功地把那些真正的病毒删除干净了,滚吧您呐,让我投入卡巴斯基的怀抱吧!</p><h3 id="参考链接">参考链接</h3><p><a href="https://iliu.org/thoughts-on-struggling-with-antivirus-software/">1</a><br><a href="https://meledee.com/2025/03/4617.html">2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下了一个破解版游戏,结果火绒直接弹出窗口提示我有三百多个exe感染了jadtre ax 病毒&lt;br&gt;
&lt;img src=&quot;/images/archives/2025/2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/PixPin</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-24 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-24T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/">来源</a><br>我是一个习惯于早做规划与反复思索的人。<br>而坚持写博客最大的好处就是，可以时不时翻看之前写的文章，宛若跨越时间的荆棘，与曾经的自己促膝长谈。</p></blockquote><blockquote><p>现在想来，十九岁时，我的迷惘归结下来，即是对将来自己的出路无所适从：出国留学，国内升学，抑或是早日进入职场。这几条路上，都有前人留下的无数足迹与丰碑，但也无可避免地悬着前人用泪水濯洗的种种失败警示牌。我曾尝试从中选出最优解，然而反复的纠结过后，我所意识到的，是这种比较的注定无结果：每当我觉得某个选择优于其他选择时，总会有某些信息刷新我的认知，让我匆忙撤回自己的决定。一如盲人同时摸象与鲸鱼，用片面的认知去比较复杂的事物，注定失败。</p></blockquote><blockquote><p>先是出国。关于这个选项，我曾仔细考虑，然而最终出于经济上的原因（赴美读硕开销实在过于昂贵）和人生规划的原因（<strong>我对学术无甚兴趣，不愿耗费多年去追求博士学位</strong>），出国成为了三者中第一个被排除的选项。而站在当下（2020 年）来看，全球疫情的扩散与民族主义情绪的对立，出国虽然依旧有着不可抗拒的诱惑力（比如优渥的学术环境与工作环境），但是更显得充满了极度未知的不确定性。</p></blockquote><blockquote><p>「选择比努力更重要。」这句话近年来已经广为人知，不少人以此自我调侃，感叹自己当初选择的失误（比如选错学校、选错专业），但当下一次选择到来时，却又不假思索地下意识地站到了主流的人群中，甚至拼尽全力挤出一条道路以加入主流人群。</p><p>诚然，作为一个才识普通的人，我或许不具备选择最合适的道路的能力，但我所希望的，是不盲从、不追随，依靠自身的观察与思考，尽量选出一条相对合适的道路。<br>人类的悲欢并不相通，但是相似。</p><p>关于读研与工作，面临同样困扰的也并非只有我一个人。</p><p>在做出决定的过程中，我阅读了不少人的博客与帖子，从中获得了一些宝贵的信息与经验，或多或少地影响了我最终的决定。</p><p>由于之前并未刻意保存浏览过的网页，在此，仅仅列出其中的一小部分：</p></blockquote><ul><li><a href="https://laike9m.com/blog/suo-yi-dao-di-yao-bu-yao-du-yan,119/">所以，到底要不要读研？ - laike9m’s blog</a></li><li><a href="http://gaocegege.com/Blog/%E9%9A%8F%E7%AC%94/master">研究生复盘 | 高策</a></li><li><a href="https://ipotato.me/article/65">iPotato | 在读研 &amp; 工作中选择后者</a></li><li><a href="https://www.v2ex.com/t/580275">已有名校 CS 本科学历，读研对于计算机行业的职业发展有多大的意义？ - V2EX</a></li></ul><p>这恰恰是我当下迷惘而又感到无路可走的心境,专业课程的枯燥与无用让我感到厌烦,愈加激烈的保研争夺战让我望而却步,而那些学术论文里面的水分都可以让海平面再升高一米了.</p><p>可日愈恶化的工作环境阻断了我得过且过的想法,作为雏鸟在第一家公司所学习的架构未必对我的技术提升有任何的助益,而我的学历劣势也将在很长一段时间内保持下去.</p><p>这种左右为难的状况让我一边痛苦一边踟蹰,只好到处翻阅博客,搜寻资源,希望能够对当前的我有些微的救赎.</p><p>这篇博客可惜的地方在于没有考虑到提前工作的坏处,但看了看他<a href="https://www.zackwu.com/posts/2025-11-26-think-long-term-and-work-hard/">最近的文章</a>,过得还算不错,可我现在还没有那个胆量去直接放弃保研,因为我讨厌唯一的选择,希望能多几条路可以走,而现在我仅仅是在本专业保研排名的边缘上(笑).这解释为是对我自己负责,但更可能只是我胆小罢了.</p><h2 id="题外话">题外话:</h2><p>博客是我最喜欢的信息传播方式,我永远都可以在某个博客里找到一些用一般手段怎么搜都搜不到的棘手问题的解决方案,永远都可以找到一个处境和你相似的人,永远都可以找到能够为你指引道路的人.</p><p>这半年来我搜集了差不多一百多个博客,我打算之后整理一下把里面的精华部分传到GitHub上,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/&quot;&gt;来源&lt;/a&gt;&lt;br&gt;
我是一个习惯于早做规划与反复思索的人。&lt;br&gt;
</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-21 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/21/archives-2025-2025-12-21-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/21/archives-2025-2025-12-21-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-21T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li></li></ol></blockquote><p><a href="https://ruanyf-weekly.vercel.app/weekly/issue-210">周刊210期</a><br>诺拉·劳森还说了一个观点。大家通常认为，复杂系统往往会在经济繁荣的时候崩溃，因为业务太多，支撑不过来，但他认为不是这样的，系统崩溃往往发生在经济收缩期。<br>经济繁荣时期，软件公司会大量雇佣新员工，投入更多的财力和人力，支撑复杂系统。等到经济收缩期，公司开始减少投入、冻结招聘或裁员，复杂系统可能就会在这个时候出问题，变得难以维护。<br>现在就是经济收缩期，那么接下来，会不会就是软件故障的高发期，我们将看到很多复杂系统的崩溃？</p><blockquote><ol start="2"><li></li></ol></blockquote><p>IT 行业与传统制造业有一个重要区别，就是 IT 行业有着严重的垄断。<br>全世界的智能手机有70亿部，比汽车多出5倍（14亿辆）。但是，智能手机制造商比汽车制造商少了好几个数量级。搜索引擎、社交网络、操作系统都是这样，几个巨头就垄断了整个市场。</p><blockquote><p>3.<a href="https://blog.amamiyayuuko.com/p/ai-new-bing/">来源</a><br>各个互联网公司都试图把自己的网站做成一个完全封闭的APP，你没法在搜索引擎上搜索到微信公众号的文章、小红书的内容、淘宝的商品描述……这就导致bing只能从非常有限的地方获得中文语料，最后就导致他的回答特别池沼……而且比别的AI都池沼十倍甚至九倍……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ruanyf-weekly.vercel.app/weekly/issue-210&quot;&gt;周刊210期&lt;/a&gt;&lt;br&gt;
诺拉·劳森还说了一个观点。大</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>重要文章存档</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-20T02:58:05.000Z</published>
    <updated>2026-01-01T10:11:09.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cpp构造与析构"><a href="https://blog.csdn.net/2501_91275995/article/details/156042381">cpp构造与析构</a></h2><h2 id="校招流程"><a href="https://www.zackwu.com/posts/2020-10-05-an-incomplete-guide-to-campus-recruitment-interviews/">校招流程</a></h2><h2 id="还是校招"><a href="https://blog.cugxuan.cn/2021/01/06/Campus/guide-capmus-v2/">还是校招</a></h2><h2 id="微软实习"><a href="https://ddadaal.me/articles/2019-spring-ms-intern-interview-experiences">微软实习</a></h2><h2 id="cpp书单"><a href="https://csguide.cn/books/cpp.html">cpp书单</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cpp构造与析构&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/2501_91275995/article/details/156042381&quot;&gt;cpp构造与析构&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;校招流程&quot;&gt;&lt;a href=&quot;https://w</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-20 数据结构重点例题分析</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/archives-2025-2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/archives-2025-2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/</id>
    <published>2025-12-20T00:00:00.000Z</published>
    <updated>2026-01-06T09:59:37.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="稀疏矩阵的三元组表">稀疏矩阵的三元组表</h2><p>三元组表需要把行,列,值分别列出来(意义在哪里?)<br><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image.webp" alt=""></p><p>甚至还要再写辅助数组rowSize和rowStart,把很明显的东西再写一遍,却又不考算法,没招了.</p><h2 id="链表反转">链表反转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    LNode* q;</span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;   <span class="comment">// 断开头结点与原链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;      <span class="comment">// 保存后继</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;      <span class="comment">// 头插</span></span><br><span class="line">        p = q;            <span class="comment">// 处理下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴下代码就能看懂了,其实我觉得就是两端交换</p><h2 id="KMP">KMP</h2><p><a href="https://www.cnblogs.com/Higurashi-kagome/p/18013626">参考1</a><br><a href="https://www.xdull.cn/kmp.html">参考2</a><br>都讲的挺好.</p><p>重点是明确next数组的作用,之所以存储模式的对应字串最长公共前后缀,是因为当匹配失败时,原字符串中在匹配失败位置前的成功匹配部分刚好可以作为重置后的模式字符串的前缀,它同时也是先前匹配时得到对应长度模式字串的后缀.搞懂了这个就能彻底理解kmp了.</p><blockquote><p>例题: 设主串T=”abaabaabcabaabc”，模式串P=”abaabc”，采用KMP算法进行模式匹配，到匹配成功为止，在匹配过程中进行的单个字符间的比较次数是（ ）.</p></blockquote><blockquote><p>解题: int num=0,<br>先写出next数组[0,0,1,1,2,0],第一次匹配到abaab,num+=5,但由于失败的匹配也要算上,num+=1<br>指针移到后缀ab,接着比较找到abaabc,num+=4,故num=10</p></blockquote><h2 id="组合数求解">组合数求解</h2><blockquote><p>【例4】编写一个递归算法，找出从自<br>然数1,2,3,4,…,n中任取r个数的所有组<br>合。例如，n=5，r=3时的组合是543，<br>542，541，532，531，521，432，431<br>，421，321.</p><p>【解答】本问题就是求解组合数。<br>int Combin(int m, int n)<br>{ if(m==n||n==0) return 1;<br>else return Combin(m-1,n)+<br>Combin(m-1,n-1);}</p></blockquote><p>一开始是用dfs写的,但没想到ppt里根本没考虑把组合写出来,不过这个递归也挺难想到的.</p><h2 id="广义表">广义表</h2><blockquote><p>假设广义表是由带头节点的链<br>表存储，请画出广义表A(a, B((),<br>C(1)))的存储结构；假设head，tail分<br>别是求首元素操作和求尾表操作，求<br>如何获得元素1.</p></blockquote><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image2.webp" alt="解答"><br>其中,一个结点的定义如下:</p><blockquote><p>utype = 0/1/2/3 ;<br>value = ref /intgrinfo /charinfo / hlink ;tlink</p></blockquote><p>0表示该节点为头节点,1表示为整数,2表示为char,3表示为子表节点,∧表示该节点为尾节点,指向该子表头节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GenList :: <span class="built_in">depth</span> ( GenListNode *ls ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ls→tlink == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//空表</span></span><br><span class="line">GenListNode *temp = ls→tlink;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( temp != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> <span class="comment">//横扫广义表</span></span><br><span class="line"><span class="keyword">if</span> ( temp→utype == LST ) &#123;</span><br><span class="line"> <span class="comment">//子表深度</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">depth</span> ( temp→value.hlink );</span><br><span class="line"><span class="keyword">if</span> ( m &lt; n ) m = n;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//不是子表不加深度</span></span><br><span class="line">temp = temp→tlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉链的应用">二叉链的应用</h2><blockquote><p>假设二叉树采用二叉链存储，设计一个算法Level()求二叉树中值为 x 的节点的层数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Level</span><span class="params">(BiNode *T, <span class="type">int</span> x, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) <span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">Level</span>(T-&gt;lchild, x, level + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (l) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Level</span>(T-&gt;rchild, x, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树与森林典型例题">二叉树与森林典型例题</h2><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-34-19.webp" alt="题目"></p><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-35-26.webp" alt="解答"></p><h2 id="静态搜索表的应用">静态搜索表的应用</h2><h3 id="顺序搜索">顺序搜索</h3><p><img src="/images/archives/2025/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-12-10.webp%3E" alt="不能写个循环吗急死我了"><br>还装模做样加一个概念ASL(Average Search Length)<br><img src="/images/archives/2025/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-13-47.webp%3E" alt=""><br><img src="/images/archives/2025/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-25_10-52-23.webp%3E" alt="公式"></p><h3 id="折半搜索">折半搜索</h3><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-27_12-34-38.webp" alt="代码"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;稀疏矩阵的三元组表&quot;&gt;稀疏矩阵的三元组表&lt;/h2&gt;
&lt;p&gt;三元组表需要把行,列,值分别列出来(意义在哪里?)&lt;br&gt;
&lt;img src=&quot;/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>我遇到的各种调试问题</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-19T01:58:56.000Z</published>
    <updated>2026-01-19T04:52:05.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode-powershell终端打字缺字漏字"><a class="markdownIt-Anchor" href="#vscode-powershell终端打字缺字漏字"></a> vscode powershell终端打字缺字漏字</h2><p>解决方法:</p><blockquote><p>搜索设置<br />Terminal &gt; Integrated &gt; Default Profile: Windows<br />换为cmd</p></blockquote><h2 id="左斜线和右斜线问题"><a class="markdownIt-Anchor" href="#左斜线和右斜线问题"></a> 左斜线和右斜线问题</h2><p>windows路径都是,转义符是,而网页链接,linux都是/<br />解决方法:</p><blockquote><p>在搜索框输入：“Explorer: Copy Relative Path Separator”<br />将\改为正斜杠/<br /><a href="https://blog.csdn.net/kdz6511/article/details/148712726">参考链接</a></p></blockquote><h2 id="gpt废话太多"><a class="markdownIt-Anchor" href="#gpt废话太多"></a> gpt废话太多</h2><p>解决方法</p><blockquote><p>在设置里可以加入自定义提示词,这样就不用每次都提示让他精简输出了</p></blockquote><h2 id="cmd输入python弹出微软应用商店"><a class="markdownIt-Anchor" href="#cmd输入python弹出微软应用商店"></a> cmd输入python弹出微软应用商店</h2><p>解决方法</p><blockquote><p>进入设置里的应用执行别名,去掉跟python有关的别名(很好奇为什么要把这玩意加进来)</p></blockquote><h2 id="path环境变量变成一行"><a class="markdownIt-Anchor" href="#path环境变量变成一行"></a> path环境变量变成一行</h2><p>解决方法</p><blockquote><p>由于Windows的无敌bug,第一个如果是带有%开头的变量会把path变成一行,把带有盘符的变量放到第一行即可</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vscode-powershell终端打字缺字漏字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vscode-powershell终端打字缺字漏字&quot;&gt;&lt;/a&gt; vscode powershell终端打字缺字漏字&lt;/h2&gt;
&lt;p&gt;解决方</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
</feed>

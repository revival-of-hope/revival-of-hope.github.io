<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当时只道是寻常</title>
  
  
  <link href="https://revival-of-hope.github.io/rss.xml" rel="self"/>
  
  <link href="https://revival-of-hope.github.io/"/>
  <updated>2025-12-27T04:29:44.033Z</updated>
  <id>https://revival-of-hope.github.io/</id>
  
  <author>
    <name>Revival-of-hope</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025-12-27 各种grammar集合</title>
    <link href="https://revival-of-hope.github.io/2025/12/27/dynamic-2025-12-27-grammar/"/>
    <id>https://revival-of-hope.github.io/2025/12/27/dynamic-2025-12-27-grammar/</id>
    <published>2025-12-27T00:00:00.000Z</published>
    <updated>2025-12-27T04:29:44.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><p>windows端先设置代理端口</p><figure class="highlight plaintext"><figcaption><span>http_proxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>git init &#x2F;&#x2F;初始化git,只运行一次<br>git add . &#x2F;&#x2F;所有文件加入本地git<br>git commit -m “first commit” &#x2F;&#x2F;提交到本地<br>git branch -M main &#x2F;&#x2F;设置提交分支为main,之后可以不必运行<br>git remote add origin <a href="https://github.com/revival-of-hope/Clash_of_Clans.git">https://github.com/revival-of-hope/Clash_of_Clans.git</a> &#x2F;&#x2F;关联选定仓库并在本地设置标签为origin,只要运行一次<br>git push -u origin main &#x2F;&#x2F;-u(upstream)设置上游分支为origin的main分支,以后默认提交到origin仓库的main分支,以后只写git push就行</p><p>之后再修改只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">#可加上origin main关键字,但由于已经设置默认上游,故可以省略</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;描述修改&quot;</span> <span class="comment">#不加引号也可以</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>即可</p><h2 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">##</span><br><span class="line">###</span><br><span class="line">####</span><br></pre></td></tr></table></figure><p>均为标题</p><p><a href=""></a> 插入链接和说明<br><img src="/"> 插入图片</p><p><code>代码类型</code> 插入代码块<br><code>代码</code> 行内代码<br><em>斜体</em><br><strong>粗体</strong><br><del>删除线</del><br>&#x3D;&#x3D;高亮&#x3D;&#x3D;</p><ul><li>项目</li></ul><ul><li>项目</li></ul><ul><li>项目</li></ul><p>三种方式均可以表示列表</p><ul><li><input disabled="" type="checkbox"> 未完成</li><li><input checked="" disabled="" type="checkbox"> 已完成</li></ul><ol><li>项目</li><li>项目</li><li>项目</li></ol><blockquote><p>引用内容</p><blockquote><p>嵌套引用</p></blockquote></blockquote><hr><hr><hr><p>三种方式均可以表示分割线</p><table><thead><tr><th>列1</th><th>列2</th><th>列3</th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td></tr></tbody></table><p>表格</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git命令&quot;&gt;&lt;a href=&quot;#git命令&quot; class=&quot;headerlink&quot; title=&quot;git命令&quot;&gt;&lt;/a&gt;git命令&lt;/h2&gt;&lt;p&gt;windows端先设置代理端口&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;f</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-26 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/26/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/26/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-26T00:00:00.000Z</published>
    <updated>2025-12-27T04:29:45.952Z</updated>
    
    <content type="html"><![CDATA[<p>这几天用<a href="https://rawweb.org/">rawweb</a>不知道看了多少博客,足够大的体量保证了我搜任何一个关键词基本都能找到答案,每一个博客对我来说都是一个全新的领域,仿佛博主的生活就是我的生活,他们的迷惘和彷徨就是我的迷惘和彷徨.就比如我搜索关键词保研,一下就得到了一千多条结果,里面的很多文章对我来说都是对读研和工作这一抉择的重新认识.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天用&lt;a href=&quot;https://rawweb.org/&quot;&gt;rawweb&lt;/a&gt;不知道看了多少博客,足够大的体量保证了我搜任何一个关键词基本都能找到答案,每一个博客对我来说都是一个全新的领域,仿佛博主的生活就是我的生活,他们的迷惘和彷徨就是我的迷惘和彷徨.就比如我搜</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25 离散数学整理-逻辑关系</title>
    <link href="https://revival-of-hope.github.io/2025/12/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/</id>
    <published>2025-12-25T00:00:00.000Z</published>
    <updated>2025-12-27T06:54:03.892Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据离散数学简明教程整理,仅为一本一百多页的薄书,但涵盖了大部分概念.</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="用一个例子搞懂集合运算"><a href="#用一个例子搞懂集合运算" class="headerlink" title="用一个例子搞懂集合运算"></a>用一个例子搞懂集合运算</h2><p><img src="/images/archives/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-25_21-34-39.webp"><br><img src="/images/archives/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-25_21-37-39.webp" alt="重要的德摩根律"></p><h2 id="对称差运算"><a href="#对称差运算" class="headerlink" title="对称差运算"></a>对称差运算</h2><p>对称差运算满足结合律,交换律,分配律<br>其中分配律最难理解,但在网上甚至找不到什么人解释<br><img src="/../images/archives/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-41-15.webp" alt="公式"></p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p><img src="/../images/archives/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-49-58.webp" alt="定义"></p><p><img src="/images/archives/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-53-32.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文根据离散数学简明教程整理,仅为一本一百多页的薄书,但涵盖了大部分概念.&lt;/p&gt;
&lt;h1 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h1&gt;&lt;h2 id=&quot;用一个例子搞懂集合运算&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25 cocos模块学习</title>
    <link href="https://revival-of-hope.github.io/2025/12/25/archives-2025-12-25-cocos%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/25/archives-2025-12-25-cocos%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-12-25T00:00:00.000Z</published>
    <updated>2025-12-27T04:30:22.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cocos命令"><a href="#cocos命令" class="headerlink" title="cocos命令"></a>cocos命令</h2><p><code>cocos new &lt;项目名&gt;  -l cpp</code><br> 当前目录下生成<br><code>cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143</code><br>在新项目里强制改cmake方式,其中-s指定cmakelists目录,-b指定build生成文件夹名字,-g指定编译器</p><p>新增加文件时,在cmake里面加入对应的文件路径<br>再运行<code>cmake ..</code>就行了<br>resource目录下的文件默认会全部添加,不用改cmakelists,而cpp和头文件需要手动添加,或者换成默认全部添加的代码<br>之后在build文件夹运行cmake ..后即可<br>单纯修改文件时会同步修改,不用担心</p><p><code>cmake -S . -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143</code></p><h2 id="概念部分"><a href="#概念部分" class="headerlink" title="概念部分"></a>概念部分</h2><p>精灵:可以理解为人物和物品,是可操作的对象<br>label: 可以理解为字幕,大到开始界面标题,小到物品资源名字,都能用</p><h2 id="初始化部分"><a href="#初始化部分" class="headerlink" title="初始化部分"></a>初始化部分</h2><p>写好场景的h文件和cpp文件后,在AppDelegate.cpp里使用并运行</p><h3 id="加载场景"><a href="#加载场景" class="headerlink" title="加载场景"></a>加载场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myScene = Scene::<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//runWithScene() 用于开始游戏，加载第一个场景。只用于第一个场景！</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">runWithScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//replaceScene() 使用传入的场景替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">replaceScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pushScene() 将当前运行中的场景暂停并压入到场景栈中，再将传入的场景设置为当前运行场景。只有存在正在运行的场景时才能调用该方法。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">pushScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//popScene() 释放当前场景，再从场景栈中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">popScene</span>();</span><br></pre></td></tr></table></figure><h2 id="窗口部分"><a href="#窗口部分" class="headerlink" title="窗口部分"></a>窗口部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> visibleSize = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleSize</span>();</span><br><span class="line">    <span class="comment">//窗口对角线向量,这个向量可以调用visibleSize.width</span></span><br><span class="line">    <span class="comment">//和visibleSize.height两个子属性</span></span><br><span class="line">    <span class="keyword">auto</span> origin = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleOrigin</span>();</span><br><span class="line">    <span class="comment">//左下角坐标(0,0)</span></span><br></pre></td></tr></table></figure><p>在AppDelegate.cpp下有一行<br><code>glview = GLViewImpl::createWithRect(&quot;test&quot;, cocos2d::Rect(0, 0, designResolutionSize.width, designResolutionSize.height));</code><br>修改designResolutionSize为其他大小(如largeResolutionSize)即可修改窗口默认大小</p><h2 id="创建部分"><a href="#创建部分" class="headerlink" title="创建部分"></a>创建部分</h2><h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><p><strong>所有创建的精灵和场景,动作都会自动销毁</strong><br><em>创建精灵</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> child = Sprite::<span class="built_in">create</span>(<span class="string">&quot;Images/test.png&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> mySprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;mysprite.png&quot;</span>, <span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>));</span><br><span class="line"><span class="comment">//可以指定裁剪区域,(0,0)为左上角坐标,大小为200X200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多边形精灵.</span></span><br><span class="line"><span class="keyword">auto</span> pinfo = AutoPolygon::<span class="built_in">generatePolygon</span>(<span class="string">&quot;filename.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sprite with polygon info.</span></span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::<span class="built_in">create</span>(pinfo);</span><br></pre></td></tr></table></figure><p><a href="https://docs.cocos.com/cocos2d-x/manual/zh/sprites/spritesheets.html">还可以使用图集来创建</a></p><p><em>创建label</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> label = Label::<span class="built_in">createWithTTF</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, <span class="number">16.0f</span>);</span><br><span class="line"><span class="keyword">auto</span> label = Label::<span class="built_in">create</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, <span class="number">16.0f</span>);</span><br><span class="line"><span class="comment">//两种方法均可以,下面一种在字体不能正常加载时使用系统字体,那我肯定用下面一种啊</span></span><br></pre></td></tr></table></figure><p><em>创建menu</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最复杂的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建一个image对象</span></span><br><span class="line"><span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(</span><br><span class="line">                                        <span class="string">&quot;CloseNormal.png&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">                                        <span class="built_in">CC_CALLBACK_1</span>(HelloWorld::menuCloseCallback,<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//可以用回调函数,但用lamda表达式更像人类一点,官方例子如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 lambda 表达式作为菜单项的回调函数：</span></span><br><span class="line"><span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(<span class="string">&quot;CloseNormal.png&quot;</span>, <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">[&amp;](Ref* sender)&#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是看不懂的话有以下例子</span></span><br><span class="line"><span class="keyword">auto</span> showPlayerDlgItem = MenuItemImage::<span class="built_in">create</span>(<span class="string">&quot;Images/Pea.png&quot;</span>,</span><br><span class="line">                                               <span class="string">&quot;Images/Pea.png&quot;</span>,</span><br><span class="line">                                               [<span class="keyword">this</span>](Ref* sender)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_playerDlg-&gt;<span class="built_in">setVisible</span>(!<span class="keyword">this</span>-&gt;_playerDlg-&gt;<span class="built_in">isVisible</span>());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//简单说来就是点击这个菜单图片会发生什么</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在用图像来创建菜单</span></span><br><span class="line"><span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem,closeItem2,closeItem3, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//可以一直叠下去</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指定元素位置-菜单-UI组件通用"><a href="#指定元素位置-菜单-UI组件通用" class="headerlink" title="指定元素位置(菜单,UI组件通用)"></a>指定元素位置(菜单,UI组件通用)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(origin.x,origin.y));</span><br><span class="line">child-&gt;<span class="built_in">setPosition</span>(<span class="built_in">vec2</span>(visibleSize/<span class="number">2</span>));</span><br><span class="line"><span class="comment">//两种方法都可以</span></span><br></pre></td></tr></table></figure><p><strong>改变精灵的中心点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DEFAULT anchor point for all Sprites</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom left</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// top left</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom right</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// top right</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="将元素加入指定图层-通用"><a href="#将元素加入指定图层-通用" class="headerlink" title="将元素加入指定图层(通用)"></a>将元素加入指定图层(通用)</h3><p><code>this-&gt;addChild(child, 1,people);</code></p><blockquote><p>原定义部分<br>void Node::addChild(Node *child, int localZOrder, int tag)</p></blockquote><p>即第一个参数是元素名称,第二个参数是指定图层坐标,第三个参数是标签,<br>后两个均为可选</p><h2 id="动作部分"><a href="#动作部分" class="headerlink" title="动作部分"></a>动作部分</h2><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>通过 setRotation() 方法，设置一个角度值可以控制精灵的旋转，正值精灵顺时针旋转，负值精灵逆时针旋转，默认位置的角度值是 0.0。<br><code>mySprite-&gt;setRotation(20.0f);</code></p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// increases X and Y size by 2.0 uniformly</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScale</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increases just X scale by 2.0</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScaleX</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increases just Y scale by 2.0</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScaleY</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p><strong>动作中的缩放方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scale uniformly by 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleBy = ScaleBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleBy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale X by 2 and Y by 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleBy = ScaleBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleBy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale to uniformly to 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleTo = ScaleTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale X to 2 and Y to 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleTo = ScaleTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleTo);</span><br></pre></td></tr></table></figure><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move sprite to position 50,10 in 2 seconds.</span></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">50</span>, <span class="number">10</span>));</span><br><span class="line">mySprite1-&gt;<span class="built_in">runAction</span>(moveTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move sprite 20 points to right in 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">20</span>,<span class="number">0</span>));</span><br><span class="line">mySprite2-&gt;<span class="built_in">runAction</span>(moveBy);</span><br></pre></td></tr></table></figure><p>注意到每个动作都要先创建为对象再用runAction执行</p><p><strong>可以创建一个移动序列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">500</span>, mySprite-&gt;<span class="built_in">getPositionY</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// MoveTo - lets move the new sprite to 300 x 256 over 2 seconds</span></span><br><span class="line"><span class="comment">// MoveTo is absolute - The sprite gets moved to 300 x 256 regardless of</span></span><br><span class="line"><span class="comment">// where it is located now.</span></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">300</span>, mySprite-&gt;<span class="built_in">getPositionY</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delay - create a small delay</span></span><br><span class="line"><span class="keyword">auto</span> delay = DelayTime::<span class="built_in">create</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> seq = Sequence::<span class="built_in">create</span>(moveBy, delay, moveTo, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(seq);</span><br></pre></td></tr></table></figure><p>注意到cocos里面用到数组对象时总要指定最后一位为空指针</p><p>查看源码发现runAction指接收一个参数,也就是说延迟动作只能显示写一个delay对象实现</p><h3 id="色彩混合"><a href="#色彩混合" class="headerlink" title="色彩混合"></a>色彩混合</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;mysprite.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tints a node to the specified RGB values</span></span><br><span class="line"><span class="keyword">auto</span> tintTo = TintTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">120.0f</span>, <span class="number">232.0f</span>, <span class="number">254.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(tintTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tints a node BY the delta of the specified RGB values.</span></span><br><span class="line"><span class="keyword">auto</span> tintBy = TintBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">120.0f</span>, <span class="number">232.0f</span>, <span class="number">254.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(tintBy);</span><br></pre></td></tr></table></figure><p>可用于实现药水对兵种的作用效果</p><h2 id="瓦片地图"><a href="#瓦片地图" class="headerlink" title="瓦片地图"></a>瓦片地图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建地图</span></span><br><span class="line">map=TMXTiledMap::<span class="built_in">create</span>(<span class="string">&quot;test.tmx&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//瓦片处理</span></span><br><span class="line">Size tileSize = map-&gt;<span class="built_in">getTileSize</span>();        <span class="comment">// 单个瓦片像素大小（如 64x64）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放地图</span></span><br><span class="line"><span class="comment">// Step 1: 计算横竖各能放多少个完整瓦片（向下取整）</span></span><br><span class="line"><span class="type">int</span> maxTilesX = (<span class="type">int</span>)(visibleSize.width / tileSize.width);</span><br><span class="line"><span class="type">int</span> maxTilesY = (<span class="type">int</span>)(visibleSize.height / tileSize.height);</span><br><span class="line"><span class="comment">//注意到这里的visiblesize根据需要选择获取全屏还是裁剪掉菜单栏的区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止除零或瓦片太大的情况</span></span><br><span class="line"><span class="keyword">if</span> (maxTilesX &lt;= <span class="number">0</span>) maxTilesX = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (maxTilesY &lt;= <span class="number">0</span>) maxTilesY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 计算两种缩放比例</span></span><br><span class="line"><span class="type">float</span> scaleIfFitWidth = visibleSize.width / (maxTilesX * tileSize.width);</span><br><span class="line"><span class="type">float</span> scaleIfFitHeight = visibleSize.height / (maxTilesY * tileSize.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 选择「宁可裁掉一点地图，也绝不留黑边」的策略 → 取较大值</span></span><br><span class="line"><span class="type">float</span> finalScale = std::<span class="built_in">max</span>(scaleIfFitWidth, scaleIfFitHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 应用缩放 + 严格左上角对齐 + 防1像素缝隙</span></span><br><span class="line">map-&gt;<span class="built_in">setScale</span>(finalScale);</span><br><span class="line">map-&gt;<span class="built_in">setAnchorPoint</span>(<span class="built_in">Vec2</span>(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">// 左上角为锚点</span></span><br><span class="line">map-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(<span class="number">-0.5f</span>, visibleSize.height + <span class="number">0.5f</span>));   </span><br></pre></td></tr></table></figure><p>尽管写了这么多,但最后我还是用AI完成绝大部分代码的,AI的文献阅读能力让期末周的我泪流满面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cocos命令&quot;&gt;&lt;a href=&quot;#cocos命令&quot; class=&quot;headerlink&quot; title=&quot;cocos命令&quot;&gt;&lt;/a&gt;cocos命令&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cocos new &amp;lt;项目名&amp;gt;  -l cpp&lt;/code&gt;&lt;br&gt; 当前目</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-24 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/24/archives-2025-12-24-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/24/archives-2025-12-24-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-24T00:00:00.000Z</published>
    <updated>2025-12-27T05:55:32.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/">来源</a><br>我是一个习惯于早做规划与反复思索的人。<br>而坚持写博客最大的好处就是，可以时不时翻看之前写的文章，宛若跨越时间的荆棘，与曾经的自己促膝长谈。</p></blockquote><blockquote><p>现在想来，十九岁时，我的迷惘归结下来，即是对将来自己的出路无所适从：出国留学，国内升学，抑或是早日进入职场。这几条路上，都有前人留下的无数足迹与丰碑，但也无可避免地悬着前人用泪水濯洗的种种失败警示牌。我曾尝试从中选出最优解，然而反复的纠结过后，我所意识到的，是这种比较的注定无结果：每当我觉得某个选择优于其他选择时，总会有某些信息刷新我的认知，让我匆忙撤回自己的决定。一如盲人同时摸象与鲸鱼，用片面的认知去比较复杂的事物，注定失败。</p></blockquote><blockquote><p>先是出国。关于这个选项，我曾仔细考虑，然而最终出于经济上的原因（赴美读硕开销实在过于昂贵）和人生规划的原因（<strong>我对学术无甚兴趣，不愿耗费多年去追求博士学位</strong>），出国成为了三者中第一个被排除的选项。而站在当下（2020 年）来看，全球疫情的扩散与民族主义情绪的对立，出国虽然依旧有着不可抗拒的诱惑力（比如优渥的学术环境与工作环境），但是更显得充满了极度未知的不确定性。</p></blockquote><blockquote><p>「选择比努力更重要。」这句话近年来已经广为人知，不少人以此自我调侃，感叹自己当初选择的失误（比如选错学校、选错专业），但当下一次选择到来时，却又不假思索地下意识地站到了主流的人群中，甚至拼尽全力挤出一条道路以加入主流人群。</p><p>诚然，作为一个才识普通的人，我或许不具备选择最合适的道路的能力，但我所希望的，是不盲从、不追随，依靠自身的观察与思考，尽量选出一条相对合适的道路。<br>人类的悲欢并不相通，但是相似。</p><p>关于读研与工作，面临同样困扰的也并非只有我一个人。</p><p>在做出决定的过程中，我阅读了不少人的博客与帖子，从中获得了一些宝贵的信息与经验，或多或少地影响了我最终的决定。</p><p>由于之前并未刻意保存浏览过的网页，在此，仅仅列出其中的一小部分：</p></blockquote><ul><li><a href="https://laike9m.com/blog/suo-yi-dao-di-yao-bu-yao-du-yan,119/">所以，到底要不要读研？ - laike9m’s blog</a></li><li><a href="http://gaocegege.com/Blog/%E9%9A%8F%E7%AC%94/master">研究生复盘 | 高策</a></li><li><a href="https://ipotato.me/article/65">iPotato | 在读研 &amp; 工作中选择后者</a></li><li><a href="https://www.v2ex.com/t/580275">已有名校 CS 本科学历，读研对于计算机行业的职业发展有多大的意义？ - V2EX</a></li></ul><p>这恰恰是我当下迷惘而又感到无路可走的心境,专业课程的枯燥与无用让我感到厌烦,愈加激烈的保研争夺战让我望而却步,而那些学术论文里面的水分都可以让海平面再升高一米了.</p><p>可日愈恶化的工作环境阻断了我得过且过的想法,作为雏鸟在第一家公司所学习的架构未必对我的技术提升有任何的助益,而我的学历劣势也将在很长一段时间内保持下去.</p><p>这种左右为难的状况让我一边痛苦一边踟蹰,只好到处翻阅博客,搜寻资源,希望能够对当前的我有些微的救赎.</p><p>这篇博客可惜的地方在于没有考虑到提前工作的坏处,但看了看他<a href="https://www.zackwu.com/posts/2025-11-26-think-long-term-and-work-hard/">最近的文章</a>,过得还算不错,可我现在还没有那个胆量去直接放弃保研,因为我讨厌唯一的选择,希望能多几条路可以走,而现在我仅仅是在本专业保研排名的边缘上(笑).这解释为是对我自己负责,但更可能只是我胆小罢了.</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话:"></a>题外话:</h2><p>博客是我最喜欢的信息传播方式,我永远都可以在某个博客里找到一些用一般手段怎么搜都搜不到的棘手问题的解决方案,永远都可以找到一个处境和你相似的人,永远都可以找到能够为你指引道路的人.</p><p>这半年来我搜集了差不多一百多个博客,我打算之后整理一下把里面的精华部分传到GitHub上,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/&quot;&gt;来源&lt;/a&gt;&lt;br&gt;我是一个习惯于早做规划与反复思索的人。&lt;br&gt;而坚</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-24 病毒攻击</title>
    <link href="https://revival-of-hope.github.io/2025/12/24/archives-2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/24/archives-2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/</id>
    <published>2025-12-24T00:00:00.000Z</published>
    <updated>2025-12-26T02:21:58.578Z</updated>
    
    <content type="html"><![CDATA[<p>下了一个破解版游戏,结果火绒直接弹出窗口提示我有三百多个exe感染了jadtre ax 病毒<br><img src="/images/archives/2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/PixPin_2025-12-24_09-58-14.webp"></p><p>到这个时候我才发现我对网络安全实际上是一窍不通,<br>只好先用火绒把所有感染的exe放到隔离区,然后来了一个全盘扫描,我以后一定要好好研究一下计算机的底层知识和病毒攻击原理.</p><p>首先我找到了<a href="https://www.virusview.net/malware/Virus/Win32/Jadtre">计算机病毒百科</a>里关于这个病毒的详细信息</p><blockquote><p>它会修改系统文件，包括操作系统的关键文件，以隐藏自身并且避免被杀软检测到。<br>该病毒会通过劫持用户的浏览器、修改主页和搜索引擎设置等方式，进行钓鱼攻击，诱导用户点击恶意链接，从而进一步传播病毒。<br>它会窃取用户的个人敏感信息，如登录密码、银行账号等，并将这些信息发送到黑客的服务器上。<br>病毒会利用系统的漏洞，进行远程控制，从而盗取用户的隐私信息或者操控计算机进行其他恶意行为。<br>该病毒还会利用系统资源进行挖矿或者进行分布式拒绝服务（DDoS）攻击。<br>它会禁用或损坏杀软程序的功能，以保证自身不被杀软识别和清除。</p></blockquote><p>发现它主要是诱导用户点击恶意链接,还好火绒直接帮我拦截了网页跳转.</p><p>顺藤摸瓜找到了这个<a href="https://www.antiycloud.com/#/antiy/safeinfor">网站</a>,我才发现网络安全确实是一个壁垒高却极为重要的领域,<br>想着在网上找一点入门教程,结果用中文搜全是AI文章或者垃圾文字,再一次体会到中文互联网的封闭性,只好问gpt,找到了以下网站:</p><blockquote><p>By Sunday evening, you could have taken your first real step into cybersecurity.<br>Here are 15 websites to kick-start your cybersecurity journey (all beginner-friendly):<br>    1.TryHackMe  – Hands-on labs for all skill levels<br><a href="https://tryhackme.com/">https://tryhackme.com</a><br>    2.Hack The Box  – Gamified hacking challenges<br><a href="https://www.hackthebox.com/">https://www.hackthebox.com</a><br>    3.Blue Team Labs Online  – Defensive security scenarios<br><a href="https://lnkd.in/dckAehnQ">https://lnkd.in/dckAehnQ</a><br>    4.OverTheWire – Fun war games to learn Linux &amp; networking<br><a href="https://lnkd.in/d66wAqDb">https://lnkd.in/d66wAqDb</a><br>    5.PortSwigger Web Security Academy – Web app hacking from the pros<br><a href="https://lnkd.in/dyrBGjRh">https://lnkd.in/dyrBGjRh</a><br>    6.VulnHub – Download vulnerable machines and hack away<br><a href="https://www.vulnhub.com/">https://www.vulnhub.com</a><br>    7.LetsDefend  – SOC analyst simulation<br><a href="https://letsdefend.io/">https://letsdefend.io</a><br>    8.CyberDefenders  – Threat hunting and forensics labs<br><a href="https://cyberdefenders.org/">https://cyberdefenders.org</a><br>    9.CTFtime – Find Capture the Flag competitions<br><a href="https://ctftime.org/">https://ctftime.org</a><br>    10.Security Blue Team  – Blue teaming certifications and practice<br><a href="https://lnkd.in/dmuUFfQX">https://lnkd.in/dmuUFfQX</a><br>    11.PentesterLab – Web security training<br><a href="https://pentesterlab.com/">https://pentesterlab.com</a><br>    12.MITRE ATT&amp;CK – Learn real adversary tactics and techniques<br><a href="https://attack.mitre.org/">https://attack.mitre.org</a><br>    13.OWASP – Secure coding &amp; app security resources<br><a href="https://owasp.org/">https://owasp.org</a><br>    14.DFIR Diva – Free digital forensics resources<br><a href="https://dfirdiva.com/">https://dfirdiva.com</a><br>    15.Flare-On Challenges – Reverse engineering practice<br><a href="https://flare-on.com/">https://flare-on.com</a></p></blockquote><blockquote><p><a href="https://github.com/404notf0und/Security-Data-Analysis-and-Visualization">找到了一个汇总链接</a><br>不多说了,尽管期末周快来了,兴趣学习的时间还是有的,开练.</p></blockquote><hr><p><strong>25号更新</strong><br>一开始我觉得这个病毒没什么危害性,就又把火绒隔离区里的exe给恢复了,现在发现我确实是智障,今晚扫描全盘发现基本所有的exe文件都被感染了,<br>里面有几百款游戏exe和工具exe,受不了了,太蠢了这也.我决定不再点击恢复文件,只能把这些文件全部删掉了.<br>好的,这下真的激发我对网络安全的兴趣了,做病毒真有这么好玩吗(😡)</p><p>这件事还让我看到火绒并不好用,虽然平时没什么弹窗打扰我,但是一但出事一点都救不了我.<br>病急乱投医,我甚至下载了360来试试,果不其然,连安装页面都没弹出来,就已经在修改我的注册表了,去你的吧!</p><p>然后看了看别人的推荐,又综合了各种考虑,先拿卡巴斯基来试试全盘扫描,竟然要花9个小时多.</p><p><strong>26号更新</strong><br>今天早上来看,发现问题并没有那么严重,大多数都是火绒的误报,我把那些隔离区里的exe上传到<a href="https://internxt.com/virus-scanner">文件病毒检测网站</a>里发现根本没有病毒,受不了了.而卡巴斯基也成功地把那些真正的病毒删除干净了,滚吧您呐,让我投入卡巴斯基的怀抱吧!</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://iliu.org/thoughts-on-struggling-with-antivirus-software/">1</a><br><a href="https://meledee.com/2025/03/4617.html">2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下了一个破解版游戏,结果火绒直接弹出窗口提示我有三百多个exe感染了jadtre ax 病毒&lt;br&gt;&lt;img src=&quot;/images/archives/2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/PixPin_2025-</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-21 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/21/archives-2025-12-21-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/21/archives-2025-12-21-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-21T00:00:00.000Z</published>
    <updated>2025-12-22T10:19:16.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li><a href="https://ruanyf-weekly.vercel.app/weekly/issue-210">周刊210期</a><br>诺拉·劳森还说了一个观点。大家通常认为，复杂系统往往会在经济繁荣的时候崩溃，因为业务太多，支撑不过来，但他认为不是这样的，系统崩溃往往发生在经济收缩期。<br>经济繁荣时期，软件公司会大量雇佣新员工，投入更多的财力和人力，支撑复杂系统。等到经济收缩期，公司开始减少投入、冻结招聘或裁员，复杂系统可能就会在这个时候出问题，变得难以维护。<br>现在就是经济收缩期，那么接下来，会不会就是软件故障的高发期，我们将看到很多复杂系统的崩溃？</li></ol></blockquote><blockquote><ol start="2"><li>IT 行业与传统制造业有一个重要区别，就是 IT 行业有着严重的垄断。<br>全世界的智能手机有70亿部，比汽车多出5倍（14亿辆）。但是，智能手机制造商比汽车制造商少了好几个数量级。搜索引擎、社交网络、操作系统都是这样，几个巨头就垄断了整个市场。</li></ol></blockquote><blockquote><p>3.<a href="https://blog.amamiyayuuko.com/p/ai-new-bing/">来源</a><br>各个互联网公司都试图把自己的网站做成一个完全封闭的APP，你没法在搜索引擎上搜索到微信公众号的文章、小红书的内容、淘宝的商品描述……这就导致bing只能从非常有限的地方获得中文语料，最后就导致他的回答特别池沼……而且比别的AI都池沼十倍甚至九倍……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://ruanyf-weekly.vercel.app/weekly/issue-210&quot;&gt;周刊210期&lt;/a&gt;&lt;br&gt;诺拉·劳森还说了一个观点。大家通常认为，复杂系统往往会在经济繁荣的时候崩溃，因为业务太多</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>重要文章存档</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-20T02:58:05.000Z</published>
    <updated>2025-12-25T11:19:01.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cpp构造与析构"><a href="#cpp构造与析构" class="headerlink" title="cpp构造与析构"></a><a href="https://blog.csdn.net/2501_91275995/article/details/156042381">cpp构造与析构</a></h2><h2 id="校招流程"><a href="#校招流程" class="headerlink" title="校招流程"></a><a href="https://www.zackwu.com/posts/2020-10-05-an-incomplete-guide-to-campus-recruitment-interviews/">校招流程</a></h2><h2 id="还是校招"><a href="#还是校招" class="headerlink" title="还是校招"></a><a href="https://blog.cugxuan.cn/2021/01/06/Campus/guide-capmus-v2/">还是校招</a></h2><h2 id="微软实习"><a href="#微软实习" class="headerlink" title="微软实习"></a><a href="https://ddadaal.me/articles/2019-spring-ms-intern-interview-experiences">微软实习</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cpp构造与析构&quot;&gt;&lt;a href=&quot;#cpp构造与析构&quot; class=&quot;headerlink&quot; title=&quot;cpp构造与析构&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/2501_91275995/article/details/1</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-20 数据结构重点例题分析</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/</id>
    <published>2025-12-20T00:00:00.000Z</published>
    <updated>2025-12-27T04:35:12.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="稀疏矩阵的三元组表"><a href="#稀疏矩阵的三元组表" class="headerlink" title="稀疏矩阵的三元组表"></a>稀疏矩阵的三元组表</h2><p>三元组表需要把行,列,值分别列出来(意义在哪里?)<br><img src="/images/archives/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image.webp"></p><p>甚至还要再写辅助数组rowSize和rowStart,把很明显的东西再写一遍,却又不考算法,没招了.</p><h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    LNode* q;</span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;   <span class="comment">// 断开头结点与原链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;      <span class="comment">// 保存后继</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;      <span class="comment">// 头插</span></span><br><span class="line">        p = q;            <span class="comment">// 处理下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴下代码就能看懂了,其实我觉得就是两端交换</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a href="https://www.cnblogs.com/Higurashi-kagome/p/18013626">参考1</a><br><a href="https://www.xdull.cn/kmp.html">参考2</a><br>都讲的挺好.</p><p>重点是明确next数组的作用,之所以存储模式的对应字串最长公共前后缀,是因为当匹配失败时,原字符串中在匹配失败位置前的成功匹配部分刚好可以作为重置后的模式字符串的前缀,它同时也是先前匹配时得到对应长度模式字串的后缀.搞懂了这个就能彻底理解kmp了.</p><blockquote><p>例题: 设主串T&#x3D;”abaabaabcabaabc”，模式串P&#x3D;”abaabc”，采用KMP算法进行模式匹配，到匹配成功为止，在匹配过程中进行的单个字符间的比较次数是（ ）.</p></blockquote><blockquote><p>解题: int num&#x3D;0,<br>先写出next数组[0,0,1,1,2,0],第一次匹配到abaab,num+&#x3D;5,但由于失败的匹配也要算上,num+&#x3D;1<br>指针移到后缀ab,接着比较找到abaabc,num+&#x3D;4,故num&#x3D;10</p></blockquote><h2 id="组合数求解"><a href="#组合数求解" class="headerlink" title="组合数求解"></a>组合数求解</h2><blockquote><p>【例4】编写一个递归算法，找出从自<br>然数1,2,3,4,…,n中任取r个数的所有组<br>合。例如，n&#x3D;5，r&#x3D;3时的组合是543，<br>542，541，532，531，521，432，431<br>，421，321.</p><p>【解答】本问题就是求解组合数。<br>int Combin(int m, int n)<br>{ if(m&#x3D;&#x3D;n||n&#x3D;&#x3D;0) return 1;<br>else return Combin(m-1,n)+<br>Combin(m-1,n-1);}</p></blockquote><p>一开始是用dfs写的,但没想到ppt里根本没考虑把组合写出来,不过这个递归也挺难想到的.</p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><blockquote><p>假设广义表是由带头节点的链<br>表存储，请画出广义表A(a, B((),<br>C(1)))的存储结构；假设head，tail分<br>别是求首元素操作和求尾表操作，求<br>如何获得元素1.</p></blockquote><p><img src="/images/archives/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image2.webp" alt="解答"><br>其中,一个结点的定义如下:</p><blockquote><p>utype &#x3D; 0&#x2F;1&#x2F;2&#x2F;3 ;<br>value &#x3D; ref &#x2F;intgrinfo &#x2F;charinfo &#x2F; hlink ;tlink</p></blockquote><p>0表示该节点为头节点,1表示为整数,2表示为char,3表示为子表节点,∧表示该节点为尾节点,指向该子表头节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GenList :: <span class="built_in">depth</span> ( GenListNode *ls ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ls→tlink == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//空表</span></span><br><span class="line">GenListNode *temp = ls→tlink;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( temp != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> <span class="comment">//横扫广义表</span></span><br><span class="line"><span class="keyword">if</span> ( temp→utype == LST ) &#123;</span><br><span class="line"> <span class="comment">//子表深度</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">depth</span> ( temp→value.hlink );</span><br><span class="line"><span class="keyword">if</span> ( m &lt; n ) m = n;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//不是子表不加深度</span></span><br><span class="line">temp = temp→tlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉链的应用"><a href="#二叉链的应用" class="headerlink" title="二叉链的应用"></a>二叉链的应用</h2><blockquote><p>假设二叉树采用二叉链存储，设计一个算法Level()求二叉树中值为 x 的节点的层数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Level</span><span class="params">(BiNode *T, <span class="type">int</span> x, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) <span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">Level</span>(T-&gt;lchild, x, level + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (l) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Level</span>(T-&gt;rchild, x, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树与森林典型例题"><a href="#二叉树与森林典型例题" class="headerlink" title="二叉树与森林典型例题"></a>二叉树与森林典型例题</h2><p><img src="/images/archives/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-34-19.webp" alt="题目"></p><p><img src="/images/archives/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-35-26.webp" alt="解答"></p><h2 id="静态搜索表的应用"><a href="#静态搜索表的应用" class="headerlink" title="静态搜索表的应用"></a>静态搜索表的应用</h2><h3 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h3><p>![不能写个循环吗急死我了](&#x2F;images&#x2F;archives&#x2F;2025-12-14 数据结构整理-4&#x2F;PixPin_2025-12-27_12-12-10.webp)<br>还装模做样加一个概念ASL(Average Search Length)<br>![](&#x2F;images&#x2F;archives&#x2F;2025-12-14 数据结构整理-4&#x2F;PixPin_2025-12-27_12-13-47.webp)<br><img src="/../images/archives/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-25_10-52-23.webp" alt="公式"></p><h3 id="折半搜索"><a href="#折半搜索" class="headerlink" title="折半搜索"></a>折半搜索</h3><p><img src="/../images/archives/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-27_12-34-38.webp" alt="代码"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;稀疏矩阵的三元组表&quot;&gt;&lt;a href=&quot;#稀疏矩阵的三元组表&quot; class=&quot;headerlink&quot; title=&quot;稀疏矩阵的三元组表&quot;&gt;&lt;/a&gt;稀疏矩阵的三元组表&lt;/h2&gt;&lt;p&gt;三元组表需要把行,列,值分别列出来(意义在哪里?)&lt;br&gt;&lt;img src=&quot;/im</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>我遇到的各种调试问题</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-19T01:58:56.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode-powershell终端打字缺字漏字"><a href="#vscode-powershell终端打字缺字漏字" class="headerlink" title="vscode powershell终端打字缺字漏字"></a>vscode powershell终端打字缺字漏字</h2><p>解决方法:<br>搜索设置<br>Terminal &gt; Integrated &gt; Default Profile: Windows<br>换为cmd</p><h2 id="左斜线和右斜线问题"><a href="#左斜线和右斜线问题" class="headerlink" title="左斜线和右斜线问题"></a>左斜线和右斜线问题</h2><p>windows路径都是,转义符是,而网页链接,linux都是&#x2F;<br>解决方法:<br>在搜索框输入：”Explorer: Copy Relative Path Separator”<br>将\改为正斜杠&#x2F;<br><a href="https://blog.csdn.net/kdz6511/article/details/148712726">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vscode-powershell终端打字缺字漏字&quot;&gt;&lt;a href=&quot;#vscode-powershell终端打字缺字漏字&quot; class=&quot;headerlink&quot; title=&quot;vscode powershell终端打字缺字漏字&quot;&gt;&lt;/a&gt;vscode powe</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-19 数据结构整理-(图论)</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/</id>
    <published>2025-12-19T00:00:00.000Z</published>
    <updated>2025-12-25T03:01:15.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bfs搜索"><a href="#bfs搜索" class="headerlink" title="bfs搜索"></a>bfs搜索</h2><p>特点:使用队列,可以得到最短路径,无论是否会重复访问,都能一个节点一直是最优状态.<br>写法:<br><strong>以大佬的八数码解法为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//转移数组；</span></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    map&lt;ll,ll&gt; m;</span><br><span class="line">    m[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); <span class="comment">//初始状态入队列</span></span><br><span class="line">        <span class="type">int</span> c[<span class="number">3</span>][<span class="number">3</span>],f=<span class="number">0</span>,g=<span class="number">0</span>,n=u;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">123804765</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=n%<span class="number">10</span>,n/=<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(!c[i][j])f=i,g=j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll nx=f+dx[i],ny=g+dy[i],ns=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||ny&lt;<span class="number">0</span>||nx&gt;<span class="number">2</span>||ny&gt;<span class="number">2</span>)<span class="keyword">continue</span>; <span class="comment">//越界就不执行</span></span><br><span class="line">            <span class="built_in">swap</span>(c[nx][ny],c[f][g]);</span><br><span class="line">            <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">                <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)ns=ns*<span class="number">10</span>+c[i][j];<span class="comment">//矩阵转数列 </span></span><br><span class="line">            <span class="keyword">if</span>(!m.<span class="built_in">count</span>(ns))</span><br><span class="line">            &#123;</span><br><span class="line">                m[ns]=m[u]<span class="number">+1</span>;<span class="comment">//map去重的同时顺便统计到达这个状态所需的步数</span></span><br><span class="line">                q.<span class="built_in">push</span>(ns);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(c[nx][ny],c[f][g]);<span class="comment">//状态复原</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m[<span class="number">123804765</span>]&lt;&lt;endl; <span class="comment">// map的下标直接用数列表示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dfs搜索"><a href="#dfs搜索" class="headerlink" title="dfs搜索"></a>dfs搜索</h2><p>特点:有时候会使用栈,可以得到方案总数,有次数要求时使用这个方法.<br>写法:<br><strong>以最经典的八皇后问题为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> col[N], d1[N], d2[N];  <span class="comment">// 列、主对角线、副对角线标记</span></span><br><span class="line"><span class="type">int</span> pos[N];                <span class="comment">// pos[x] = 皇后在第 x 行放的列号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                cout &lt;&lt; pos[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[c] || d1[row + c] || d2[row - c + n]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        col[c] = d1[row + c] = d2[row - c + n] = <span class="number">1</span>;</span><br><span class="line">        pos[row] = c;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        col[c] = d1[row + c] = d2[row - c + n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到,无论是dfs还是bfs,重点是将当前状态判定后再重置状态,保证后来的方案不会受到这次修改影响.</p><h2 id="dfs解疑"><a href="#dfs解疑" class="headerlink" title="dfs解疑"></a>dfs解疑</h2><p>dfs有两种结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll sum)</span> </span>&#123;  <span class="comment">// 前一半</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">push_back</span>(sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(l<span class="number">+1</span>, r, sum);        <span class="comment">// 不选</span></span><br><span class="line">    <span class="built_in">dfs1</span>(l<span class="number">+1</span>, r, sum + a[l]);  <span class="comment">// 选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就像背包问题,一般都能用动态规划解决,每一步都只有两个分支</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在每一步都有多个选择</span><br></pre></td></tr></table></figure><p>(突然发现下面这部分期末不考算法,懒得挂代码上来了)<br>(第二次复习时需要画图补充)</p><h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><h3 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h3><p>模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; other.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用lamda或许更好,这个重载太难理解了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5005</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">e</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按边权排序</span></span><br><span class="line">    <span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 已加入 MST 的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kruskal,用引用更安全</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ed : e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(ed.u) != <span class="built_in">find</span>(ed.v))&#123;</span><br><span class="line">            <span class="built_in">unite</span>(ed.u, ed.v);</span><br><span class="line">            ans += ed.w;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt != n - <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz\n&quot;</span>; <span class="comment">// 图不连通</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是用避圈法,难点是确保不形成圈,<br>用并查集来处理这我自己真想不出来,拿ai生成的我也不好意思在luogu上提交.<br>由于还是看不太懂,于是我用ai做了一个网页.</p><details><summary>点击展开 Kruskal 最小生成树演示</summary><p>下面是 Kruskal 最小生成树演示：</p><!-- Canvas 和按钮 --><canvas id="graphCanvas" width="600" height="400" style="border:1px solid #ccc;"></canvas><div style="margin-top:10px;">  <button id="nextStep">下一步</button>  <button id="reset">重置</button>  <span id="mstSum" style="margin-left:20px;">当前 MST 总权值: 0</span></div><script>// ------------------- 数据 -------------------const nodes = [  {id:0,x:100,y:100},{id:1,x:300,y:100},{id:2,x:500,y:100},  {id:3,x:200,y:300},{id:4,x:400,y:300}];const edges = [  {u:0,v:1,w:2},{u:0,v:3,w:3},{u:1,v:2,w:4},  {u:1,v:3,w:2},{u:2,v:4,w:1},{u:3,v:4,w:3}];// ------------------- Canvas 绘图 -------------------const canvas = document.getElementById('graphCanvas');const ctx = canvas.getContext('2d');function drawGraph(highlightEdge=null, skip=false) {  ctx.clearRect(0,0,canvas.width,canvas.height);  edges.forEach(e => {    const n1 = nodes[e.u], n2 = nodes[e.v];    if(e === highlightEdge){ ctx.strokeStyle = skip?'#aaa':'red'; ctx.lineWidth = 4; }    else if(e.inMST){ ctx.strokeStyle = 'green'; ctx.lineWidth = 3; }    else { ctx.strokeStyle = '#ccc'; ctx.lineWidth = 2; }    ctx.beginPath(); ctx.moveTo(n1.x,n1.y); ctx.lineTo(n2.x,n2.y); ctx.stroke();    const mx = (n1.x+n2.x)/2, my=(n1.y+n2.y)/2;    ctx.fillStyle='black'; ctx.font='14px sans-serif';    ctx.fillText(e.w,mx+5,my-5);  });  nodes.forEach(n => {    ctx.beginPath(); ctx.arc(n.x,n.y,15,0,Math.PI*2);    ctx.fillStyle='#fff'; ctx.fill();    ctx.strokeStyle='#000'; ctx.stroke();    ctx.fillStyle='black'; ctx.fillText(n.id,n.x-5,n.y+5);  });}// ------------------- 并查集 -------------------let parent = nodes.map(n=>n.id);function find(u){ return parent[u]===u ? u : (parent[u]=find(parent[u])); }function unite(u,v){ parent[find(u)] = find(v); }// ------------------- Kruskal -------------------edges.sort((a,b)=>a.w-b.w);let step=0;let mstSum = 0;document.getElementById('nextStep').onclick = function(){  if(step >= edges.length) return;  const e = edges[step];  let skip = false;  if(find(e.u) !== find(e.v)){    unite(e.u,e.v); e.inMST = true; mstSum += e.w;  } else skip = true;  drawGraph(e, skip);  document.getElementById('mstSum').textContent = "当前 MST 总权值: " + mstSum;  step++;}document.getElementById('reset').onclick = function(){  step = 0;  parent = nodes.map(n=>n.id);  edges.forEach(e=>e.inMST=false);  mstSum = 0;  drawGraph();  document.getElementById('mstSum').textContent = "当前 MST 总权值: " + mstSum;}// 初始化drawGraph();</script></details><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>写<a href="https://www.luogu.com.cn/problem/P1194">P1194</a>的时候脑袋卡壳了,怎么都想不出如何得到和更新当前的最小代价<br>于是问了ai,发现还有prim算法可以用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> k[MAX][MAX];</span><br><span class="line"><span class="type">int</span> dist[MAX];</span><br><span class="line"><span class="type">bool</span> vis[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入代价矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">            cin &gt;&gt; k[i][j];</span><br><span class="line">            <span class="comment">// 如果通过别人得到比直接买还贵，直接舍弃</span></span><br><span class="line">            <span class="keyword">if</span> (k[i][j] &gt; a||k[i][j]==<span class="number">0</span>) k[i][j] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        dist[i] = a;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim 主循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mn = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找当前未加入生成树、代价最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dist[j] &lt; mn) &#123;</span><br><span class="line">                mn = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入生成树</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans += dist[u];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 u 更新其他点的最小代价</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= b; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                dist[v] = <span class="built_in">min</span>(dist[v], k[u][v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实好理解不少,可以看出来prim是点驱动的,每次找到代价最小的点,起点任意选择;<br>而kruskal是边驱动的,每次找到代价最小的不成环边,起点选最小边.</p><h2 id="Dijkstra最短路径算法"><a href="#Dijkstra最短路径算法" class="headerlink" title="Dijkstra最短路径算法"></a>Dijkstra最短路径算法</h2><p><a href="https://gallery.selfboot.cn/zh/algorithms/dijkstra">极好的证明</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 归纳基础：k = 1 时，T 中只包含起点 s，dist[s] = short[s] = 0，因此命题在 k = 1 时成立。</span><br><span class="line"></span><br><span class="line">2. 归纳假设：假设命题在第 k 步时成立，即 T 中所有节点的 dist 值都是最短路径长度。</span><br><span class="line"></span><br><span class="line">3. 归纳步骤：证明第 k+1 步时命题也成立：</span><br><span class="line"></span><br><span class="line">设第 k+1 步选择的节点为 v（v 是未访问节点中 dist 值最小的）；v 与集合 T 中的某个节点 u 相连；</span><br><span class="line">需要证明：dist[v] = short[v]。</span><br><span class="line">这里用反证法：</span><br><span class="line"></span><br><span class="line">假设存在一条从起点 s 到 v 的路径 P，其长度是 short[v]，且 short[v] &lt; dist[v]。</span><br><span class="line">由于起点 s 在集合 T 中，而终点 v 不在集合 T 中，路径 P 必然至少经过一个集合 T 中的节点（除起点外）。因为起点 s 到任何不在 T 中节点的距离，都是通过 T 中的节点来计算和更新的。</span><br><span class="line">设路径 P 上最后一个在集合 T 中的节点为 last，之后经过未访问集合中的节点 y 最终到达 v；下面看路径 P 的长度计算：</span><br><span class="line">  short[v] = dist[last] + distance[last,y] + distance[y,v]  // 路径 P 的长度</span><br><span class="line">           ≥ dist[y] + distance[y,v]                        // 根据 dist[y] 的更新规则</span><br><span class="line">           ≥ dist[v]      </span><br><span class="line">要理解下面这两个点才能明白上面的推导：</span><br><span class="line">首先由归纳假设，到达 last 的距离 dist[last] 是最短的；对于节点 y，根据 Dijkstra 算法的更新规则：dist[y] ≤ dist[last] + distance[last,y]</span><br><span class="line"></span><br><span class="line">又因为算法第 k+1 步选择了 v 作为当前最小距离节点，所以 dist[v] ≤ dist[y] + distance[y,v]。</span><br><span class="line">于是就推导出 short[v] &gt;= dist[v]，这和我们的假设 short[v] &lt; dist[v] 矛盾，因此假设不成立，dist[v] 就是从起点到 v 的最短路径长度。这也证明了算法每一步选择的节点的距离都是最短路径长度。</span><br></pre></td></tr></table></figure><p>这个归纳证明直接讲明白了算法的核心步骤,每次取未vis的最短路后更新其他未vis的最短路,直到遍历完所有节点就可以了</p><h2 id="floyd最短路径算法"><a href="#floyd最短路径算法" class="headerlink" title="floyd最短路径算法"></a>floyd最短路径算法</h2><p>重点是确认初始状态,之后将所有点遍历作为中间点更新最短路径,写一个三重循环,可得到任意两点之间的最短路径.<br>可以看出来floyd更为通用,dijkstra只能得到单源最短路径</p><h2 id="aoe网络关键路径"><a href="#aoe网络关键路径" class="headerlink" title="aoe网络关键路径"></a>aoe网络关键路径</h2><p><a href="https://blog.csdn.net/ROBOT_a/article/details/147289874">讲的最清楚</a></p><blockquote><p>关键路径所经过的结点的最迟发生时间和最早发生时间是一致的。如果不好理解的话，打个比方，比如小组作业中，有个同学做的特别慢（关键路径）。所有人同时开始做，其他组员都做完了，他还没有做完，而小组只有等所有人都做完才能上交作品，那么完成小组作业所需的总时间就取决于他的时间。为了不拖后腿，对于他来说，他所做的n个事情就没有“最早什么时候做”“最晚什么时候做”这个说法，而是要马不停蹄地一直做。其他组员则可以选择早一点或晚一点做，只要不比他（关键路径）慢就行。<br>————————————————<br>版权声明：本文为CSDN博主「木卫三上的下午茶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ROBOT_a/article/details/147289874">https://blog.csdn.net/ROBOT_a/article/details/147289874</a></p></blockquote><p>这个解释非常妙,让我一下看懂了.</p><p>关键是先求每个节点的最早发生时间和最迟发生时间,<br>再根据节点反推边对应事件的最早发生时间和最迟发生时间,相减得到差额,等于0的就是关键路径所经过的边.<br>需要明确的是递推方向,最早从前往后推,最迟从后往前推,节点和事件都是这样.<br>(到处搜资料还是没看懂,一翻到这篇文章就看懂了)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bfs搜索&quot;&gt;&lt;a href=&quot;#bfs搜索&quot; class=&quot;headerlink&quot; title=&quot;bfs搜索&quot;&gt;&lt;/a&gt;bfs搜索&lt;/h2&gt;&lt;p&gt;特点:使用队列,可以得到最短路径,无论是否会重复访问,都能一个节点一直是最优状态.&lt;br&gt;写法:&lt;br&gt;&lt;stron</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/18/archives-2025-12-18-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/18/archives-2025-12-18-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-18T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://exquora.thoughtstorms.info/"></a></p><p>我对 Quora 上瘾，情不自禁使用这个网站。那里有一些很棒的问题和讨论，激发了我的灵感和想法。</p><p>但是当我重新阅读自己写的答案，一方面欣赏我的修辞和洞察力，另一方面也看到了很多想法可以成长为更大的成果。它们本可能进一步发展为软件、文章、论文、创业公司、书籍或社会运动，但任何事都没有发生。</p><p>不仅如此，还有许多篇我写的长篇大论已经无关紧要，沦为了废文。还有很多我花了好几个小时写的评论，试图说服对于这些问题永远不可能改变观点的那些读者。</p><p>我花了数千（也许是数万）小时在 Quora 上写作。我写的远不止11000个答案，还有5000多个草稿答案，其中很多已经写得很长了，只是因为来不及最终润色而没​​有发表。</p></blockquote><p>这篇文章说出了我想说的,我见过很多极其优秀的故事或者技术讲解,可作者发布的网站恰恰是贴吧,天涯或者知乎这样的问答网站或者论坛,作者的观点被一篇篇孤立的文章或者一条条回复分割开来,很难形成一个完整的体系.</p><p>而天涯的倒闭也说明了在这些自己不能掌控的平台上并不能保证自己的思想可以永久保留下来,那些优秀的文章随着服务器的关闭直接成为了无法触及的历史,即便是作者本人也无法找回.</p><p>因此,我拒绝在论坛里写长篇大论,而是作为读者去发掘优秀的文章,可惜的是现在优秀的文章也越来越少了,而AI生成的无意义内容充斥着论坛的每个角落,很难找到真正有意义的东西,这也是我悲哀的一点.</p><p>一方面,论坛不能让作者的文字体系化,另一方面,博客不能保证作者的文章能广泛传播,比如我这个博客就不是所有国人都能访问到的,很难找到一个折衷点.</p><p>如果我有那个能力,我可能会去开发一个跨平台的博客论坛吧,侧重点在于分享生活和技术,每个人都能像写博客一样把文章从自己本地上传,改进一下SEO算法,保证最好的文章优先显示,集成了评论系统和follow功能,最大幅度减少作者需要折腾的东西,只写md就行了,呈现的页面也由作者自己在前端设置.重点是这个网站能长久保存,不会让作者的心血白费.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://exquora.thoughtstorms.info/&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我对 Quora 上瘾，情不自禁使用这个网站。那里有一些很棒的问题和讨论，激发了我的灵感和想法。&lt;/p&gt;
&lt;p&gt;但是当我重新阅读自己</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18 触动过我的文章</title>
    <link href="https://revival-of-hope.github.io/2025/12/18/dynamic-2025-12-18-%E8%A7%A6%E5%8A%A8%E8%BF%87%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/18/dynamic-2025-12-18-%E8%A7%A6%E5%8A%A8%E8%BF%87%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-18T00:00:00.000Z</published>
    <updated>2025-12-24T06:47:11.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十年前的实习面试"><a href="#十年前的实习面试" class="headerlink" title="十年前的实习面试"></a><a href="https://zhuanlan.zhihu.com/p/117315093">十年前的实习面试</a></h3><h3 id="疫情求职"><a href="#疫情求职" class="headerlink" title="疫情求职"></a><a href="https://juejin.cn/post/7180678820796563516?searchId=20251125151954D8EF0E1FE1D09C7C0330">疫情求职</a></h3><h3 id="github-stars-wont-pay-your-rent"><a href="#github-stars-wont-pay-your-rent" class="headerlink" title="github-stars-wont-pay-your-rent"></a><a href="https://www.kitze.io/posts/github-stars-wont-pay-your-rent">github-stars-wont-pay-your-rent</a></h3><h3 id="git考古"><a href="#git考古" class="headerlink" title="git考古"></a><a href="https://blog.brachiosoft.com/">git考古</a></h3><h3 id="速通日语"><a href="#速通日语" class="headerlink" title="速通日语"></a><a href="https://galgame.dev/topic/639/%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%80%E5%B9%B4%E4%B8%8D%E5%88%B0%E9%80%9F%E9%80%9An1%E8%BF%99%E4%BB%B6%E4%BA%8B-%E5%9F%BA%E4%BA%8E%E5%95%83%E7%94%9F%E8%82%89galgame%E7%9A%84%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/8">速通日语</a></h3><h3 id="加拿大体验"><a href="#加拿大体验" class="headerlink" title="加拿大体验"></a><a href="https://ramsayleung.github.io/zh/post/2024/%E7%99%BB%E9%99%86%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/">加拿大体验</a></h3><h3 id="日本游记"><a href="#日本游记" class="headerlink" title="日本游记"></a><a href="https://nekonull.me/archive/2310-jp-travel/">日本游记</a></h3><h3 id="python的问题"><a href="#python的问题" class="headerlink" title="python的问题"></a><a href="https://www.dongwm.com/post/be-a-gopher/">python的问题</a></h3><h3 id="My-solopreneur-story-zero-to-45K-mo-in-2-years"><a href="#My-solopreneur-story-zero-to-45K-mo-in-2-years" class="headerlink" title="My solopreneur story: zero to $45K&#x2F;mo in 2 years"></a><a href="https://news.tonydinh.com/p/my-solopreneur-story-zero-to-45kmo">My solopreneur story: zero to $45K&#x2F;mo in 2 years</a></h3><h3 id="肮脏的交易"><a href="#肮脏的交易" class="headerlink" title="肮脏的交易"></a><a href="https://www.mooreslawisdead.com/post/sam-altman-s-dirty-dram-deal">肮脏的交易</a></h3><h3 id="十年学会编程"><a href="#十年学会编程" class="headerlink" title="十年学会编程"></a><a href="http://daiyuwen.freeshell.org/gb/misc/21-days-cn.html">十年学会编程</a></h3><h3 id="契诃夫分析"><a href="#契诃夫分析" class="headerlink" title="契诃夫分析"></a><a href="https://mhperng.blogspot.com/2025/12/anton-chekhov.html">契诃夫分析</a></h3><h3 id="软件开发经验"><a href="#软件开发经验" class="headerlink" title="软件开发经验"></a><a href="https://cloud.tencent.com/developer/article/1004735">软件开发经验</a></h3><h3 id="保研与工作"><a href="#保研与工作" class="headerlink" title="保研与工作"></a><a href="https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/">保研与工作</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;十年前的实习面试&quot;&gt;&lt;a href=&quot;#十年前的实习面试&quot; class=&quot;headerlink&quot; title=&quot;十年前的实习面试&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/117315093&quot;&gt;十年前的实习面试&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 道路与选择</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/archives-2025-12-16-%E9%81%93%E8%B7%AF%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/archives-2025-12-16-%E9%81%93%E8%B7%AF%E4%B8%8E%E9%80%89%E6%8B%A9/</id>
    <published>2025-12-16T08:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<p>这几天有点焦躁和郁闷,总有种无所适从的感觉,浑浑噩噩的,对很多事都不上心了,于是现在静下来认真思考了一下当前的处境.</p><p>人生是由一大堆选择构成的,每一个分岔路口都决定了我以后的人生道路,有时候选择多种多样,似乎哪里都是通路,有时候仿佛是山穷水尽,让我别无选择.</p><p>人自然是希望选择越多越好,这就是我以前为什么倾向于做事提早做准备的原因,为的就是不让自己在ddl的时候显得无路可走.</p><p>但过多的选择,太多的可能,悲观的现实又让我痛苦万分,人生的道路总是要自己走的,但如果有一个引路人就更好了.看不清未来的道路只会使我无所适从,一边厌恶着填鸭式的教育,一边追求绩点的完美,只怕到头来也是一场空.</p><h2 id="梁甫吟"><a href="#梁甫吟" class="headerlink" title="梁甫吟"></a>梁甫吟</h2><p><strong>唐 · 李白</strong></p><blockquote><p>長嘯梁甫吟，何時見陽春？<br>君不見，朝歌屠叟辭棘津，八十西來釣渭濱。<br>寧羞白髮照清水，逢時壯氣思經綸。<br>廣張三千六百釣，風期暗與文王親。<br>大賢虎變愚不測，當年頗似尋常人。  </p><p>君不見，高陽酒徒起草中，長揖山東隆準公。<br>入門不拜逞雄辯，兩女輟洗來趨風。<br>東下齊城七十二，指揮楚漢如鏇蓬。<br>狂客落魄尚如此，何況壯士當群雄！  </p><p>我欲攀龍見明主，雷公砰訇震天鼓。<br>帝旁投壺多玉女，三時大笑開電光，<br>倏爍晦冥起風雨。<br>閶闔九門不可通，以額扣關閽者怒。  </p><p>白日不照我精誠，杞國無事憂天傾。<br>猰貐磨牙競人肉，騶虞不折生草莖。<br>手接飛猱搏雕虎，側足焦原未言苦。  </p><p>智者可卷愚者豪，世人見我輕鴻毛。<br>力排南山三壯士，齊相殺之費二桃。<br>吳楚弄兵無劇孟，亞夫咍爾為徒勞。  </p><p>梁甫吟，聲正悲。<br>張公兩龍劍，神物合有時。<br>風雲感會起屠釣，大人臲屼當安之。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天有点焦躁和郁闷,总有种无所适从的感觉,浑浑噩噩的,对很多事都不上心了,于是现在静下来认真思考了一下当前的处境.&lt;/p&gt;
&lt;p&gt;人生是由一大堆选择构成的,每一个分岔路口都决定了我以后的人生道路,有时候选择多种多样,似乎哪里都是通路,有时候仿佛是山穷水尽,让我别无选择.&lt;</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 折腾记录-动态更新</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/dynamic-2025-12-16-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/dynamic-2025-12-16-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/</id>
    <published>2025-12-16T00:00:00.000Z</published>
    <updated>2025-12-27T04:26:17.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo图片管理困难-帖子多了很难阅读"><a href="#hexo图片管理困难-帖子多了很难阅读" class="headerlink" title="hexo图片管理困难,帖子多了很难阅读"></a>hexo图片管理困难,帖子多了很难阅读</h2><p>解决方法:<br>config_yml里修改<br>new_post_name: :year-:month-:day-:title.md<br>同时,听从大佬建议,将所有图片改成webp格式,效果立竿见影<br><img src="/images/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/tmpDAFA.png"></p><h2 id="还是图片问题-每次复制images子文件夹路径太麻烦"><a href="#还是图片问题-每次复制images子文件夹路径太麻烦" class="headerlink" title="还是图片问题,每次复制images子文件夹路径太麻烦"></a>还是图片问题,每次复制images子文件夹路径太麻烦</h2><p>根据<a href="https://www.hwpo.top/posts/d87f7e0c/index.html"></a>教程在post文件夹里设置同名文件夹没解决</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>最后写了一个脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 用 data.path 生成文件夹名</span></span><br><span class="line">  <span class="comment">// data.path 是相对于 source/_posts 的路径，带后缀</span></span><br><span class="line">  <span class="keyword">const</span> filename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, path.<span class="title function_">extname</span>(data.<span class="property">path</span>)); <span class="comment">// 去掉扩展名</span></span><br><span class="line">  <span class="keyword">const</span> imagesDir = path.<span class="title function_">join</span>(hexo.<span class="property">base_dir</span>, <span class="string">&#x27;source/images&#x27;</span>, filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(imagesDir)) &#123;</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(imagesDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Created image folder: <span class="subst">$&#123;imagesDir&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在同级目录下生成图像文件夹来管理,麻烦的是每次都要删去相对路径里的’source&#x2F;‘</p><h2 id="hexo命令行"><a href="#hexo命令行" class="headerlink" title="hexo命令行"></a>hexo命令行</h2><p>hexo new post&#x2F;draft&#x2F;page<br>hexo publish draft”文章名”<br>hexo d           –push my blog  deploy<br>hexo new  +name     –new blog<br>hexo g            –apply changes  generate<br>hexo s            –local static html #预览<br>hexo g -d   #一次完成</p><p>draft也就是草稿，在使用hexo创建文章时，可以先指定为草稿。<br>hexo new draft <title><br>然后在完成之后，使用publish命令将draft转移到post下。<br>hexo publish <title></p><h2 id="改用butterfly主题"><a href="#改用butterfly主题" class="headerlink" title="改用butterfly主题"></a>改用butterfly主题</h2><p>这个主题确实好用了不少</p><h2 id="增加评论系统"><a href="#增加评论系统" class="headerlink" title="增加评论系统"></a>增加评论系统</h2><p><a href="https://tech.yemengstar.com/vercel-twikoo-comment-your-hexo/">参考文章</a></p><h2 id="尝试新部署方式"><a href="#尝试新部署方式" class="headerlink" title="尝试新部署方式"></a>尝试新部署方式</h2><p><a href="https://tech.yemengstar.com/github-actions-auto-hexo/"></a></p><h2 id="增加了category条目-tag条目和背景图片"><a href="#增加了category条目-tag条目和背景图片" class="headerlink" title="增加了category条目,tag条目和背景图片"></a>增加了category条目,tag条目和背景图片</h2><p>原来要用<code>hexo new page tag</code>才能在hexo里显示tag页和category页</p><h2 id="发现md只要在posts下都能被直接解析-25-12-21"><a href="#发现md只要在posts下都能被直接解析-25-12-21" class="headerlink" title="发现md只要在posts下都能被直接解析(25&#x2F;12&#x2F;21)"></a>发现md只要在posts下都能被直接解析(25&#x2F;12&#x2F;21)</h2><p>于是我将不会再修改的文章都移动到了archives文件夹,图片路径也做了对应的修改,<br>之前我还想文章多了要怎么处理呢.</p><h2 id="还是图片问题-hexo本地无法正确解析相对路径"><a href="#还是图片问题-hexo本地无法正确解析相对路径" class="headerlink" title="还是图片问题,hexo本地无法正确解析相对路径"></a>还是图片问题,hexo本地无法正确解析相对路径</h2><p>例如<code>source/images/archives/2025-11-26/image.png</code><br>需要改为’images&#x2F;archives&#x2F;2025-11-26&#x2F;image.png’,每次改就很麻烦了<br>于是找ai弄了脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data.<span class="property">cover</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    data.<span class="property">cover</span> = data.<span class="property">cover</span>.<span class="title function_">replace</span>(</span><br><span class="line">      <span class="regexp">/^\/?source\//</span>,</span><br><span class="line">      <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完美解决,以后只要把复制相对路径就可以了,不要再删删减减了.</p><h2 id="增加rss订阅图标"><a href="#增加rss订阅图标" class="headerlink" title="增加rss订阅图标"></a>增加rss订阅图标</h2><p><a href="https://mitpoppy.github.io/posts/fe13d434.html">参考文章</a><br>发现了RSS订阅方式,于是增加了这一功能</p><h2 id="更改了图像文件夹创建方式-25-12-26"><a href="#更改了图像文件夹创建方式-25-12-26" class="headerlink" title="更改了图像文件夹创建方式(25&#x2F;12&#x2F;26)"></a>更改了图像文件夹创建方式(25&#x2F;12&#x2F;26)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// data.path: 2025-12-26-xxx.md</span></span><br><span class="line">  <span class="keyword">const</span> basename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, path.<span class="title function_">extname</span>(data.<span class="property">path</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取前 10 个字符作为日期</span></span><br><span class="line">  <span class="keyword">const</span> date = basename.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 图片目录：source/images/2025-12-26</span></span><br><span class="line">  <span class="keyword">const</span> imagesDir = path.<span class="title function_">join</span>(</span><br><span class="line">    hexo.<span class="property">base_dir</span>,</span><br><span class="line">    <span class="string">&#x27;source/images&#x27;</span>,</span><br><span class="line">    date</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(imagesDir)) &#123;</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(imagesDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Created image folder: <span class="subst">$&#123;imagesDir&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于我的post创建格式在config里面改成了这样子<br><code>new_post_name: :year-:month-:day-:title.md</code><br>故可以根据日期直接找到对应的图片,这样图片管理起来更加方便了,但原来的几十个文件夹我是真不想再改了.</p><h2 id="突然发现没必要用file-utils粘贴相对路径-直接复制图片就好了-12-27"><a href="#突然发现没必要用file-utils粘贴相对路径-直接复制图片就好了-12-27" class="headerlink" title="突然发现没必要用file utils粘贴相对路径,直接复制图片就好了(12&#x2F;27)"></a>突然发现没必要用file utils粘贴相对路径,直接复制图片就好了(12&#x2F;27)</h2><p>在settings.json里加上</p><figure class="highlight plaintext"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;**/*.md&quot;: &quot;images/$&#123;documentBaseName&#125;/&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>就可以在md里直接复制图片而不是自己写了<img src="/">这些东西了,<br>甚至会根据图片复制的位置智能选择是插入相对路径还是插入整个图片链接格式,又能偷一点懒了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo图片管理困难-帖子多了很难阅读&quot;&gt;&lt;a href=&quot;#hexo图片管理困难-帖子多了很难阅读&quot; class=&quot;headerlink&quot; title=&quot;hexo图片管理困难,帖子多了很难阅读&quot;&gt;&lt;/a&gt;hexo图片管理困难,帖子多了很难阅读&lt;/h2&gt;&lt;p&gt;解决</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-14 数据结构整理-(树和堆)</title>
    <link href="https://revival-of-hope.github.io/2025/12/14/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/"/>
    <id>https://revival-of-hope.github.io/2025/12/14/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/</id>
    <published>2025-12-14T00:00:00.000Z</published>
    <updated>2025-12-27T04:23:33.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前序遍历-中序遍历-后序遍历-层序遍历"><a href="#前序遍历-中序遍历-后序遍历-层序遍历" class="headerlink" title="前序遍历,中序遍历,后序遍历,层序遍历"></a>前序遍历,中序遍历,后序遍历,层序遍历</h2><p>依次为根左右,左根右,左右根,逐层遍历<br>![说明](&#x2F;images&#x2F;archives&#x2F;2025-12-14 数据结构整理-4&#x2F;PixPin_2025-12-25_10-52-23.webp)<br>在递归里打印的顺序也是如此<br><strong>以前序遍历为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> BinaryTree&lt;Type&gt;::</span><br><span class="line"><span class="built_in">PreOrder</span> ( BinTreeNode &lt;Type&gt; *current ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( current != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        cout &lt;&lt; current→data;</span><br><span class="line">        <span class="built_in">PreOrder</span> ( current→leftChild );</span><br><span class="line">        <span class="built_in">PreOrder</span> ( current→rightChild );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据前序和中序画二叉树"><a href="#根据前序和中序画二叉树" class="headerlink" title="根据前序和中序画二叉树"></a>根据前序和中序画二叉树</h3><p><img src="/images/archives/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-55-59.webp" alt="例题"></p><h2 id="线索化二叉树-Threaded-Binary-Tree"><a href="#线索化二叉树-Threaded-Binary-Tree" class="headerlink" title="线索化二叉树 (Threaded Binary Tree)"></a>线索化二叉树 (Threaded Binary Tree)</h2><p>简单说来就是空的左指针指向对应遍历顺序的前驱,若自己是第一个节点则为 nullptr,右指针指向对应遍历顺序的后驱,若自己为最后一个节点则为 nullptr.<br>![](&#x2F;images&#x2F;archives&#x2F;2025-12-14 数据结构整理-4&#x2F;PixPin_2025-12-25_10-57-29.webp)</p><p>但我觉得这种不太会考算法,最多考我画画图,所以 pass 掉.</p><h2 id="最大堆和最小堆"><a href="#最大堆和最小堆" class="headerlink" title="最大堆和最小堆"></a>最大堆和最小堆</h2><h3 id="向下调整算法"><a href="#向下调整算法" class="headerlink" title="向下调整算法"></a>向下调整算法</h3><p>调整顺序:自下而上,从右往左,其实就是从尾部节点开始倒着遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小堆的向下调整算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt; :: <span class="built_in">FilterDown</span> ( <span class="type">int</span> start, <span class="type">int</span></span><br><span class="line">EndOfHeap ) &#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    <span class="comment">// j 是 i 的左子女</span></span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= EndOfHeap ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( j &lt; EndOfHeap &amp;&amp; heap[j] &gt; heap[j<span class="number">+1</span>] ) j++; <span class="comment">//两子女中选小者</span></span><br><span class="line">        <span class="keyword">if</span> ( temp &lt;= heap[j] ) <span class="keyword">break</span>; <span class="comment">//不需要调整</span></span><br><span class="line">        <span class="keyword">else</span> &#123; heap[i] = heap[j]; i = j; j = <span class="number">2</span>*j<span class="number">+1</span>; &#125;</span><br><span class="line">        <span class="comment">//相当于把start一直通过swap向下调整到最优位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理可推得最大堆的向下调整算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MaxHeap&lt;Type&gt; :: <span class="built_in">FilterDown</span>(<span class="type">int</span> start,<span class="type">int</span> EndOfHeap)&#123;</span><br><span class="line">    <span class="type">int</span> i=start,j=<span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=EndOfHeap)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;EndofHeap&amp;&amp;heap[j]&lt;heap[j<span class="number">+1</span>]) j++;<span class="comment">//两子女选大者</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=hep[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            heap[i]=heap[j];</span><br><span class="line">            i=j;</span><br><span class="line">            j=<span class="number">2</span>*j<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入与向上调整算法"><a href="#插入与向上调整算法" class="headerlink" title="插入与向上调整算法"></a>插入与向上调整算法</h3><p>简单说来就是插入到堆的末尾,然后向上逐层调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">int</span> MinHeap&lt;Type&gt; :: <span class="built_in">Insert</span> ( <span class="type">const</span> Type &amp;x ) &#123;</span><br><span class="line"><span class="comment">//在堆中插入新元素 x</span></span><br><span class="line"><span class="keyword">if</span> ( CurrentSize == MaxHeapSize ) <span class="comment">//堆满</span></span><br><span class="line">&#123; cout &lt;&lt; <span class="string">&quot;堆已满&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">heap[CurrentSize] = x;</span><br><span class="line"> <span class="comment">//插在表尾</span></span><br><span class="line"><span class="built_in">FilterUp</span> (CurrentSize);</span><br><span class="line"> <span class="comment">//向上调整为堆</span></span><br><span class="line">CurrentSize++;</span><br><span class="line"> <span class="comment">//堆元素增一</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt; :: <span class="built_in">FilterUp</span> ( <span class="type">int</span> start ) &#123;</span><br><span class="line"><span class="comment">//从 start 开始,向上直到0,调整堆</span></span><br><span class="line">    <span class="type">int</span> j = start, i = (j<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// i 是 j 的父结点</span></span><br><span class="line">    Type temp = heap[j];</span><br><span class="line">    <span class="keyword">while</span> ( j &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( heap[i] &lt;= temp ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; heap[j] = heap[i]; j = i; i = (i <span class="number">-1</span>)/<span class="number">2</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h3><p>通过把顶端和堆末尾元素交换来把顶端删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">int</span> MinHeap &lt;Type&gt; :: <span class="built_in">RemoveMin</span> (Type &amp;x)&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !CurrentSize )&#123;   </span><br><span class="line">        cout &lt;&lt; “ 堆已空 <span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    x = heap[0];</span></span><br><span class="line"><span class="string">    //删除最小元素</span></span><br><span class="line"><span class="string">    heap[0] = heap[CurrentSize-1];</span></span><br><span class="line"><span class="string">    CurrentSize--;</span></span><br><span class="line"><span class="string">    FilterDown ( 0, CurrentSize-1 ); // start, EndOfHeap</span></span><br><span class="line"><span class="string">    //从0号位置开始自顶向下调整为堆</span></span><br><span class="line"><span class="string">    return 1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="左孩子右兄弟表示法"><a href="#左孩子右兄弟表示法" class="headerlink" title="左孩子右兄弟表示法"></a>左孩子右兄弟表示法</h2><p>为了将多叉树转换成二叉树,从上往下遍历,左指针指向第一个孩子,右指针指向同层右边的兄弟<br>同理,将二叉树转换成多叉树,也是从上往下遍历,根据左右指针重新画图</p><h2 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h2><p>森林转化成二叉树  </p><ul><li>核心转换规则：左孩子右兄弟表示法  </li><li>先将每棵树转二叉树（左孩子右兄弟），再将二叉树按右子节点连接<br><code>用人话说就是把根节点都看成是兄弟就可以了</code><br><code>这样的话沿着根节点的右指针一直遍历拆分下去就可以找到这个森林的原始结构了</code><br>二叉树转换为森林  </li><li>先按右子节点拆分二叉树，再将每棵二叉树还原为原树（逆左孩子右兄弟）</li></ul><h2 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h2><blockquote><p>假定用于通信的电文仅由 8个字母 c1, c2, c3, c4, c5, c6, c7, c8 组成, 各字母在电文中出现的频率<br>分别为 5, 25, 3, 6, 10, 11, 36, 4。试为这 8 个字母设计不等长 Huffman编码, 并给出该电文的总码数。</p></blockquote><p>答案：257</p><details><summary>点击查看流程图</summary><p><img src="/images/archives/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-26_13-06-42.webp"></p></details><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>稍微接触过一点算法的人都知道要怎么写吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[a]==a)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[a]=<span class="built_in">find</span>(f[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa=<span class="built_in">find</span>(a),fb=<span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">        f[fb]=fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> s,t;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="built_in">unite</span>(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![然而ppt中是这样写路径压缩的…](&#x2F;images&#x2F;archives&#x2F;2025-12-14 数据结构整理-4&#x2F;PixPin_2025-12-27_11-58-23.webp)<br>![而它的parent数组定义是这样的…](&#x2F;images&#x2F;archives&#x2F;2025-12-14 数据结构整理-4&#x2F;PixPin_2025-12-27_12-00-58.webp)<br>都用数组来存结点数了却没用数组存母节点吗,有点意思,为了不想让人轻易看懂真的是煞费苦心,我觉得这种代码要是考了就有点sm了,之后有时间我再瞅两眼,没时间就算了.</p><blockquote><p>【例1】请给出下列操作序列的运算结果，其中M是合并，F是查找：M(1,2),M(3,4),M(3,5),M(1,7),M(3,6),M(8,9),M(1,8),M(3,10),M(3,11),M(3,12),M(3,13),M(14,15),M(16,17),M(14,16),M(1,3),M(1,14)<br>根据树的高度执行合并（高度高的树作为根节点）：<br>1)画出并查集森林的构造过程。<br>2)画出存储该并查集的数组。</p></blockquote><p>![解答](&#x2F;images&#x2F;archives&#x2F;2025-12-14 数据结构整理-4&#x2F;PixPin_2025-12-27_12-06-42.webp)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前序遍历-中序遍历-后序遍历-层序遍历&quot;&gt;&lt;a href=&quot;#前序遍历-中序遍历-后序遍历-层序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历,中序遍历,后序遍历,层序遍历&quot;&gt;&lt;/a&gt;前序遍历,中序遍历,后序遍历,层序遍历&lt;/h2&gt;&lt;p&gt;依次</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-14 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/14/archives-2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/14/archives-2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-14T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7%C2%B7%E5%85%8B%E4%BC%A6%E6%96%AF%E5%9F%BA">克伦斯基wiki</a></p><p>今天翻wiki时通过多次跳转转到了克伦斯基的界面,之前对他的印象只有布尔什维克对他主政政府时期的控诉,以为他只是一个常见的反对派角色.</p><p><img src="/images/2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/1.webp"><br>看完wiki之后才发现他与<em>陈独秀</em>,<em>托洛茨基</em>并无区别,同样是内心向往着一个更加美好,自由的社会,同样是怀有或多或少的高士情怀,但是每况愈下的社会形势迫使他们站出来,担任自己本不想担任的领袖角色,在时代的浪潮下起起落落,最终被推上风口浪尖,只是因为不愿意参与尔虞我诈的政治斗争,狠不下心去为自己谋求应有的利益,怀着革命为人民的期望,最后却成为被革命的对象,从先驱者变成背叛者,不为敌我双方所认同,无路可走,跌下本就不属于自己的神坛,摔得粉碎.<br>被尘封在历史的角落,所有的功绩都被后来者掠夺殆尽.</p><p><strong>他们宛若一颗流星,照亮了整个世界,而后轰然坠落,再无人记得他们.</strong></p><p>这也是我厌恶英雄光环和领袖情结的原因,很多人之所以能够从渺渺众生中脱颖而出,原因便是对自己狠得下心,愿意去做那些旁人坚持不下去或者难以接受的事情,可是如果一个人对自己都能如此狠心,那对待别人又怎么可能会不狠心,不使用一些肮脏的手段,又怎么能让不甘居于人下的自己摘取桂冠,不通过残酷的斗争,又怎么可能胜过同样是英雄俊杰的对手甚至是同志.</p><p>可惜我对自己也狠不下心,又何从说对别人狠心,只好默默地给英雄们让道了.</p><p>之后会出一系列文章分析俄国革命的全流程,之所以写在这,是提醒自己别忘了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7%C2%B7%E5%85%8B%E4%BC%A6%E6%96%AF%E5%9F%BA&quot;&gt;克伦斯基wiki&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-11 数据结构整理-(排序专项)</title>
    <link href="https://revival-of-hope.github.io/2025/12/11/2025-12-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-3/"/>
    <id>https://revival-of-hope.github.io/2025/12/11/2025-12-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-3/</id>
    <published>2025-12-11T00:00:00.000Z</published>
    <updated>2025-12-25T04:01:47.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="速通版"><a href="#速通版" class="headerlink" title="速通版"></a>速通版</h2><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>O(n^2)不可取</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><blockquote><p>思路:<br>找到upper_bound,插入后将后面的数组下标加一,重点是找到插入下标.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp=a[i],index=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;temp) index--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;index;j--)&#123;</span><br><span class="line">        a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    a[index]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><blockquote><p>思路与上面相同,只是这次用二分法找到upper_bound</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp=a[i],index=i;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;temp)&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l=mid<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=l;j--)&#123;</span><br><span class="line">        a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    a[l]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>思路:每次取增量的一半进行分组排序,直到增量为1,保证完全有序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;  <span class="comment">// 外层：缩小 gap</span></span><br><span class="line">        <span class="comment">// 对于当前 gap，进行分组插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;  <span class="comment">// 从 gap 开始，每个元素插入到前面的子序列</span></span><br><span class="line">            <span class="type">int</span> temp = a[i];  <span class="comment">// 当前元素</span></span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="comment">// 在子序列中向后移（步长 gap）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; a[j - gap] &gt; temp) &#123;</span><br><span class="line">                a[j] = a[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = temp;  <span class="comment">// 插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>每一轮排好一个数字,n个数字排n-1轮</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=a[j<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;a[j])&#123;</span><br><span class="line">            a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">            a[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以直接用swap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = a[l];</span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= pivot) j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a[i] = pivot;</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">// 返回 pivot 最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, l, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(a,<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为参考视频</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1205817791&bvid=BV1tf421Q7eh&cid=1596291120&p=1"   width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe><blockquote><p>吐槽一下B站直接在分享点嵌入代码给出的是<code>&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=1205817791&amp;bvid=BV1tf421Q7eh&amp;cid=1596291120&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;</code><br>结果只能在很小的一块区域显示,所以我用ai改成了<code>&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=1205817791&amp;bvid=BV1tf421Q7eh&amp;cid=1596291120&amp;p=1&quot; width=&quot;100%&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;速通版&quot;&gt;&lt;a href=&quot;#速通版&quot; class=&quot;headerlink&quot; title=&quot;速通版&quot;&gt;&lt;/a&gt;速通版&lt;/h2&gt;&lt;h3 id=&quot;复杂度&quot;&gt;&lt;a href=&quot;#复杂度&quot; class=&quot;headerlink&quot; title=&quot;复杂度&quot;&gt;&lt;/a&gt;复杂度&lt;/h</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-09 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/09/archives-2025-12-09-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/09/archives-2025-12-09-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-09T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每当有人给我的开源项目，提出这样或那样的要求，我就给他三个 F，让他自己选一个。<br>Fix it, Fork it, F**k off.<br><a href="https://boyter.org/posts/the-three-f-s-of-open-source/">来源</a></p></blockquote><p>每当我看到一个比较小众的实用开源项目,通常都是只有一个contributer或者一个branch,而issue却有好几个或者几十个,这些issue很少是提修改建议的,更多的是要求增加各种各样的自己想要的需求.</p><p>如果每个人都这样做,从不想到自己加入到这个项目中帮助创建者完善功能,那么开发者的热情将会急速冷却,开源社区也将不复存在,幸好现在还不是这样.</p><blockquote><p>人生有没有意义？人类又有什么意义？<br>我说，人生是有意义的，而人类则是没有意义的。<br>询问人类的存在有没有意义，就等于询问地球或宇宙的存在有没有意义一样，是得不到答案的。<br>人生的意义是什么呢？它的意义就在于为没有意义的人类工作、服务等等，其目的不外乎是使人类生活得更好并得以延续。<br>反正人类是现实的存在，你又是其中一员，你有义务使它发展延续。你只要这样做了，你的人生就具有了意义，或者说价值，并不一定要去理会人类存在的意义。<br><a href="https://ruanyf-weekly.vercel.app/weekly/issue-228">来源</a></p></blockquote><p>要我说这段话只是消极中的乐观而已,人类没有意义,人生也没有意义.</p><p>人类只是感觉的动物,我们当前的体验决定了我们的感受,也正是一次次体验塑造了我们.所以尽管人生没有意义,我还是想去多体验目前所没能看到和听到的一切.</p><p>因此我不愿意沿着别人的老路走,因为这终究是别人的体验,重走一次未免太乏味;但我也不愿意去走一条全新的,险峻的道路,因为我不想让自己遭罪.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每当有人给我的开源项目，提出这样或那样的要求，我就给他三个 F，让他自己选一个。&lt;br&gt;Fix it, Fork it, F**k off.&lt;br&gt;&lt;a href=&quot;https://boyter.org/posts/the-three-f-s-of</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-29 神奇的cocos2d-x</title>
    <link href="https://revival-of-hope.github.io/2025/11/29/archives-2025-11-29-%E7%A5%9E%E5%A5%87%E7%9A%84cocos2d-x/"/>
    <id>https://revival-of-hope.github.io/2025/11/29/archives-2025-11-29-%E7%A5%9E%E5%A5%87%E7%9A%84cocos2d-x/</id>
    <published>2025-11-29T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<p>由于课程作业要求用cocos2d-x完成,把我折腾的够呛.<br>以下是我的心路历程:</p><p>选用cc4.0版本,由于要求用python2编译,尽管我删除了python3的环境变量,但cmd在编译的时候还是用了python3,windows系统不得不品的一环,<br>-&gt;<br>狠下心卸载了python3,重置了python2,终于能够正常运行cmd里的cocos命令了,一打开vs看的我满头雾水.<br>-&gt;<br>于是去官网找教程,<br><a href="https://docs.cocos2d-x.org/cocos2d-x/v4/zh/basic_concepts/sprites.html"></a><br>谁想官网的教程基本啥都没教,甚至不会教我在一个新建cpp文件里要包含哪些东西,而是填鸭式的讲一些分块组件,于是放弃看教程<br>-&gt;<br>找到了cocos安装时自带的test项目,一运行,发现连官方的test的项目都跑不了,官网教程甚至没教我怎么运行这个test项目,于是换成3.17.2,还试了试github上其他的项目,可能是我打开的方法不对,总有或多或少的小问题<br>-&gt;<br>仔细研究,看了看test项目里的cmakelists<br>贴一小段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">     Classes/controller.h</span><br><span class="line">     Classes/TransitionsTest/TransitionsTest.h</span><br><span class="line">     Classes/TextureCacheTest/TextureCacheTest.h</span><br><span class="line">     Classes/MotionStreakTest/MotionStreakTest.h</span><br><span class="line">     Classes/ExtensionsTest/AssetsManagerExTest/AssetsManagerExTest.h</span><br><span class="line">     Classes/ExtensionsTest/ExtensionsTest.h</span><br><span class="line">     Classes/ExtensionsTest/TableViewTest/CustomTableViewCell.h</span><br><span class="line">     Classes/ExtensionsTest/TableViewTest/TableViewTestScene.h</span><br><span class="line">     Classes/ExtensionsTest/NetworkTest/WebSocketTest.h</span><br><span class="line">     Classes/ExtensionsTest/NetworkTest/WebSocketDelayTest.h</span><br><span class="line">     Classes/ExtensionsTest/NetworkTest/SocketIOTest.h</span><br><span class="line">     Classes/ExtensionsTest/NetworkTest/HttpClientTest.h</span><br><span class="line">     Classes/Sprite3DTest/Sprite3DTest.h</span><br><span class="line">     Classes/Sprite3DTest/DrawNode3D.h</span><br><span class="line">     Classes/BaseTest.h</span><br><span class="line">     Classes/SceneTest/SceneTest.h</span><br><span class="line">     Classes/ReleasePoolTest/ReleasePoolTest.h</span><br><span class="line">     Classes/InputTest/MouseTest.h</span><br><span class="line"><span class="comment">#     Classes/SpineTest/SpineTest.h</span></span><br><span class="line"><span class="comment">#     Classes/Scene3DTest/Scene3DTest.h</span></span><br><span class="line">     Classes/ParticleTest/ParticleTest.h</span><br><span class="line">     Classes/EffectsTest/EffectsTest.h</span><br><span class="line">     Classes/UITest/UITest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIScrollViewTest/UIScrollViewTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/CocosGUIScene.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITabControlTest/UITabControlTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITextFieldTest/UITextFieldTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITextBMFontTest/UITextBMFontTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIImageViewTest/UIImageViewTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UISliderTest/UISliderTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UILoadingBarTest/UILoadingBarTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIEditBoxTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIRichTextTest/UIRichTextTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIScene.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIPageViewTest/UIPageViewTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIButtonTest/UIButtonTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIScale9SpriteTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIWidgetAddNodeTest/UIWidgetAddNodeTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIListViewTest/UIListViewTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UISceneManager.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIRadioButtonTest/UIRadioButtonTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UILayoutTest/UILayoutTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITextAtlasTest/UITextAtlasTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UICheckBoxTest/UICheckBoxTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIFocusTest/UIFocusTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITextTest/UITextTest.h</span><br><span class="line">     Classes/DrawPrimitivesTest/DrawPrimitivesTest.h</span><br><span class="line">     Classes/BillBoardTest/BillBoardTest.h</span><br><span class="line">     Classes/SpriteFrameCacheTest/SpriteFrameCacheTest.h</span><br><span class="line">     Classes/EffectsAdvancedTest/EffectsAdvancedTest.h</span><br><span class="line">     Classes/SchedulerTest/SchedulerTest.h</span><br><span class="line">     Classes/MultiTouchTest/MultiTouchTest.h</span><br><span class="line">     Classes/testResource.h</span><br><span class="line">     Classes/ShaderTest/ShaderTest.vsh.h</span><br><span class="line">     Classes/ShaderTest/shaderTest.psh.h</span><br><span class="line">     Classes/ShaderTest/ShaderTest.h</span><br><span class="line">     Classes/ShaderTest/ShaderTest2.h</span><br><span class="line">     Classes/NewRendererTest/NewRendererTest.h</span><br><span class="line">     Classes/SpritePolygonTest/SpritePolygonTest.h</span><br><span class="line">     Classes/TexturePackerEncryptionTest/TextureAtlasEncryptionTest.h</span><br></pre></td></tr></table></figure><p>这怎么还一个个自己填呢<br>-&gt;<br>默默地换回cc4.0,继续受苦<br>-&gt;<br><a href="https://www.cnblogs.com/geore/p/5793864.html">找到了古早博客</a><br>但版本不是4.0的,不过对照着还能看<br>-&gt;<br><a href="https://www.freesion.com/article/7454340813/">好的,终于找到了</a><br>cocos run –proj-dir .. -p win32<br>发现这个确实就在readme.md里,好吧,是我没认真看文档…<br>![](images&#x2F;2025-11-29 神奇的cocos2d-x&#x2F;image.png)<br>好的,我不该抱着什么希望的.<br>-&gt;<br><a href="https://forum.cocos.org/t/topic/120754">好滴,又找到高人了</a><br>官方把这些问题整合一下会死吗,哈哈,不过cocos死的也差不多了.<br>-&gt;<br>好的,还是跑不了,显然test里的项目用的是vs 2010,根本兼容不了,<br>于是又换成了3.17.2里的测试项目,原来一开始自带了build好的文件,他也知道新手自己跑不了,<br>现在终于能跑测试项目了,接下来可以好好研究变量的使用了(玄学)<br>-&gt;</p><h2 id="cocos命令"><a href="#cocos命令" class="headerlink" title="cocos命令"></a>cocos命令</h2><p>cocos new &lt;项目名&gt;  -l cpp 当前目录下生成<br>cmake -S . -B build -G “Visual Studio 17 2022” -A win32 -T v143  在新项目里强制改cmake方式.<br>新增加文件时,在cmake里面加入对应的文件路径<br>再运行<code>cmake ..</code>就行了</p><h2 id="研究场景创建"><a href="#研究场景创建" class="headerlink" title="研究场景创建"></a>研究场景创建</h2><p><strong>1.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cocos2d.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __HELLOWORLD_SCENE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HELLOWORLD_SCENE_H__ <span class="comment">//防止反复包含同一头文件</span></span></span><br><span class="line">USING_NS_CC; <span class="comment">//using namespace cocos2d,意义不明的缩写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> : <span class="keyword">public</span> cocos2d::Scene <span class="comment">//继承cocos2d命名空间下的scene类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">override</span></span>;  </span><br><span class="line">    <span class="comment">//override作为关键字,要求重写scene内的这个init()函数与现在这个函数必须同名,否则报错.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> cocos2d::Scene* <span class="title">scene</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//把这个函数开放给appdelegate.cpp使用</span></span><br><span class="line">    <span class="comment">// a selector callback</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">menuCloseCallback</span><span class="params">(Ref* sender)</span></span>;</span><br><span class="line">/</span><br><span class="line">    <span class="comment">// implement the &quot;static create()&quot; method manually</span></span><br><span class="line">    <span class="built_in">CREATE_FUNC</span>(HelloWorld);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>1.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">USING_NS_CC;</span><br><span class="line"></span><br><span class="line"><span class="function">Scene* <span class="title">HelloWorld::scene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> HelloWorld::<span class="built_in">create</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HelloWorld::init</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//内部实现所有自己要搞的功能,重载原Scene对象的init()函数</span></span><br><span class="line">    <span class="keyword">auto</span> visibleSize = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleSize</span>();</span><br><span class="line">    <span class="comment">//窗口对角线向量</span></span><br><span class="line">    <span class="keyword">auto</span> origin = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleOrigin</span>();</span><br><span class="line">    <span class="comment">//左下角(0,0)</span></span><br><span class="line">    <span class="comment">// 2. add a menu item with &quot;X&quot; image, which is clicked to quit the program</span></span><br><span class="line">    <span class="comment">//    you may modify it.</span></span><br><span class="line">    <span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(</span><br><span class="line">                                        <span class="string">&quot;CloseNormal.png&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">                                        <span class="built_in">CC_CALLBACK_1</span>(HelloWorld::menuCloseCallback,<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//第一个是未选中时的图片,第二个是选中时的图片</span></span><br><span class="line"><span class="comment">//第三个是回调函数</span></span><br><span class="line">    closeItem-&gt;<span class="built_in">setPosition</span>(origin + <span class="built_in">Vec2</span>(visibleSize) - <span class="built_in">Vec2</span>(closeItem-&gt;<span class="built_in">getContentSize</span>() / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">//此时menu已经和closeitem绑定,位置也相互绑定</span></span><br><span class="line">    menu-&gt;<span class="built_in">setPosition</span>(Vec2::ZERO);</span><br><span class="line">    <span class="comment">//但还是要先初始化一下位置,sb cocos</span></span><br><span class="line">    <span class="comment">//而且莫名其妙这里就变成相对位置了</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(menu, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//调用addchild方法置于图层1,不然会被初始图层0覆盖 </span></span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line">    <span class="comment">// 3. add your codes below...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add a label shows &quot;Hello World&quot;</span></span><br><span class="line">    <span class="comment">// create and initialize a label</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> label = Label::<span class="built_in">createWithTTF</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, TITLE_FONT_SIZE);</span><br><span class="line"><span class="comment">//注意到这里的font size需要手动指明,没有默认字体大小给你</span></span><br><span class="line">    <span class="comment">// position the label on the center of the screen</span></span><br><span class="line">    label-&gt;<span class="built_in">setPosition</span>(origin.x + visibleSize.width/<span class="number">2</span>,</span><br><span class="line">                            origin.y + visibleSize.height - label-&gt;<span class="built_in">getContentSize</span>().height);</span><br><span class="line"><span class="comment">//注意到这不是函数重载,只传入二维向量时要写明vec2方法以接收两个参数</span></span><br><span class="line">    <span class="comment">// add the label as a child to this layer</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(label, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add &quot;HelloWorld&quot; splash screen&quot;</span></span><br><span class="line">    <span class="keyword">auto</span> sprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;HelloWorld.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position the sprite on the center of the screen</span></span><br><span class="line">    sprite-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(visibleSize / <span class="number">2</span>) + origin);</span><br><span class="line">    <span class="comment">//如果默认从(0,0)开始又为什么要把origin加上去呢</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add the sprite as a child to this layer</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(sprite);</span><br><span class="line">    <span class="comment">//神奇的是精灵放在-1不会被覆盖,可能默认精灵不会重叠吧</span></span><br><span class="line">    <span class="keyword">auto</span> drawNode = DrawNode::<span class="built_in">create</span>();</span><br><span class="line">    drawNode-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">addChild</span>(drawNode);</span><br><span class="line"></span><br><span class="line">    Rect safeArea = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getSafeAreaRect</span>();</span><br><span class="line">    drawNode-&gt;<span class="built_in">drawRect</span>(safeArea.origin, safeArea.origin + safeArea.size, Color4F::BLUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWorld::menuCloseCallback</span><span class="params">(Ref* sender)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁实例吗</span></span><br></pre></td></tr></table></figure><p>短短几行,够我研究了.<br><a href="https://blog.csdn.net/qq_42048450/article/details/117282640">虚函数了解</a></p><h2 id="研究appdelegate"><a href="#研究appdelegate" class="headerlink" title="研究appdelegate"></a>研究appdelegate</h2><p><strong>appdelegate.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">AppDelegate::<span class="built_in">AppDelegate</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line">AppDelegate::~<span class="built_in">AppDelegate</span>() </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小心翼翼的构造与析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppDelegate::initGLContextAttrs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLContextAttrs glContextAttrs = &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    GLView::<span class="built_in">setGLContextAttrs</span>(glContextAttrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没必要管的底层画布函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AppDelegate::applicationDidFinishLaunching</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize director</span></span><br><span class="line">    <span class="keyword">auto</span> director = Director::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> glview = director-&gt;<span class="built_in">getOpenGLView</span>();</span><br><span class="line">    <span class="keyword">if</span>(!glview) &#123;</span><br><span class="line">        glview = GLViewImpl::<span class="built_in">create</span>(<span class="string">&quot;Cpp Empty Test&quot;</span>);</span><br><span class="line">        <span class="comment">//窗口标题设定</span></span><br><span class="line">        director-&gt;<span class="built_in">setOpenGLView</span>(glview);</span><br><span class="line">    &#125;</span><br><span class="line">    glview-&gt;<span class="built_in">setIcon</span>(icons);</span><br><span class="line"></span><br><span class="line">    director-&gt;<span class="built_in">setOpenGLView</span>(glview);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the design resolution</span></span><br><span class="line">    glview-&gt;<span class="built_in">setDesignResolutionSize</span>(designResolutionSize.width, </span><br><span class="line">    designResolutionSize.height, ResolutionPolicy::NO_BORDER);</span><br><span class="line"></span><br><span class="line">    Size frameSize = glview-&gt;<span class="built_in">getFrameSize</span>();</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; searchPath;</span><br><span class="line">    <span class="comment">// Create a scene. it&#x27;s an autorelease object</span></span><br><span class="line">    <span class="keyword">auto</span> scene = HelloWorld::<span class="built_in">scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run</span></span><br><span class="line">    director-&gt;<span class="built_in">runWithScene</span>(scene);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="官方cpp-empty-test-项目"><a href="#官方cpp-empty-test-项目" class="headerlink" title="官方cpp_empty_test 项目"></a>官方cpp_empty_test 项目</h2><p><strong>AppMacros.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Resource mediumResource =  &#123; cocos2d::<span class="built_in">Size</span>(<span class="number">1024</span>, <span class="number">768</span>),  <span class="string">&quot;ipad&quot;</span>   &#125;;</span><br><span class="line"><span class="comment">//设置窗口尺寸</span></span><br></pre></td></tr></table></figure><h2 id="cpp-test-项目"><a href="#cpp-test-项目" class="headerlink" title="cpp_test 项目"></a>cpp_test 项目</h2><p>由于沟槽的项目文件不是按照教程步骤归类,找起来头疼.<br>![](images&#x2F;2025-11-29 神奇的cocos2d-x&#x2F;tmpC6C9.png)</p><p>发现这样写成纯吐槽了,重开一个帖子来写汇总心得.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于课程作业要求用cocos2d-x完成,把我折腾的够呛.&lt;br&gt;以下是我的心路历程:&lt;/p&gt;
&lt;p&gt;选用cc4.0版本,由于要求用python2编译,尽管我删除了python3的环境变量,但cmd在编译的时候还是用了python3,windows系统不得不品的一环,&lt;br</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>

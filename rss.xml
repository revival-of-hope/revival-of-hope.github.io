<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当时只道是寻常</title>
  
  
  <link href="https://revival-of-hope.github.io/rss.xml" rel="self"/>
  
  <link href="https://revival-of-hope.github.io/"/>
  <updated>2026-01-01T08:26:59.641Z</updated>
  <id>https://revival-of-hope.github.io/</id>
  
  <author>
    <name>Revival-of-hope</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2026-01-01 离散数学整理-群论</title>
    <link href="https://revival-of-hope.github.io/2026/01/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E7%BE%A4%E8%AE%BA/"/>
    <id>https://revival-of-hope.github.io/2026/01/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E7%BE%A4%E8%AE%BA/</id>
    <published>2026-01-01T00:00:00.000Z</published>
    <updated>2026-01-01T08:26:59.641Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113979489780353&bvid=BV1H2NoeiE1K&cid=28736228422&p=1"        width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe><h2 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h2><p>半群满足加法,群还满足减法,环还满足乘法,域还满足除法</p><h2 id="各种运算律"><a class="markdownIt-Anchor" href="#各种运算律"></a> 各种运算律</h2><h3 id="结合律"><a class="markdownIt-Anchor" href="#结合律"></a> 结合律</h3><ul><li><code>a+(b+c)=(a+b)+c</code><br />结合律是群论中最为重要的部分,只有满足结合律的代数系统才可以进行两项以上的计算,例如计算a+b+c.如果(a+b)+c!=q+(b+c),那就无法得出唯一的结果了</li></ul><h3 id="交换律"><a class="markdownIt-Anchor" href="#交换律"></a> 交换律</h3><ul><li><code>a+b=b+a</code><br />很多代数系统不满足交换律,例如矩阵乘法</li></ul><h3 id="分配律"><a class="markdownIt-Anchor" href="#分配律"></a> 分配律</h3><p>如果<em>对+满足以下式子,则称</em>对+满足分配律</p><ul><li><code>a*(b+c)=a*b+a*c</code></li></ul><h3 id="幂等律"><a class="markdownIt-Anchor" href="#幂等律"></a> 幂等律</h3><ul><li><code>a+a=a</code><br />在幂等律成立的代数系统中，对同一元素重复运算不会产生新的结果，常见于集合的并运算与交运算中。</li></ul><h3 id="吸收律"><a class="markdownIt-Anchor" href="#吸收律"></a> 吸收律</h3><p>需要同时满足下面两个式子</p><ul><li><code>a+(a*b)=a</code></li><li><code>a*(a+b)=a</code><br />吸收律描述了两种运算之间的相互制约关系，是格论与布尔代数中的基本性质</li></ul><h3 id="消去律"><a class="markdownIt-Anchor" href="#消去律"></a> 消去律</h3><p><img src="../images/archives/2026-01-01/PixPin_2026-01-01_15-47-28.webp" alt="例题" /><br />逆元和结合律保证了消去律的存在</p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><img src="../images/archives/2026-01-01/PixPin_2026-01-01_10-35-05.webp" alt="" /></p><h2 id="同态和同构"><a class="markdownIt-Anchor" href="#同态和同构"></a> 同态和同构</h2><p><strong>同态（Homomorphism）</strong><br />设 ((A, \circ))、((B, \ast)) 是两个代数系统，若存在映射<br />[<br />f : A \to B<br />]<br />满足对任意 (a,b \in A)，都有<br />[<br />f(a \circ b) = f(a) \ast f(b)<br />]<br />则称 (f) 为从 (A) 到 (B) 的同态映射。</p><p><strong>例子（幂的同态）</strong><br />设<br />[<br />A = (\mathbb{R}, +), \quad B = ({e^x \mid x \in \mathbb{R}}, \cdot)<br />]<br />定义映射<br />[<br />f(x) = e^x<br />]<br />则<br />[<br />f(x+y) = e^{x+y} = e^x \cdot e^y = f(x)\cdot f(y)<br />]<br />因此 (f) 是一个同态。</p><p><strong>同构（Isomorphism）</strong><br />若同态 (f : A \to B) 是双射（既单射又满射），则称 (A) 与 (B) 同构，记作<br />[<br />A \cong B<br />]</p><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><p><img src="../images/archives/2026-01-01/PixPin_2026-01-01_14-30-58.webp" alt="" /><br />通过这个例题可以明确几点关于映射的知识</p><ul><li>没参与映射的元素不会计入原像集合,例如这里的0在原像集合中,故一定有像存在</li><li>双射时像和原像一定是一一对应的</li></ul><h2 id="半群"><a class="markdownIt-Anchor" href="#半群"></a> 半群</h2><p>满足结合律的封闭代数系统称为半群,没有什么特殊性质<br />例子: 自然数下的加法</p><p>含有幺元的半群称为独异点(垃圾翻译)</p><h2 id="群"><a class="markdownIt-Anchor" href="#群"></a> 群</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><p>存在一个数e,使得对于集合S内所有的元素a都满足以下公式,则称e为集合S的幺元</p><ul><li><code>e+a=a,a+e=a</code></li></ul><p>若一个半群S存在幺元e,且对于集合S内所有的元素a都有逆元b满足以下公式,则称S为群</p><ul><li><code>b+a=a+b=e</code></li></ul><ol><li>由于零元不存在逆元,故群都不含零元</li><li>除单位元素e外群不存在等幂元素</li></ol><h3 id="群的阶数"><a class="markdownIt-Anchor" href="#群的阶数"></a> 群的阶数</h3><p>群G中元素的个数称为阶数,记作|G|,若个数有限,称为有限群,否则为无限群,若G只有一个单位元素e,则称为平凡群</p><h3 id="交换群阿贝尔群"><a class="markdownIt-Anchor" href="#交换群阿贝尔群"></a> 交换群(阿贝尔群)</h3><p>满足交换律的群称为交换群</p><h3 id="klein四元群"><a class="markdownIt-Anchor" href="#klein四元群"></a> Klein四元群</h3><p><img src="../images/archives/2026-01-01/PixPin_2026-01-01_15-36-07.webp" alt="" /><br />G的运算具有以下特点:</p><ol><li>e为G中的幺元</li><li>.是可交换的</li><li>任何G中元素与自己运算的结果都为e</li><li>除幺元外任意两个元素的运算结果都等于另一个元素</li></ol><p>可以看出Klein四元群既是交换群又是有限群</p><h3 id="子群"><a class="markdownIt-Anchor" href="#子群"></a> 子群</h3><p>生成子群</p><h3 id="子群-2"><a class="markdownIt-Anchor" href="#子群-2"></a> 子群</h3><p>设 ((G, \circ)) 为群，(H \subseteq G)。若满足：</p><ol><li>(e \in H)</li><li>若 (a,b \in H)，则 (a \circ b \in H)</li><li>若 (a \in H)，则 (a^{-1} \in H)</li></ol><p>则称 (H) 为 (G) 的子群，记作 (H \le G)。</p><hr /><h3 id="元素生成的子群循环子群"><a class="markdownIt-Anchor" href="#元素生成的子群循环子群"></a> 元素生成的子群（循环子群）</h3><p>若 (S={a})，则：<br />[<br />\langle a \rangle<br />= { a^n \mid n \in \mathbb{Z} }<br />]</p><p>其中：</p><ul><li>(a^0 = e)</li><li>(a^{-n} = (a<sup>{-1})</sup>n)</li></ul><h3 id="循环群"><a class="markdownIt-Anchor" href="#循环群"></a> 循环群</h3><h2 id="环"><a class="markdownIt-Anchor" href="#环"></a> 环</h2><h2 id="域"><a class="markdownIt-Anchor" href="#域"></a> 域</h2><h2 id="格与布尔代数"><a class="markdownIt-Anchor" href="#格与布尔代数"></a> 格与布尔代数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=113979489780353&amp;bvid=BV1H2NoeiE1K&amp;cid=28736228422&amp;p=1&quot;        width=&quot;100%&quot;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2025 年终总结</title>
    <link href="https://revival-of-hope.github.io/2025/12/31/archives-2025-2025-12-31-%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <id>https://revival-of-hope.github.io/2025/12/31/archives-2025-2025-12-31-%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%A7%E4%BD%9C%E4%B8%9A/</id>
    <published>2025-12-31T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周都在忙cocos大作业,差点在30号晚上熬通宵.今天下午答辩,答辩前五分钟才把ppt写完,而项目到演示时都没能完整运行,还好老师们都不怎么在意真正的成品,反而是一直拷打代码中继承和多态的应用,侥幸过关,如果真的要当场演示,那估计就有大问题了.</p><p>究其原因,是小组合作的环节出了问题,我们组有一个本来能自己单干的大佬,而剩下的两人包括我则是不一般的菜鸡,大多数代码都是由AI完成的,很多报错也只有问AI才能解决,因为我之前根本就没接触过CPP的工程构建,多文件的集成也都是靠AI解决的.</p><p>尽管大佬给了很详细的接口文档,但由于文档全是英文,于是我们就直接贴给AI让它翻译,又没好意思让他一个人帮我们看代码,那样他就把活儿都干了.于是就悲剧了.尽管UI层的隔离测试可以跑通,Gameplay和Engine部分单独跑也可以,但由于我们这边的实现不够完全,接口没能全部写完整,于是在答辩前三天的合并时就出问题了,而且在大佬很早就提出要对齐接口的时候我们不够重视,导致接口一直有偏差,等发现是由于接口没对齐导致报错的时候离答辩只有不到一天了.而大佬以为我们都实现好了,只是路径包含或者平台差异导致报错,之前就没有来帮我们改代码,而这个时候再改就已经来不及了.</p><p><strong>复盘</strong><br />小组项目成功的必要条件:</p><ul><li>组员之间关系平等,不存在不好意思说话的情况,只有好好的沟通交流才能保证项目协作正常</li><li>组员之间能力不能相差太大,如果能力都有限反而更好团队协作,光是抱大腿未免有些太要不得了</li><li>组员需要掌握基本的Debug能力,光是靠AI或者求爷爷告奶奶是不行的,而是要能够自己独立解决基本的技术问题</li><li>每次更新都需要及时通过文档告知其他组员,详细写明更改的地方,以及对合作者的接口要求,最好是中文(😀)</li><li>在开始项目之前就要搭出一个最基本的框架,即使再抽象也可以,把所有必须要实现的功能要求先列出来,才可以保证后续运行的时候不跑偏</li><li>分工不合理很有可能导致组员间暗藏怨气,需要找到一个合理的分工方式和架构保证工作量分配均匀</li><li>使用git进行版本控制,每次commit时不要偷懒,多打几个字把本次commit好好说清楚,才不会在日后受罪</li><li>需要尽早进行合并,才能确认基本功能有没有正常实现,否则后期的合并会极其痛苦</li><li>永远不要孤军奋战,给代码一通乱改,而是虚心请教他人,如果拉不下脸,想想项目失败的后果</li></ul><p>想来这也是对我这一个学期课业的一个糟糕的总结吧,学的不够精,学的不够多,到最后啥都没剩下,还有三个小时就跨年了,祝新的一年我能更成熟一点,更好学一点,更活泼一点,更努力一点,不用太多,一点点就够了,能让我自己感觉到就够了.</p><p><strong>目标</strong></p><ul><li>[ ] cpp工程学习</li><li>[ ] 后端学习(数据库+Java)</li><li>[ ] 网络安全学习</li><li>[ ] 编写一个开源项目</li><li>[ ] 参加十场以上的比赛</li><li>[ ] 明确就业还是读研</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一周都在忙cocos大作业,差点在30号晚上熬通宵.今天下午答辩,答辩前五分钟才把ppt写完,而项目到演示时都没能完整运行,还好老师们都不怎么在意真正的成品,反而是一直拷打代码中继承和多态的应用,侥幸过关,如果真的要当场演示,那估计就有大问题了.&lt;/p&gt;
&lt;p&gt;究其原因</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-27 各种grammar集合</title>
    <link href="https://revival-of-hope.github.io/2025/12/27/dynamic-2025-12-27-grammar/"/>
    <id>https://revival-of-hope.github.io/2025/12/27/dynamic-2025-12-27-grammar/</id>
    <published>2025-12-27T00:00:00.000Z</published>
    <updated>2026-01-01T06:06:00.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索引擎命令"><a class="markdownIt-Anchor" href="#搜索引擎命令"></a> 搜索引擎命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">设关键词为计算机</span><br><span class="line"><span class="string">&quot;计算机&quot;</span>:        <span class="comment"># 必须含有计算机三个字</span></span><br><span class="line">计算机 after:2023-01-01 before:2024-01-01 <span class="comment"># 限定日期</span></span><br><span class="line">计算机 past:1y <span class="comment"># 过去一年</span></span><br><span class="line">计算机 filetype:pdf <span class="comment"># 限定文件类型</span></span><br><span class="line">计算机 site:baidu.com <span class="comment"># 限定网站  </span></span><br><span class="line">计算机 -考研 <span class="comment">#排除关键词</span></span><br><span class="line">site:.edu        （教育机构）</span><br><span class="line">site:.gov        （政府网站）</span><br><span class="line">site:.org        （组织机构）</span><br><span class="line">site:.cn         （中国网站）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="git命令"><a class="markdownIt-Anchor" href="#git命令"></a> git命令</h2><p>windows端先设置代理端口</p><figure class="highlight plaintext"><figcaption><span>http_proxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>git init //初始化git,只运行一次<br />git add . //所有文件加入本地git<br />git commit -m “first commit” //提交到本地<br />git branch -M main //设置提交分支为main,之后可以不必运行<br />git remote add origin <a href="https://github.com/revival-of-hope/Clash_of_Clans.git">https://github.com/revival-of-hope/Clash_of_Clans.git</a> //关联选定仓库并在本地设置标签为origin,只要运行一次<br />git push -u origin main //-u(upstream)设置上游分支为origin的main分支,以后默认提交到origin仓库的main分支,以后只写git push就行</p><p>之后再修改只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">#可加上origin main关键字,但由于已经设置默认上游,故可以省略</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;描述修改&quot;</span> <span class="comment">#不加引号也可以</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>即可</p><h2 id="hexo命令行"><a class="markdownIt-Anchor" href="#hexo命令行"></a> hexo命令行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hexo new post/draft/page</span><br><span class="line">hexo publish draft&quot;文章名&quot;</span><br><span class="line">hexo d           --push my blog  deploy</span><br><span class="line">hexo new  +name     --new blog</span><br><span class="line">hexo g            --apply changes  generate</span><br><span class="line">hexo s            --local static html #预览</span><br><span class="line">hexo g -d   #一次完成</span><br><span class="line"></span><br><span class="line">draft也就是草稿，在使用hexo创建文章时，可以先指定为草稿。</span><br><span class="line">hexo new draft &lt;title&gt;</span><br><span class="line">然后在完成之后，使用publish命令将draft转移到post下。</span><br><span class="line">hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure><h2 id="markdown"><a class="markdownIt-Anchor" href="#markdown"></a> markdown</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">##</span><br><span class="line">###</span><br><span class="line">####</span><br></pre></td></tr></table></figure><p>均为标题</p><p><code>[]() 插入链接和说明</code><br /><code>![]() 插入图片</code><br />`</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113979489780353&bvid=BV1H2NoeiE1K&cid=28736228422&p=1"        width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe> 插入图片`<figure class="highlight plaintext"><figcaption><span>插入代码块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`代码` 行内代码</span><br><span class="line">`*斜体*`</span><br><span class="line">`**粗体** `</span><br><span class="line">`~~删除线~~`</span><br><span class="line">`==高亮==`</span><br></pre></td></tr></table></figure><ul><li>项目</li></ul><ul><li>项目</li></ul><ul><li>项目</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三种方式均可以表示列表</span><br></pre></td></tr></table></figure><ul><li>[ ] 未完成</li><li>[x] 已完成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ol><li>项目</li><li>项目</li><li>项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&gt; 引用内容</span><br><span class="line">&gt;&gt; 嵌套引用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br><span class="line">___</span><br><span class="line">三种方式均可以表示分割线</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 列1 | 列2 | 列3 |</span><br><span class="line">| --- | --- | --- |</span><br><span class="line">| A   | B   | C   |</span><br><span class="line"></span><br><span class="line">表格</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜索引擎命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#搜索引擎命令&quot;&gt;&lt;/a&gt; 搜索引擎命令&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-26 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/26/archives-2025-2025-12-26-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/26/archives-2025-2025-12-26-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-26T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://ipotato.me/article/65">来源</a><br />说实话大三上就开始找实习其实是一个有些冒险，但相应收益会比较高的做法。风险点在于学校的课程安排趋近于收尾，一些比较难的专业课也会集中在这个学期，如何平衡好学习和工作是一个首先要考虑的因素，这一点上我的做法比较粗暴：直接翘课。一是因为成绩也够不着保研的尾巴，无需那么在意绩点，二是因为除了体育课这种比较难逃的课，其他一律统统全翘，只是为了挤出了一周 4 天的实习时长，至于课业，只能安排到工作日下班，周末以及考试临近时的请假进行学习。但即便是翘课，对于一些专业课程还是要用心，比如 OS 以及编译原理等课程，可以说是专业的重中之重，不光学习会接触，在面试以及工作中也是非常核心的内容。好在一个学期下来课虽然都翘了，但最后的结果也不坏，没有顾此失彼而整出来个挂科。</p></blockquote><ul><li>其实如果没打算读研的话就可以这么做,既然是本科毕业就工作,那绩点的意义就消失了.</li></ul><p>这几天用<a href="https://rawweb.org/">rawweb</a>不知道看了多少博客,足够大的体量保证了我搜任何一个关键词基本都能找到答案,每一个博客对我来说都是一个全新的领域,仿佛博主的生活就是我的生活,他们的迷惘和彷徨就是我的迷惘和彷徨.就比如我搜索关键词保研,一下就得到了一千多条结果,里面的很多文章对我来说都是对读研和工作这一抉择的重新认识.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ipotato.me/article/65&quot;&gt;来源&lt;/a&gt;&lt;br /&gt;
说实话大三上就开始找实习其实是一个有些冒险，但相应收益会比较高的做法。风险点在于学校的课程安排趋近于收尾，一些比较难的专业课也会集中在这个学期</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25 离散数学整理-逻辑关系</title>
    <link href="https://revival-of-hope.github.io/2025/12/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/</id>
    <published>2025-12-25T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.855Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据离散数学简明教程整理,仅为一本一百多页的薄书,但涵盖了大部分概念.</p><h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1><h2 id="用一个例子搞懂集合运算"><a class="markdownIt-Anchor" href="#用一个例子搞懂集合运算"></a> 用一个例子搞懂集合运算</h2><p><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-25_21-34-39.webp" alt="" /><br /><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-25_21-37-39.webp" alt="重要的德摩根律" /></p><h2 id="对称差运算"><a class="markdownIt-Anchor" href="#对称差运算"></a> 对称差运算</h2><p>对称差运算满足结合律,交换律,分配律<br />其中分配律最难理解,但在网上甚至找不到什么人解释<br /><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-41-15.webp" alt="公式" /></p><h1 id="关系"><a class="markdownIt-Anchor" href="#关系"></a> 关系</h1><p><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-49-58.webp" alt="定义" /></p><p><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-53-32.webp" alt="" /></p><p><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_15-55-36.webp" alt="关系的几种性质" /></p><h2 id="关系图"><a class="markdownIt-Anchor" href="#关系图"></a> 关系图</h2><p>自反关系中每个节点都有环,反自反关系中没有环<br />对称关系中两个节点之间都是双向箭头,反对称关系中不存在双向箭头</p><h2 id="关系闭包"><a class="markdownIt-Anchor" href="#关系闭包"></a> 关系闭包</h2><p><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_16-02-46.webp" alt="" /></p><p>自反闭包加上单位矩阵就可以了,对称闭包把矩阵补成对称的就可以了,传递闭包真得一个个推,要是真按照公式算那真没完了.</p><h2 id="等价关系与偏序关系"><a class="markdownIt-Anchor" href="#等价关系与偏序关系"></a> 等价关系与偏序关系</h2><p>等价关系:要求集合A上的R关系是自反,对称,传递的.<br />偏序关系:要求集合A上的R关系是自反,反对称,传递的.</p><p>从定义可以知道偏序关系图中不存在双向箭头.</p><h3 id="偏序集和哈斯图"><a class="markdownIt-Anchor" href="#偏序集和哈斯图"></a> 偏序集和哈斯图</h3><p>集合A和A上的偏序关系R被称为偏序集,记为&lt;A,R&gt;.<br />其中有一个很像小于等于号的偏序符号.<br /><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_16-19-23.webp" alt="" /></p><p>突然发现这样要贴上一堆图片,还不如自己翻书,待我之后自己搞懂了整个离散的时候再回来填坑吧.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文根据离散数学简明教程整理,仅为一本一百多页的薄书,但涵盖了大部分概念.&lt;/p&gt;
&lt;h1 id=&quot;集合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#集合&quot;&gt;&lt;/a&gt; 集合&lt;/h1&gt;
&lt;h2 id=&quot;用一个例子搞懂集合运算&quot;&gt;&lt;a class=</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25 cocos模块学习</title>
    <link href="https://revival-of-hope.github.io/2025/12/25/archives-2025-2025-12-25-cocos%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/25/archives-2025-2025-12-25-cocos%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-12-25T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cocos命令"><a class="markdownIt-Anchor" href="#cocos命令"></a> cocos命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143 -DUSE_COCOS_ENGINE=OFF -DBUILD_APP=OFF -DBUILD_TESTS=ON</span><br><span class="line">cmake --build build -j10</span><br><span class="line">ctest --test-dir build --output-on-failure</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143 -DUSE_COCOS_ENGINE=ON -DBUILD_APP=ON -DBUILD_TESTS=OFF</span><br><span class="line">cmake --build build --config Debug -j12</span><br></pre></td></tr></table></figure><p><code>cocos new &lt;项目名&gt;  -l cpp</code><br />当前目录下生成<br /><code>cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143</code><br />在新项目里强制改cmake方式,其中-s指定cmakelists目录,-b指定build生成文件夹名字,-g指定编译器<br /><code>cmake --build build j10</code></p><p>新增加文件时,在cmake里面加入对应的文件路径<br />再运行<code>cmake .</code>就行了<br />resource目录下的文件默认会全部添加,不用改cmakelists,而cpp和头文件需要手动添加,或者换成默认全部添加的代码<br />之后在build文件夹运行cmake …后即可<br />单纯修改文件时会同步修改,不用担心</p><p><code>cmake -S . -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143</code></p><h2 id="概念部分"><a class="markdownIt-Anchor" href="#概念部分"></a> 概念部分</h2><p>精灵:可以理解为人物和物品,是可操作的对象<br />label: 可以理解为字幕,大到开始界面标题,小到物品资源名字,都能用</p><h2 id="初始化部分"><a class="markdownIt-Anchor" href="#初始化部分"></a> 初始化部分</h2><p>写好场景的h文件和cpp文件后,在AppDelegate.cpp里使用并运行</p><h3 id="加载场景"><a class="markdownIt-Anchor" href="#加载场景"></a> 加载场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myScene = Scene::<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//runWithScene() 用于开始游戏，加载第一个场景。只用于第一个场景！</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">runWithScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//replaceScene() 使用传入的场景替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">replaceScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pushScene() 将当前运行中的场景暂停并压入到场景栈中，再将传入的场景设置为当前运行场景。只有存在正在运行的场景时才能调用该方法。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">pushScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//popScene() 释放当前场景，再从场景栈中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">popScene</span>();</span><br></pre></td></tr></table></figure><h2 id="窗口部分"><a class="markdownIt-Anchor" href="#窗口部分"></a> 窗口部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> visibleSize = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleSize</span>();</span><br><span class="line">    <span class="comment">//窗口对角线向量,这个向量可以调用visibleSize.width</span></span><br><span class="line">    <span class="comment">//和visibleSize.height两个子属性</span></span><br><span class="line">    <span class="keyword">auto</span> origin = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleOrigin</span>();</span><br><span class="line">    <span class="comment">//左下角坐标(0,0)</span></span><br></pre></td></tr></table></figure><p>在AppDelegate.cpp下有一行<br /><code>glview = GLViewImpl::createWithRect(&quot;test&quot;, cocos2d::Rect(0, 0, designResolutionSize.width, designResolutionSize.height));</code><br />修改designResolutionSize为其他大小(如largeResolutionSize)即可修改窗口默认大小</p><h2 id="创建部分"><a class="markdownIt-Anchor" href="#创建部分"></a> 创建部分</h2><h3 id="创建元素"><a class="markdownIt-Anchor" href="#创建元素"></a> 创建元素</h3><p><strong>所有创建的精灵和场景,动作都会自动销毁</strong><br /><em>创建精灵</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> child = Sprite::<span class="built_in">create</span>(<span class="string">&quot;Images/test.png&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> mySprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;mysprite.png&quot;</span>, <span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>));</span><br><span class="line"><span class="comment">//可以指定裁剪区域,(0,0)为左上角坐标,大小为200X200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多边形精灵.</span></span><br><span class="line"><span class="keyword">auto</span> pinfo = AutoPolygon::<span class="built_in">generatePolygon</span>(<span class="string">&quot;filename.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sprite with polygon info.</span></span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::<span class="built_in">create</span>(pinfo);</span><br></pre></td></tr></table></figure><p><a href="https://docs.cocos.com/cocos2d-x/manual/zh/sprites/spritesheets.html">还可以使用图集来创建</a></p><p><em>创建label</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> label = Label::<span class="built_in">createWithTTF</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, <span class="number">16.0f</span>);</span><br><span class="line"><span class="keyword">auto</span> label = Label::<span class="built_in">create</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, <span class="number">16.0f</span>);</span><br><span class="line"><span class="comment">//两种方法均可以,下面一种在字体不能正常加载时使用系统字体,那我肯定用下面一种啊</span></span><br></pre></td></tr></table></figure><p><em>创建menu</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最复杂的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建一个image对象</span></span><br><span class="line"><span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(</span><br><span class="line">                                        <span class="string">&quot;CloseNormal.png&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">                                        <span class="built_in">CC_CALLBACK_1</span>(HelloWorld::menuCloseCallback,<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//可以用回调函数,但用lamda表达式更像人类一点,官方例子如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 lambda 表达式作为菜单项的回调函数：</span></span><br><span class="line"><span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(<span class="string">&quot;CloseNormal.png&quot;</span>, <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">[&amp;](Ref* sender)&#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是看不懂的话有以下例子</span></span><br><span class="line"><span class="keyword">auto</span> showPlayerDlgItem = MenuItemImage::<span class="built_in">create</span>(<span class="string">&quot;Images/Pea.png&quot;</span>,</span><br><span class="line">                                               <span class="string">&quot;Images/Pea.png&quot;</span>,</span><br><span class="line">                                               [<span class="keyword">this</span>](Ref* sender)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_playerDlg-&gt;<span class="built_in">setVisible</span>(!<span class="keyword">this</span>-&gt;_playerDlg-&gt;<span class="built_in">isVisible</span>());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//简单说来就是点击这个菜单图片会发生什么</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在用图像来创建菜单</span></span><br><span class="line"><span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem,closeItem2,closeItem3, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//可以一直叠下去</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指定元素位置菜单ui组件通用"><a class="markdownIt-Anchor" href="#指定元素位置菜单ui组件通用"></a> 指定元素位置(菜单,UI组件通用)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(origin.x,origin.y));</span><br><span class="line">child-&gt;<span class="built_in">setPosition</span>(<span class="built_in">vec2</span>(visibleSize/<span class="number">2</span>));</span><br><span class="line"><span class="comment">//两种方法都可以</span></span><br></pre></td></tr></table></figure><p><strong>改变精灵的中心点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DEFAULT anchor point for all Sprites</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom left</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// top left</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom right</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// top right</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="将元素加入指定图层通用"><a class="markdownIt-Anchor" href="#将元素加入指定图层通用"></a> 将元素加入指定图层(通用)</h3><p><code>this-&gt;addChild(child, 1,people);</code></p><blockquote><p>原定义部分<br />void Node::addChild(Node *child, int localZOrder, int tag)</p></blockquote><p>即第一个参数是元素名称,第二个参数是指定图层坐标,第三个参数是标签,<br />后两个均为可选</p><h2 id="动作部分"><a class="markdownIt-Anchor" href="#动作部分"></a> 动作部分</h2><h3 id="旋转"><a class="markdownIt-Anchor" href="#旋转"></a> 旋转</h3><p>通过 setRotation() 方法，设置一个角度值可以控制精灵的旋转，正值精灵顺时针旋转，负值精灵逆时针旋转，默认位置的角度值是 0.0。<br /><code>mySprite-&gt;setRotation(20.0f);</code></p><h3 id="缩放"><a class="markdownIt-Anchor" href="#缩放"></a> 缩放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// increases X and Y size by 2.0 uniformly</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScale</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increases just X scale by 2.0</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScaleX</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increases just Y scale by 2.0</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScaleY</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p><strong>动作中的缩放方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scale uniformly by 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleBy = ScaleBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleBy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale X by 2 and Y by 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleBy = ScaleBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleBy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale to uniformly to 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleTo = ScaleTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale X to 2 and Y to 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleTo = ScaleTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleTo);</span><br></pre></td></tr></table></figure><h3 id="移动"><a class="markdownIt-Anchor" href="#移动"></a> 移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move sprite to position 50,10 in 2 seconds.</span></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">50</span>, <span class="number">10</span>));</span><br><span class="line">mySprite1-&gt;<span class="built_in">runAction</span>(moveTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move sprite 20 points to right in 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">20</span>,<span class="number">0</span>));</span><br><span class="line">mySprite2-&gt;<span class="built_in">runAction</span>(moveBy);</span><br></pre></td></tr></table></figure><p>注意到每个动作都要先创建为对象再用runAction执行</p><p><strong>可以创建一个移动序列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">500</span>, mySprite-&gt;<span class="built_in">getPositionY</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// MoveTo - lets move the new sprite to 300 x 256 over 2 seconds</span></span><br><span class="line"><span class="comment">// MoveTo is absolute - The sprite gets moved to 300 x 256 regardless of</span></span><br><span class="line"><span class="comment">// where it is located now.</span></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">300</span>, mySprite-&gt;<span class="built_in">getPositionY</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delay - create a small delay</span></span><br><span class="line"><span class="keyword">auto</span> delay = DelayTime::<span class="built_in">create</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> seq = Sequence::<span class="built_in">create</span>(moveBy, delay, moveTo, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(seq);</span><br></pre></td></tr></table></figure><p>注意到cocos里面用到数组对象时总要指定最后一位为空指针</p><p>查看源码发现runAction指接收一个参数,也就是说延迟动作只能显示写一个delay对象实现</p><h3 id="色彩混合"><a class="markdownIt-Anchor" href="#色彩混合"></a> 色彩混合</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;mysprite.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tints a node to the specified RGB values</span></span><br><span class="line"><span class="keyword">auto</span> tintTo = TintTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">120.0f</span>, <span class="number">232.0f</span>, <span class="number">254.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(tintTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tints a node BY the delta of the specified RGB values.</span></span><br><span class="line"><span class="keyword">auto</span> tintBy = TintBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">120.0f</span>, <span class="number">232.0f</span>, <span class="number">254.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(tintBy);</span><br></pre></td></tr></table></figure><p>可用于实现药水对兵种的作用效果</p><h2 id="瓦片地图"><a class="markdownIt-Anchor" href="#瓦片地图"></a> 瓦片地图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建地图</span></span><br><span class="line">map=TMXTiledMap::<span class="built_in">create</span>(<span class="string">&quot;test.tmx&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//瓦片处理</span></span><br><span class="line">Size tileSize = map-&gt;<span class="built_in">getTileSize</span>();        <span class="comment">// 单个瓦片像素大小（如 64x64）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放地图</span></span><br><span class="line"><span class="comment">// Step 1: 计算横竖各能放多少个完整瓦片（向下取整）</span></span><br><span class="line"><span class="type">int</span> maxTilesX = (<span class="type">int</span>)(visibleSize.width / tileSize.width);</span><br><span class="line"><span class="type">int</span> maxTilesY = (<span class="type">int</span>)(visibleSize.height / tileSize.height);</span><br><span class="line"><span class="comment">//注意到这里的visiblesize根据需要选择获取全屏还是裁剪掉菜单栏的区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止除零或瓦片太大的情况</span></span><br><span class="line"><span class="keyword">if</span> (maxTilesX &lt;= <span class="number">0</span>) maxTilesX = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (maxTilesY &lt;= <span class="number">0</span>) maxTilesY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 计算两种缩放比例</span></span><br><span class="line"><span class="type">float</span> scaleIfFitWidth = visibleSize.width / (maxTilesX * tileSize.width);</span><br><span class="line"><span class="type">float</span> scaleIfFitHeight = visibleSize.height / (maxTilesY * tileSize.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 选择「宁可裁掉一点地图，也绝不留黑边」的策略 → 取较大值</span></span><br><span class="line"><span class="type">float</span> finalScale = std::<span class="built_in">max</span>(scaleIfFitWidth, scaleIfFitHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 应用缩放 + 严格左上角对齐 + 防1像素缝隙</span></span><br><span class="line">map-&gt;<span class="built_in">setScale</span>(finalScale);</span><br><span class="line">map-&gt;<span class="built_in">setAnchorPoint</span>(<span class="built_in">Vec2</span>(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">// 左上角为锚点</span></span><br><span class="line">map-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(<span class="number">-0.5f</span>, visibleSize.height + <span class="number">0.5f</span>));   </span><br></pre></td></tr></table></figure><p>尽管写了这么多,但最后我还是用AI完成绝大部分代码的,AI的文献阅读能力让期末周的我泪流满面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cocos命令&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cocos命令&quot;&gt;&lt;/a&gt; cocos命令&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-24 病毒攻击</title>
    <link href="https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/</id>
    <published>2025-12-24T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>下了一个破解版游戏,结果火绒直接弹出窗口提示我有三百多个exe感染了jadtre ax 病毒<br /><img src="/images/archives/2025/2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/PixPin_2025-12-24_09-58-14.webp" alt="" /></p><p>到这个时候我才发现我对网络安全实际上是一窍不通,<br />只好先用火绒把所有感染的exe放到隔离区,然后来了一个全盘扫描,我以后一定要好好研究一下计算机的底层知识和病毒攻击原理.</p><p>首先我找到了<a href="https://www.virusview.net/malware/Virus/Win32/Jadtre">计算机病毒百科</a>里关于这个病毒的详细信息</p><blockquote><p>它会修改系统文件，包括操作系统的关键文件，以隐藏自身并且避免被杀软检测到。<br />该病毒会通过劫持用户的浏览器、修改主页和搜索引擎设置等方式，进行钓鱼攻击，诱导用户点击恶意链接，从而进一步传播病毒。<br />它会窃取用户的个人敏感信息，如登录密码、银行账号等，并将这些信息发送到黑客的服务器上。<br />病毒会利用系统的漏洞，进行远程控制，从而盗取用户的隐私信息或者操控计算机进行其他恶意行为。<br />该病毒还会利用系统资源进行挖矿或者进行分布式拒绝服务（DDoS）攻击。<br />它会禁用或损坏杀软程序的功能，以保证自身不被杀软识别和清除。</p></blockquote><p>发现它主要是诱导用户点击恶意链接,还好火绒直接帮我拦截了网页跳转.</p><p>顺藤摸瓜找到了这个<a href="https://www.antiycloud.com/#/antiy/safeinfor">网站</a>,我才发现网络安全确实是一个壁垒高却极为重要的领域,<br />想着在网上找一点入门教程,结果用中文搜全是AI文章或者垃圾文字,再一次体会到中文互联网的封闭性,只好问gpt,找到了以下网站:</p><blockquote><p>By Sunday evening, you could have taken your first real step into cybersecurity.<br />Here are 15 websites to kick-start your cybersecurity journey (all beginner-friendly):<br />1.TryHackMe  – Hands-on labs for all skill levels<br /><a href="https://tryhackme.com">https://tryhackme.com</a><br />2.Hack The Box  – Gamified hacking challenges<br /><a href="https://www.hackthebox.com">https://www.hackthebox.com</a><br />3.Blue Team Labs Online  – Defensive security scenarios<br /><a href="https://lnkd.in/dckAehnQ">https://lnkd.in/dckAehnQ</a><br />4.OverTheWire – Fun war games to learn Linux &amp; networking<br /><a href="https://lnkd.in/d66wAqDb">https://lnkd.in/d66wAqDb</a><br />5.PortSwigger Web Security Academy – Web app hacking from the pros<br /><a href="https://lnkd.in/dyrBGjRh">https://lnkd.in/dyrBGjRh</a><br />6.VulnHub – Download vulnerable machines and hack away<br /><a href="https://www.vulnhub.com">https://www.vulnhub.com</a><br />7.LetsDefend  – SOC analyst simulation<br /><a href="https://letsdefend.io">https://letsdefend.io</a><br />8.CyberDefenders  – Threat hunting and forensics labs<br /><a href="https://cyberdefenders.org">https://cyberdefenders.org</a><br />9.CTFtime – Find Capture the Flag competitions<br /><a href="https://ctftime.org">https://ctftime.org</a><br />10.Security Blue Team  – Blue teaming certifications and practice<br /><a href="https://lnkd.in/dmuUFfQX">https://lnkd.in/dmuUFfQX</a><br />11.PentesterLab – Web security training<br /><a href="https://pentesterlab.com">https://pentesterlab.com</a><br />12.MITRE ATT&amp;CK – Learn real adversary tactics and techniques<br /><a href="https://attack.mitre.org">https://attack.mitre.org</a><br />13.OWASP – Secure coding &amp; app security resources<br /><a href="https://owasp.org">https://owasp.org</a><br />14.DFIR Diva – Free digital forensics resources<br /><a href="https://dfirdiva.com">https://dfirdiva.com</a><br />15.Flare-On Challenges – Reverse engineering practice<br /><a href="https://flare-on.com">https://flare-on.com</a></p></blockquote><blockquote><p><a href="https://github.com/404notf0und/Security-Data-Analysis-and-Visualization">找到了一个汇总链接</a><br />不多说了,尽管期末周快来了,兴趣学习的时间还是有的,开练.</p></blockquote><hr /><p><strong>25号更新</strong><br />一开始我觉得这个病毒没什么危害性,就又把火绒隔离区里的exe给恢复了,现在发现我确实是智障,今晚扫描全盘发现基本所有的exe文件都被感染了,<br />里面有几百款游戏exe和工具exe,受不了了,太蠢了这也.我决定不再点击恢复文件,只能把这些文件全部删掉了.<br />好的,这下真的激发我对网络安全的兴趣了,做病毒真有这么好玩吗(😡)</p><p>这件事还让我看到火绒并不好用,虽然平时没什么弹窗打扰我,但是一但出事一点都救不了我.<br />病急乱投医,我甚至下载了360来试试,果不其然,连安装页面都没弹出来,就已经在修改我的注册表了,去你的吧!</p><p>然后看了看别人的推荐,又综合了各种考虑,先拿卡巴斯基来试试全盘扫描,竟然要花9个小时多.</p><p><strong>26号更新</strong><br />今天早上来看,发现问题并没有那么严重,大多数都是火绒的误报,我把那些隔离区里的exe上传到<a href="https://internxt.com/virus-scanner">文件病毒检测网站</a>里发现根本没有病毒,受不了了.而卡巴斯基也成功地把那些真正的病毒删除干净了,滚吧您呐,让我投入卡巴斯基的怀抱吧!</p><h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3><p><a href="https://iliu.org/thoughts-on-struggling-with-antivirus-software/">1</a><br /><a href="https://meledee.com/2025/03/4617.html">2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下了一个破解版游戏,结果火绒直接弹出窗口提示我有三百多个exe感染了jadtre ax 病毒&lt;br /&gt;
&lt;img src=&quot;/images/archives/2025/2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/PixP</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-24 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-24T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/">来源</a><br />我是一个习惯于早做规划与反复思索的人。<br />而坚持写博客最大的好处就是，可以时不时翻看之前写的文章，宛若跨越时间的荆棘，与曾经的自己促膝长谈。</p></blockquote><blockquote><p>现在想来，十九岁时，我的迷惘归结下来，即是对将来自己的出路无所适从：出国留学，国内升学，抑或是早日进入职场。这几条路上，都有前人留下的无数足迹与丰碑，但也无可避免地悬着前人用泪水濯洗的种种失败警示牌。我曾尝试从中选出最优解，然而反复的纠结过后，我所意识到的，是这种比较的注定无结果：每当我觉得某个选择优于其他选择时，总会有某些信息刷新我的认知，让我匆忙撤回自己的决定。一如盲人同时摸象与鲸鱼，用片面的认知去比较复杂的事物，注定失败。</p></blockquote><blockquote><p>先是出国。关于这个选项，我曾仔细考虑，然而最终出于经济上的原因（赴美读硕开销实在过于昂贵）和人生规划的原因（<strong>我对学术无甚兴趣，不愿耗费多年去追求博士学位</strong>），出国成为了三者中第一个被排除的选项。而站在当下（2020 年）来看，全球疫情的扩散与民族主义情绪的对立，出国虽然依旧有着不可抗拒的诱惑力（比如优渥的学术环境与工作环境），但是更显得充满了极度未知的不确定性。</p></blockquote><blockquote><p>「选择比努力更重要。」这句话近年来已经广为人知，不少人以此自我调侃，感叹自己当初选择的失误（比如选错学校、选错专业），但当下一次选择到来时，却又不假思索地下意识地站到了主流的人群中，甚至拼尽全力挤出一条道路以加入主流人群。</p><p>诚然，作为一个才识普通的人，我或许不具备选择最合适的道路的能力，但我所希望的，是不盲从、不追随，依靠自身的观察与思考，尽量选出一条相对合适的道路。<br />人类的悲欢并不相通，但是相似。</p><p>关于读研与工作，面临同样困扰的也并非只有我一个人。</p><p>在做出决定的过程中，我阅读了不少人的博客与帖子，从中获得了一些宝贵的信息与经验，或多或少地影响了我最终的决定。</p><p>由于之前并未刻意保存浏览过的网页，在此，仅仅列出其中的一小部分：</p></blockquote><ul><li><a href="https://laike9m.com/blog/suo-yi-dao-di-yao-bu-yao-du-yan,119/">所以，到底要不要读研？ - laike9m’s blog</a></li><li><a href="http://gaocegege.com/Blog/%E9%9A%8F%E7%AC%94/master">研究生复盘 | 高策</a></li><li><a href="https://ipotato.me/article/65">iPotato | 在读研 &amp; 工作中选择后者</a></li><li><a href="https://www.v2ex.com/t/580275">已有名校 CS 本科学历，读研对于计算机行业的职业发展有多大的意义？ - V2EX</a></li></ul><p>这恰恰是我当下迷惘而又感到无路可走的心境,专业课程的枯燥与无用让我感到厌烦,愈加激烈的保研争夺战让我望而却步,而那些学术论文里面的水分都可以让海平面再升高一米了.</p><p>可日愈恶化的工作环境阻断了我得过且过的想法,作为雏鸟在第一家公司所学习的架构未必对我的技术提升有任何的助益,而我的学历劣势也将在很长一段时间内保持下去.</p><p>这种左右为难的状况让我一边痛苦一边踟蹰,只好到处翻阅博客,搜寻资源,希望能够对当前的我有些微的救赎.</p><p>这篇博客可惜的地方在于没有考虑到提前工作的坏处,但看了看他<a href="https://www.zackwu.com/posts/2025-11-26-think-long-term-and-work-hard/">最近的文章</a>,过得还算不错,可我现在还没有那个胆量去直接放弃保研,因为我讨厌唯一的选择,希望能多几条路可以走,而现在我仅仅是在本专业保研排名的边缘上(笑).这解释为是对我自己负责,但更可能只是我胆小罢了.</p><h2 id="题外话"><a class="markdownIt-Anchor" href="#题外话"></a> 题外话:</h2><p>博客是我最喜欢的信息传播方式,我永远都可以在某个博客里找到一些用一般手段怎么搜都搜不到的棘手问题的解决方案,永远都可以找到一个处境和你相似的人,永远都可以找到能够为你指引道路的人.</p><p>这半年来我搜集了差不多一百多个博客,我打算之后整理一下把里面的精华部分传到GitHub上,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/&quot;&gt;来源&lt;/a&gt;&lt;br /&gt;
我是一个习惯于早做规划与反复思索的人。&lt;br</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-21 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/21/archives-2025-2025-12-21-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/21/archives-2025-2025-12-21-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-21T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li></li></ol></blockquote><p><a href="https://ruanyf-weekly.vercel.app/weekly/issue-210">周刊210期</a><br />诺拉·劳森还说了一个观点。大家通常认为，复杂系统往往会在经济繁荣的时候崩溃，因为业务太多，支撑不过来，但他认为不是这样的，系统崩溃往往发生在经济收缩期。<br />经济繁荣时期，软件公司会大量雇佣新员工，投入更多的财力和人力，支撑复杂系统。等到经济收缩期，公司开始减少投入、冻结招聘或裁员，复杂系统可能就会在这个时候出问题，变得难以维护。<br />现在就是经济收缩期，那么接下来，会不会就是软件故障的高发期，我们将看到很多复杂系统的崩溃？</p><blockquote><ol start="2"><li></li></ol></blockquote><p>IT 行业与传统制造业有一个重要区别，就是 IT 行业有着严重的垄断。<br />全世界的智能手机有70亿部，比汽车多出5倍（14亿辆）。但是，智能手机制造商比汽车制造商少了好几个数量级。搜索引擎、社交网络、操作系统都是这样，几个巨头就垄断了整个市场。</p><blockquote><p>3.<a href="https://blog.amamiyayuuko.com/p/ai-new-bing/">来源</a><br />各个互联网公司都试图把自己的网站做成一个完全封闭的APP，你没法在搜索引擎上搜索到微信公众号的文章、小红书的内容、淘宝的商品描述……这就导致bing只能从非常有限的地方获得中文语料，最后就导致他的回答特别池沼……而且比别的AI都池沼十倍甚至九倍……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ruanyf-weekly.vercel.app/weekly/issue-210&quot;&gt;周刊210期&lt;/a&gt;&lt;br /&gt;
诺拉·劳森还说了一个观点</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>重要文章存档</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-20T02:58:05.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cpp构造与析构"><a class="markdownIt-Anchor" href="#cpp构造与析构"></a> <a href="https://blog.csdn.net/2501_91275995/article/details/156042381">cpp构造与析构</a></h2><h2 id="校招流程"><a class="markdownIt-Anchor" href="#校招流程"></a> <a href="https://www.zackwu.com/posts/2020-10-05-an-incomplete-guide-to-campus-recruitment-interviews/">校招流程</a></h2><h2 id="还是校招"><a class="markdownIt-Anchor" href="#还是校招"></a> <a href="https://blog.cugxuan.cn/2021/01/06/Campus/guide-capmus-v2/">还是校招</a></h2><h2 id="微软实习"><a class="markdownIt-Anchor" href="#微软实习"></a> <a href="https://ddadaal.me/articles/2019-spring-ms-intern-interview-experiences">微软实习</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cpp构造与析构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cpp构造与析构&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://blog.csdn.net/2501_91275995/article/details/156042381&quot;</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-20 数据结构重点例题分析</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/</id>
    <published>2025-12-20T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="稀疏矩阵的三元组表"><a class="markdownIt-Anchor" href="#稀疏矩阵的三元组表"></a> 稀疏矩阵的三元组表</h2><p>三元组表需要把行,列,值分别列出来(意义在哪里?)<br /><img src="images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image.webp" alt="" /></p><p>甚至还要再写辅助数组rowSize和rowStart,把很明显的东西再写一遍,却又不考算法,没招了.</p><h2 id="链表反转"><a class="markdownIt-Anchor" href="#链表反转"></a> 链表反转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    LNode* q;</span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;   <span class="comment">// 断开头结点与原链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;      <span class="comment">// 保存后继</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;      <span class="comment">// 头插</span></span><br><span class="line">        p = q;            <span class="comment">// 处理下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴下代码就能看懂了,其实我觉得就是两端交换</p><h2 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h2><p><a href="https://www.cnblogs.com/Higurashi-kagome/p/18013626">参考1</a><br /><a href="https://www.xdull.cn/kmp.html">参考2</a><br />都讲的挺好.</p><p>重点是明确next数组的作用,之所以存储模式的对应字串最长公共前后缀,是因为当匹配失败时,原字符串中在匹配失败位置前的成功匹配部分刚好可以作为重置后的模式字符串的前缀,它同时也是先前匹配时得到对应长度模式字串的后缀.搞懂了这个就能彻底理解kmp了.</p><blockquote><p>例题: 设主串T=”abaabaabcabaabc”，模式串P=”abaabc”，采用KMP算法进行模式匹配，到匹配成功为止，在匹配过程中进行的单个字符间的比较次数是（ ）.</p></blockquote><blockquote><p>解题: int num=0,<br />先写出next数组[0,0,1,1,2,0],第一次匹配到abaab,num+=5,但由于失败的匹配也要算上,num+=1<br />指针移到后缀ab,接着比较找到abaabc,num+=4,故num=10</p></blockquote><h2 id="组合数求解"><a class="markdownIt-Anchor" href="#组合数求解"></a> 组合数求解</h2><blockquote><p>【例4】编写一个递归算法，找出从自<br />然数1,2,3,4,…,n中任取r个数的所有组<br />合。例如，n=5，r=3时的组合是543，<br />542，541，532，531，521，432，431<br />，421，321.</p><p>【解答】本问题就是求解组合数。<br />int Combin(int m, int n)<br />{ if(m<mark>n||n</mark>0) return 1;<br />else return Combin(m-1,n)+<br />Combin(m-1,n-1);}</p></blockquote><p>一开始是用dfs写的,但没想到ppt里根本没考虑把组合写出来,不过这个递归也挺难想到的.</p><h2 id="广义表"><a class="markdownIt-Anchor" href="#广义表"></a> 广义表</h2><blockquote><p>假设广义表是由带头节点的链<br />表存储，请画出广义表A(a, B((),<br />C(1)))的存储结构；假设head，tail分<br />别是求首元素操作和求尾表操作，求<br />如何获得元素1.</p></blockquote><p><img src="images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image2.webp" alt="解答" /><br />其中,一个结点的定义如下:</p><blockquote><p>utype = 0/1/2/3 ;<br />value = ref /intgrinfo /charinfo / hlink ;tlink</p></blockquote><p>0表示该节点为头节点,1表示为整数,2表示为char,3表示为子表节点,∧表示该节点为尾节点,指向该子表头节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GenList :: <span class="built_in">depth</span> ( GenListNode *ls ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ls→tlink == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//空表</span></span><br><span class="line">GenListNode *temp = ls→tlink;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( temp != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> <span class="comment">//横扫广义表</span></span><br><span class="line"><span class="keyword">if</span> ( temp→utype == LST ) &#123;</span><br><span class="line"> <span class="comment">//子表深度</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">depth</span> ( temp→value.hlink );</span><br><span class="line"><span class="keyword">if</span> ( m &lt; n ) m = n;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//不是子表不加深度</span></span><br><span class="line">temp = temp→tlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉链的应用"><a class="markdownIt-Anchor" href="#二叉链的应用"></a> 二叉链的应用</h2><blockquote><p>假设二叉树采用二叉链存储，设计一个算法Level()求二叉树中值为 x 的节点的层数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Level</span><span class="params">(BiNode *T, <span class="type">int</span> x, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) <span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">Level</span>(T-&gt;lchild, x, level + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (l) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Level</span>(T-&gt;rchild, x, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树与森林典型例题"><a class="markdownIt-Anchor" href="#二叉树与森林典型例题"></a> 二叉树与森林典型例题</h2><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-34-19.webp" alt="题目" /></p><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-35-26.webp" alt="解答" /></p><h2 id="静态搜索表的应用"><a class="markdownIt-Anchor" href="#静态搜索表的应用"></a> 静态搜索表的应用</h2><h3 id="顺序搜索"><a class="markdownIt-Anchor" href="#顺序搜索"></a> 顺序搜索</h3><p><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-12-10.webp" alt="不能写个循环吗急死我了" /><br />还装模做样加一个概念ASL(Average Search Length)<br /><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-13-47.webp" alt="" /><br /><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-25_10-52-23.webp" alt="公式" /></p><h3 id="折半搜索"><a class="markdownIt-Anchor" href="#折半搜索"></a> 折半搜索</h3><p><img src="../images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-27_12-34-38.webp" alt="代码" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;稀疏矩阵的三元组表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#稀疏矩阵的三元组表&quot;&gt;&lt;/a&gt; 稀疏矩阵的三元组表&lt;/h2&gt;
&lt;p&gt;三元组表需要把行,列,值分别列出来(意义在哪里?)&lt;br /&gt;
&lt;img src=&quot;images/ar</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>我遇到的各种调试问题</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-19T01:58:56.000Z</published>
    <updated>2026-01-01T05:51:44.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode-powershell终端打字缺字漏字"><a class="markdownIt-Anchor" href="#vscode-powershell终端打字缺字漏字"></a> vscode powershell终端打字缺字漏字</h2><p>解决方法:<br />搜索设置<br />Terminal &gt; Integrated &gt; Default Profile: Windows<br />换为cmd</p><h2 id="左斜线和右斜线问题"><a class="markdownIt-Anchor" href="#左斜线和右斜线问题"></a> 左斜线和右斜线问题</h2><p>windows路径都是,转义符是,而网页链接,linux都是/<br />解决方法:<br />在搜索框输入：“Explorer: Copy Relative Path Separator”<br />将\改为正斜杠/<br /><a href="https://blog.csdn.net/kdz6511/article/details/148712726">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vscode-powershell终端打字缺字漏字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vscode-powershell终端打字缺字漏字&quot;&gt;&lt;/a&gt; vscode powershell终端打字缺字漏字&lt;/h2&gt;
&lt;p&gt;解决方</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-19 数据结构整理-(图论)</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/</id>
    <published>2025-12-19T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="邻接矩阵和邻接表"><a class="markdownIt-Anchor" href="#邻接矩阵和邻接表"></a> 邻接矩阵和邻接表</h2><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_08-07-22.webp" alt="邻接矩阵图示" /><br />时间复杂度:O(n*n)<br /><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_08-37-15.webp" alt="无向图邻接表" /><br /><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_08-38-48.webp" alt="有向图邻接表" /></p><h3 id="邻接表的遍历"><a class="markdownIt-Anchor" href="#邻接表的遍历"></a> 邻接表的遍历</h3><p><strong>bfs</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxConnectedComponent</span><span class="params">(Graph&amp; g)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = g.n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> max_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; q = &#123;i&#125;;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; q.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="type">int</span> u = q[j];</span><br><span class="line">                ++size;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : g.adj[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                        visited[v] = <span class="literal">true</span>;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            max_size = <span class="built_in">max</span>(max_size, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dfs</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;  <span class="comment">// 当前结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">            cnt += <span class="built_in">dfs</span>(v, adj, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxConnectedComponent</span><span class="params">(<span class="type">int</span> n, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="type">int</span> size = <span class="built_in">dfs</span>(i, adj, visited);</span><br><span class="line">            <span class="keyword">if</span> (size &gt; maxSize)</span><br><span class="line">                maxSize = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用visited数组来保证取到所有的连通分量,从而找到最大连通分量<br />时间复杂度:O(n+e)</p><h2 id="bfs搜索"><a class="markdownIt-Anchor" href="#bfs搜索"></a> bfs搜索</h2><p>特点:使用队列,可以得到最短路径,无论是否会重复访问,都能一个节点一直是最优状态.<br />写法:<br /><strong>以大佬的八数码解法为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//转移数组；</span></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    map&lt;ll,ll&gt; m;</span><br><span class="line">    m[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); <span class="comment">//初始状态入队列</span></span><br><span class="line">        <span class="type">int</span> c[<span class="number">3</span>][<span class="number">3</span>],f=<span class="number">0</span>,g=<span class="number">0</span>,n=u;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">123804765</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=n%<span class="number">10</span>,n/=<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(!c[i][j])f=i,g=j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll nx=f+dx[i],ny=g+dy[i],ns=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||ny&lt;<span class="number">0</span>||nx&gt;<span class="number">2</span>||ny&gt;<span class="number">2</span>)<span class="keyword">continue</span>; <span class="comment">//越界就不执行</span></span><br><span class="line">            <span class="built_in">swap</span>(c[nx][ny],c[f][g]);</span><br><span class="line">            <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">                <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)ns=ns*<span class="number">10</span>+c[i][j];<span class="comment">//矩阵转数列 </span></span><br><span class="line">            <span class="keyword">if</span>(!m.<span class="built_in">count</span>(ns))</span><br><span class="line">            &#123;</span><br><span class="line">                m[ns]=m[u]<span class="number">+1</span>;<span class="comment">//map去重的同时顺便统计到达这个状态所需的步数</span></span><br><span class="line">                q.<span class="built_in">push</span>(ns);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(c[nx][ny],c[f][g]);<span class="comment">//状态复原</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m[<span class="number">123804765</span>]&lt;&lt;endl; <span class="comment">// map的下标直接用数列表示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dfs搜索"><a class="markdownIt-Anchor" href="#dfs搜索"></a> dfs搜索</h2><p>特点:有时候会使用栈,可以得到方案总数,有次数要求时使用这个方法.<br />写法:<br /><strong>以最经典的八皇后问题为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> col[N], d1[N], d2[N];  <span class="comment">// 列、主对角线、副对角线标记</span></span><br><span class="line"><span class="type">int</span> pos[N];                <span class="comment">// pos[x] = 皇后在第 x 行放的列号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                cout &lt;&lt; pos[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[c] || d1[row + c] || d2[row - c + n]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        col[c] = d1[row + c] = d2[row - c + n] = <span class="number">1</span>;</span><br><span class="line">        pos[row] = c;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        col[c] = d1[row + c] = d2[row - c + n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到,无论是dfs还是bfs,重点是将当前状态判定后再重置状态,保证后来的方案不会受到这次修改影响.</p><h2 id="dfs解疑"><a class="markdownIt-Anchor" href="#dfs解疑"></a> dfs解疑</h2><p>dfs有两种结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll sum)</span> </span>&#123;  <span class="comment">// 前一半</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">push_back</span>(sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(l<span class="number">+1</span>, r, sum);        <span class="comment">// 不选</span></span><br><span class="line">    <span class="built_in">dfs1</span>(l<span class="number">+1</span>, r, sum + a[l]);  <span class="comment">// 选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就像背包问题,一般都能用动态规划解决,每一步都只有两个分支</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在每一步都有多个选择</span><br></pre></td></tr></table></figure><p>(突然发现下面这部分期末不考算法,懒得挂代码上来了)<br />(第二次复习时需要画图补充)</p><h2 id="最小生成树算法"><a class="markdownIt-Anchor" href="#最小生成树算法"></a> 最小生成树算法</h2><h3 id="kruskal"><a class="markdownIt-Anchor" href="#kruskal"></a> kruskal</h3><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_09-33-05.webp" alt="" /><br />模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; other.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用lamda或许更好,这个重载太难理解了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5005</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">e</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按边权排序</span></span><br><span class="line">    <span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 已加入 MST 的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kruskal,用引用更安全</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ed : e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(ed.u) != <span class="built_in">find</span>(ed.v))&#123;</span><br><span class="line">            <span class="built_in">unite</span>(ed.u, ed.v);</span><br><span class="line">            ans += ed.w;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt != n - <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz\n&quot;</span>; <span class="comment">// 图不连通</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是用避圈法,难点是确保不形成圈,<br />用并查集来处理这我自己真想不出来,拿ai生成的我也不好意思在luogu上提交.<br />由于还是看不太懂,于是我用ai做了一个网页.</p><details><summary>点击展开 Kruskal 最小生成树演示</summary><p>下面是 Kruskal 最小生成树演示：</p><!-- Canvas 和按钮 --><canvas id="graphCanvas" width="600" height="400" style="border:1px solid #ccc;"></canvas><div style="margin-top:10px;">  <button id="nextStep">下一步</button>  <button id="reset">重置</button>  <span id="mstSum" style="margin-left:20px;">当前 MST 总权值: 0</span></div><script>// ------------------- 数据 -------------------const nodes = [  {id:0,x:100,y:100},{id:1,x:300,y:100},{id:2,x:500,y:100},  {id:3,x:200,y:300},{id:4,x:400,y:300}];const edges = [  {u:0,v:1,w:2},{u:0,v:3,w:3},{u:1,v:2,w:4},  {u:1,v:3,w:2},{u:2,v:4,w:1},{u:3,v:4,w:3}];// ------------------- Canvas 绘图 -------------------const canvas = document.getElementById('graphCanvas');const ctx = canvas.getContext('2d');function drawGraph(highlightEdge=null, skip=false) {  ctx.clearRect(0,0,canvas.width,canvas.height);  edges.forEach(e => {    const n1 = nodes[e.u], n2 = nodes[e.v];    if(e === highlightEdge){ ctx.strokeStyle = skip?'#aaa':'red'; ctx.lineWidth = 4; }    else if(e.inMST){ ctx.strokeStyle = 'green'; ctx.lineWidth = 3; }    else { ctx.strokeStyle = '#ccc'; ctx.lineWidth = 2; }    ctx.beginPath(); ctx.moveTo(n1.x,n1.y); ctx.lineTo(n2.x,n2.y); ctx.stroke();    const mx = (n1.x+n2.x)/2, my=(n1.y+n2.y)/2;    ctx.fillStyle='black'; ctx.font='14px sans-serif';    ctx.fillText(e.w,mx+5,my-5);  });  nodes.forEach(n => {    ctx.beginPath(); ctx.arc(n.x,n.y,15,0,Math.PI*2);    ctx.fillStyle='#fff'; ctx.fill();    ctx.strokeStyle='#000'; ctx.stroke();    ctx.fillStyle='black'; ctx.fillText(n.id,n.x-5,n.y+5);  });}// ------------------- 并查集 -------------------let parent = nodes.map(n=>n.id);function find(u){ return parent[u]===u ? u : (parent[u]=find(parent[u])); }function unite(u,v){ parent[find(u)] = find(v); }// ------------------- Kruskal -------------------edges.sort((a,b)=>a.w-b.w);let step=0;let mstSum = 0;document.getElementById('nextStep').onclick = function(){  if(step >= edges.length) return;  const e = edges[step];  let skip = false;  if(find(e.u) !== find(e.v)){    unite(e.u,e.v); e.inMST = true; mstSum += e.w;  } else skip = true;  drawGraph(e, skip);  document.getElementById('mstSum').textContent = "当前 MST 总权值: " + mstSum;  step++;}document.getElementById('reset').onclick = function(){  step = 0;  parent = nodes.map(n=>n.id);  edges.forEach(e=>e.inMST=false);  mstSum = 0;  drawGraph();  document.getElementById('mstSum').textContent = "当前 MST 总权值: " + mstSum;}// 初始化drawGraph();</script></details><h3 id="prim算法"><a class="markdownIt-Anchor" href="#prim算法"></a> prim算法</h3><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_09-43-39.webp" alt="" /><br />写<a href="https://www.luogu.com.cn/problem/P1194">P1194</a>的时候脑袋卡壳了,怎么都想不出如何得到和更新当前的最小代价<br />于是问了ai,发现还有prim算法可以用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> k[MAX][MAX];</span><br><span class="line"><span class="type">int</span> dist[MAX];</span><br><span class="line"><span class="type">bool</span> vis[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入代价矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">            cin &gt;&gt; k[i][j];</span><br><span class="line">            <span class="comment">// 如果通过别人得到比直接买还贵，直接舍弃</span></span><br><span class="line">            <span class="keyword">if</span> (k[i][j] &gt; a||k[i][j]==<span class="number">0</span>) k[i][j] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        dist[i] = a;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim 主循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mn = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找当前未加入生成树、代价最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dist[j] &lt; mn) &#123;</span><br><span class="line">                mn = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入生成树</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans += dist[u];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 u 更新其他点的最小代价</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= b; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                dist[v] = <span class="built_in">min</span>(dist[v], k[u][v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实好理解不少,可以看出来prim是点驱动的,每次找到代价最小的点,起点任意选择;<br />而kruskal是边驱动的,每次找到代价最小的不成环边,起点选最小边.</p><h2 id="最短路径算法"><a class="markdownIt-Anchor" href="#最短路径算法"></a> 最短路径算法</h2><h3 id="会画图就行dijkstra"><a class="markdownIt-Anchor" href="#会画图就行dijkstra"></a> (会画图就行)Dijkstra</h3><h4 id="证明"><a class="markdownIt-Anchor" href="#证明"></a> 证明</h4><p><a href="https://gallery.selfboot.cn/zh/algorithms/dijkstra">极好的证明</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 归纳基础：k = 1 时，T 中只包含起点 s，dist[s] = short[s] = 0，因此命题在 k = 1 时成立。</span><br><span class="line"></span><br><span class="line">2. 归纳假设：假设命题在第 k 步时成立，即 T 中所有节点的 dist 值都是最短路径长度。</span><br><span class="line"></span><br><span class="line">3. 归纳步骤：证明第 k+1 步时命题也成立：</span><br><span class="line"></span><br><span class="line">设第 k+1 步选择的节点为 v（v 是未访问节点中 dist 值最小的）；v 与集合 T 中的某个节点 u 相连；</span><br><span class="line">需要证明：dist[v] = short[v]。</span><br><span class="line">这里用反证法：</span><br><span class="line"></span><br><span class="line">假设存在一条从起点 s 到 v 的路径 P，其长度是 short[v]，且 short[v] &lt; dist[v]。</span><br><span class="line">由于起点 s 在集合 T 中，而终点 v 不在集合 T 中，路径 P 必然至少经过一个集合 T 中的节点（除起点外）。因为起点 s 到任何不在 T 中节点的距离，都是通过 T 中的节点来计算和更新的。</span><br><span class="line">设路径 P 上最后一个在集合 T 中的节点为 last，之后经过未访问集合中的节点 y 最终到达 v；下面看路径 P 的长度计算：</span><br><span class="line">  short[v] = dist[last] + distance[last,y] + distance[y,v]  // 路径 P 的长度</span><br><span class="line">           ≥ dist[y] + distance[y,v]                        // 根据 dist[y] 的更新规则</span><br><span class="line">           ≥ dist[v]      </span><br><span class="line">要理解下面这两个点才能明白上面的推导：</span><br><span class="line">首先由归纳假设，到达 last 的距离 dist[last] 是最短的；对于节点 y，根据 Dijkstra 算法的更新规则：dist[y] ≤ dist[last] + distance[last,y]</span><br><span class="line"></span><br><span class="line">又因为算法第 k+1 步选择了 v 作为当前最小距离节点，所以 dist[v] ≤ dist[y] + distance[y,v]。</span><br><span class="line">于是就推导出 short[v] &gt;= dist[v]，这和我们的假设 short[v] &lt; dist[v] 矛盾，因此假设不成立，dist[v] 就是从起点到 v 的最短路径长度。这也证明了算法每一步选择的节点的距离都是最短路径长度。</span><br></pre></td></tr></table></figure><p>这个归纳证明直接讲明白了算法的核心步骤,每次取未vis的最短路后更新其他未vis的最短路,直到遍历完所有节点就可以了</p><h4 id="画图"><a class="markdownIt-Anchor" href="#画图"></a> 画图</h4><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_09-54-09.webp" alt="" /><br />这里的path记录的是最短路径上的前驱节点</p><h3 id="不考floyd"><a class="markdownIt-Anchor" href="#不考floyd"></a> (不考)floyd</h3><p>重点是确认初始状态,之后将所有点遍历作为中间点更新最短路径,写一个三重循环,可得到任意两点之间的最短路径.<br />可以看出来floyd更为通用,dijkstra只能得到单源最短路径</p><h2 id="aov网络"><a class="markdownIt-Anchor" href="#aov网络"></a> aov网络</h2><h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h3><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-30_09-03-33.webp" alt="方法" /><br /><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-30_09-11-51.webp" alt="例题" /><br /><strong>算法</strong></p><h4 id="zheng"><a class="markdownIt-Anchor" href="#zheng"></a> zheng</h4><h2 id="aoe网络"><a class="markdownIt-Anchor" href="#aoe网络"></a> aoe网络</h2><h3 id="关键路径"><a class="markdownIt-Anchor" href="#关键路径"></a> 关键路径</h3><p><a href="https://blog.csdn.net/ROBOT_a/article/details/147289874">讲的最清楚</a></p><blockquote><p>关键路径所经过的结点的最迟发生时间和最早发生时间是一致的。如果不好理解的话，打个比方，比如小组作业中，有个同学做的特别慢（关键路径）。所有人同时开始做，其他组员都做完了，他还没有做完，而小组只有等所有人都做完才能上交作品，那么完成小组作业所需的总时间就取决于他的时间。为了不拖后腿，对于他来说，他所做的n个事情就没有“最早什么时候做”“最晚什么时候做”这个说法，而是要马不停蹄地一直做。其他组员则可以选择早一点或晚一点做，只要不比他（关键路径）慢就行。<br />————————————————<br />版权声明：本文为CSDN博主「木卫三上的下午茶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br />原文链接：<a href="https://blog.csdn.net/ROBOT_a/article/details/147289874">https://blog.csdn.net/ROBOT_a/article/details/147289874</a></p></blockquote><p>这个解释非常妙,让我一下看懂了.</p><p>关键是先求每个节点的最早发生时间和最迟发生时间,<br />再根据节点反推边对应事件的最早发生时间和最迟发生时间,相减得到差额,等于0的就是关键路径所经过的边.<br />需要明确的是递推方向,最早从前往后推,最迟从后往前推,节点和事件都是这样.<br />(到处搜资料还是没看懂,一翻到这篇文章就看懂了)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;邻接矩阵和邻接表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#邻接矩阵和邻接表&quot;&gt;&lt;/a&gt; 邻接矩阵和邻接表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../images/archives/2025/2025-12-19-%E6%95%B0</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18 触动过我的文章</title>
    <link href="https://revival-of-hope.github.io/2025/12/18/dynamic-2025-12-18-%E8%A7%A6%E5%8A%A8%E8%BF%87%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/18/dynamic-2025-12-18-%E8%A7%A6%E5%8A%A8%E8%BF%87%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-18T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十年前的实习面试"><a class="markdownIt-Anchor" href="#十年前的实习面试"></a> <a href="https://zhuanlan.zhihu.com/p/117315093">十年前的实习面试</a></h3><h3 id="疫情求职"><a class="markdownIt-Anchor" href="#疫情求职"></a> <a href="https://juejin.cn/post/7180678820796563516?searchId=20251125151954D8EF0E1FE1D09C7C0330">疫情求职</a></h3><h3 id="github-stars-wont-pay-your-rent"><a class="markdownIt-Anchor" href="#github-stars-wont-pay-your-rent"></a> <a href="https://www.kitze.io/posts/github-stars-wont-pay-your-rent">github-stars-wont-pay-your-rent</a></h3><h3 id="git考古"><a class="markdownIt-Anchor" href="#git考古"></a> <a href="https://blog.brachiosoft.com/">git考古</a></h3><h3 id="速通日语"><a class="markdownIt-Anchor" href="#速通日语"></a> <a href="https://galgame.dev/topic/639/%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%80%E5%B9%B4%E4%B8%8D%E5%88%B0%E9%80%9F%E9%80%9An1%E8%BF%99%E4%BB%B6%E4%BA%8B-%E5%9F%BA%E4%BA%8E%E5%95%83%E7%94%9F%E8%82%89galgame%E7%9A%84%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/8">速通日语</a></h3><h3 id="加拿大体验"><a class="markdownIt-Anchor" href="#加拿大体验"></a> <a href="https://ramsayleung.github.io/zh/post/2024/%E7%99%BB%E9%99%86%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/">加拿大体验</a></h3><h3 id="日本游记"><a class="markdownIt-Anchor" href="#日本游记"></a> <a href="https://nekonull.me/archive/2310-jp-travel/">日本游记</a></h3><h3 id="python的问题"><a class="markdownIt-Anchor" href="#python的问题"></a> <a href="https://www.dongwm.com/post/be-a-gopher/">python的问题</a></h3><h3 id="my-solopreneur-story-zero-to-45kmo-in-2-years"><a class="markdownIt-Anchor" href="#my-solopreneur-story-zero-to-45kmo-in-2-years"></a> <a href="https://news.tonydinh.com/p/my-solopreneur-story-zero-to-45kmo">My solopreneur story: zero to $45K/mo in 2 years</a></h3><h3 id="肮脏的交易"><a class="markdownIt-Anchor" href="#肮脏的交易"></a> <a href="https://www.mooreslawisdead.com/post/sam-altman-s-dirty-dram-deal">肮脏的交易</a></h3><h3 id="十年学会编程"><a class="markdownIt-Anchor" href="#十年学会编程"></a> <a href="http://daiyuwen.freeshell.org/gb/misc/21-days-cn.html">十年学会编程</a></h3><h3 id="契诃夫分析"><a class="markdownIt-Anchor" href="#契诃夫分析"></a> <a href="https://mhperng.blogspot.com/2025/12/anton-chekhov.html">契诃夫分析</a></h3><h3 id="软件开发经验"><a class="markdownIt-Anchor" href="#软件开发经验"></a> <a href="https://cloud.tencent.com/developer/article/1004735">软件开发经验</a></h3><h3 id="保研与工作"><a class="markdownIt-Anchor" href="#保研与工作"></a> <a href="https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/">保研与工作</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;十年前的实习面试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#十年前的实习面试&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://zhuanlan.zhihu.com/p/117315093&quot;&gt;十年前的实习面试&lt;/a&gt;&lt;/h3&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/18/archives-2025-2025-12-18-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/18/archives-2025-2025-12-18-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-18T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://exquora.thoughtstorms.info/"></a></p><p>我对 Quora 上瘾，情不自禁使用这个网站。那里有一些很棒的问题和讨论，激发了我的灵感和想法。</p><p>但是当我重新阅读自己写的答案，一方面欣赏我的修辞和洞察力，另一方面也看到了很多想法可以成长为更大的成果。它们本可能进一步发展为软件、文章、论文、创业公司、书籍或社会运动，但任何事都没有发生。</p><p>不仅如此，还有许多篇我写的长篇大论已经无关紧要，沦为了废文。还有很多我花了好几个小时写的评论，试图说服对于这些问题永远不可能改变观点的那些读者。</p><p>我花了数千（也许是数万）小时在 Quora 上写作。我写的远不止11000个答案，还有5000多个草稿答案，其中很多已经写得很长了，只是因为来不及最终润色而没​​有发表。</p></blockquote><p>这篇文章说出了我想说的,我见过很多极其优秀的故事或者技术讲解,可作者发布的网站恰恰是贴吧,天涯或者知乎这样的问答网站或者论坛,作者的观点被一篇篇孤立的文章或者一条条回复分割开来,很难形成一个完整的体系.</p><p>而天涯的倒闭也说明了在这些自己不能掌控的平台上并不能保证自己的思想可以永久保留下来,那些优秀的文章随着服务器的关闭直接成为了无法触及的历史,即便是作者本人也无法找回.</p><p>因此,我拒绝在论坛里写长篇大论,而是作为读者去发掘优秀的文章,可惜的是现在优秀的文章也越来越少了,而AI生成的无意义内容充斥着论坛的每个角落,很难找到真正有意义的东西,这也是我悲哀的一点.</p><p>一方面,论坛不能让作者的文字体系化,另一方面,博客不能保证作者的文章能广泛传播,比如我这个博客就不是所有国人都能访问到的,很难找到一个折衷点.</p><p>如果我有那个能力,我可能会去开发一个跨平台的博客论坛吧,侧重点在于分享生活和技术,每个人都能像写博客一样把文章从自己本地上传,改进一下SEO算法,保证最好的文章优先显示,集成了评论系统和follow功能,最大幅度减少作者需要折腾的东西,只写md就行了,呈现的页面也由作者自己在前端设置.重点是这个网站能长久保存,不会让作者的心血白费.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://exquora.thoughtstorms.info/&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我对 Quora 上瘾，情不自禁使用这个网站。那里有一些很棒的问题和讨论，激发了我的灵感和想法。&lt;/p&gt;
&lt;p&gt;但是当我重新阅读自己</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 道路与选择</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/archives-2025-2025-12-16-%E9%81%93%E8%B7%AF%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/archives-2025-2025-12-16-%E9%81%93%E8%B7%AF%E4%B8%8E%E9%80%89%E6%8B%A9/</id>
    <published>2025-12-16T08:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>这几天有点焦躁和郁闷,总有种无所适从的感觉,浑浑噩噩的,对很多事都不上心了,于是现在静下来认真思考了一下当前的处境.</p><p>人生是由一大堆选择构成的,每一个分岔路口都决定了我以后的人生道路,有时候选择多种多样,似乎哪里都是通路,有时候仿佛是山穷水尽,让我别无选择.</p><p>人自然是希望选择越多越好,这就是我以前为什么倾向于做事提早做准备的原因,为的就是不让自己在ddl的时候显得无路可走.</p><p>但过多的选择,太多的可能,悲观的现实又让我痛苦万分,人生的道路总是要自己走的,但如果有一个引路人就更好了.看不清未来的道路只会使我无所适从,一边厌恶着填鸭式的教育,一边追求绩点的完美,只怕到头来也是一场空.</p><h2 id="梁甫吟"><a class="markdownIt-Anchor" href="#梁甫吟"></a> 梁甫吟</h2><p><strong>唐 · 李白</strong></p><blockquote><p>長嘯梁甫吟，何時見陽春？<br />君不見，朝歌屠叟辭棘津，八十西來釣渭濱。<br />寧羞白髮照清水，逢時壯氣思經綸。<br />廣張三千六百釣，風期暗與文王親。<br />大賢虎變愚不測，當年頗似尋常人。</p><p>君不見，高陽酒徒起草中，長揖山東隆準公。<br />入門不拜逞雄辯，兩女輟洗來趨風。<br />東下齊城七十二，指揮楚漢如鏇蓬。<br />狂客落魄尚如此，何況壯士當群雄！</p><p>我欲攀龍見明主，雷公砰訇震天鼓。<br />帝旁投壺多玉女，三時大笑開電光，<br />倏爍晦冥起風雨。<br />閶闔九門不可通，以額扣關閽者怒。</p><p>白日不照我精誠，杞國無事憂天傾。<br />猰貐磨牙競人肉，騶虞不折生草莖。<br />手接飛猱搏雕虎，側足焦原未言苦。</p><p>智者可卷愚者豪，世人見我輕鴻毛。<br />力排南山三壯士，齊相殺之費二桃。<br />吳楚弄兵無劇孟，亞夫咍爾為徒勞。</p><p>梁甫吟，聲正悲。<br />張公兩龍劍，神物合有時。<br />風雲感會起屠釣，大人臲屼當安之。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天有点焦躁和郁闷,总有种无所适从的感觉,浑浑噩噩的,对很多事都不上心了,于是现在静下来认真思考了一下当前的处境.&lt;/p&gt;
&lt;p&gt;人生是由一大堆选择构成的,每一个分岔路口都决定了我以后的人生道路,有时候选择多种多样,似乎哪里都是通路,有时候仿佛是山穷水尽,让我别无选择.&lt;</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 折腾记录-动态更新</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/dynamic-2025-12-16-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/dynamic-2025-12-16-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/</id>
    <published>2025-12-16T00:00:00.000Z</published>
    <updated>2026-01-01T06:24:32.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo图片管理困难帖子多了很难阅读"><a class="markdownIt-Anchor" href="#hexo图片管理困难帖子多了很难阅读"></a> hexo图片管理困难,帖子多了很难阅读</h2><p>解决方法:<br />config_yml里修改<br /><code>new_post_name: :year-:month-:day-:title.md</code><br />同时,听从大佬建议,将所有图片改成webp格式,效果立竿见影<br /><img src="../../images/archives/2025/2025-12-16%20%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/tmpDAFA.png" alt="" /></p><h2 id="还是图片问题每次复制images子文件夹路径太麻烦"><a class="markdownIt-Anchor" href="#还是图片问题每次复制images子文件夹路径太麻烦"></a> 还是图片问题,每次复制images子文件夹路径太麻烦</h2><p>根据<a href="https://www.hwpo.top/posts/d87f7e0c/index.html"></a>教程在post文件夹里设置同名文件夹没解决</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>最后写了一个脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 用 data.path 生成文件夹名</span></span><br><span class="line">  <span class="comment">// data.path 是相对于 source/_posts 的路径，带后缀</span></span><br><span class="line">  <span class="keyword">const</span> filename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, path.<span class="title function_">extname</span>(data.<span class="property">path</span>)); <span class="comment">// 去掉扩展名</span></span><br><span class="line">  <span class="keyword">const</span> imagesDir = path.<span class="title function_">join</span>(hexo.<span class="property">base_dir</span>, <span class="string">&#x27;source/images&#x27;</span>, filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(imagesDir)) &#123;</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(imagesDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Created image folder: <span class="subst">$&#123;imagesDir&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在同级目录下生成图像文件夹来管理,麻烦的是每次都要删去相对路径里的’source/’</p><h2 id="改用butterfly主题"><a class="markdownIt-Anchor" href="#改用butterfly主题"></a> 改用butterfly主题</h2><p>这个主题确实好用了不少</p><h2 id="增加评论系统"><a class="markdownIt-Anchor" href="#增加评论系统"></a> 增加评论系统</h2><p><a href="https://tech.yemengstar.com/vercel-twikoo-comment-your-hexo/">参考文章</a></p><h2 id="尝试新部署方式"><a class="markdownIt-Anchor" href="#尝试新部署方式"></a> 尝试新部署方式</h2><p><a href="https://tech.yemengstar.com/github-actions-auto-hexo/"></a></p><h2 id="增加了category条目tag条目和背景图片"><a class="markdownIt-Anchor" href="#增加了category条目tag条目和背景图片"></a> 增加了category条目,tag条目和背景图片</h2><p>原来要用<code>hexo new page tag</code>才能在hexo里显示tag页和category页</p><h2 id="发现md只要在posts下都能被直接解析251221"><a class="markdownIt-Anchor" href="#发现md只要在posts下都能被直接解析251221"></a> 发现md只要在posts下都能被直接解析(25/12/21)</h2><p>于是我将不会再修改的文章都移动到了archives文件夹,图片路径也做了对应的修改,<br />之前我还想文章多了要怎么处理呢.</p><h2 id="还是图片问题hexo本地无法正确解析相对路径"><a class="markdownIt-Anchor" href="#还是图片问题hexo本地无法正确解析相对路径"></a> 还是图片问题,hexo本地无法正确解析相对路径</h2><p>例如<code>source/images/archives/2025/2025-11-26/image.png</code><br />需要改为’images/archives/2025/2025-11-26/image.png’,每次改就很麻烦了<br />于是找ai弄了脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data.<span class="property">cover</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    data.<span class="property">cover</span> = data.<span class="property">cover</span>.<span class="title function_">replace</span>(</span><br><span class="line">      <span class="regexp">/^\/?source\//</span>,</span><br><span class="line">      <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完美解决,以后只要把复制相对路径就可以了,不要再删删减减了.</p><h2 id="增加rss订阅图标"><a class="markdownIt-Anchor" href="#增加rss订阅图标"></a> 增加rss订阅图标</h2><p><a href="https://mitpoppy.github.io/posts/fe13d434.html">参考文章</a><br />发现了RSS订阅方式,于是增加了这一功能</p><h2 id="更改了图像文件夹创建方式251226"><a class="markdownIt-Anchor" href="#更改了图像文件夹创建方式251226"></a> 更改了图像文件夹创建方式(25/12/26)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// data.path: 2025-12-26-xxx.md</span></span><br><span class="line">  <span class="keyword">const</span> basename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, path.<span class="title function_">extname</span>(data.<span class="property">path</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取前 10 个字符作为日期</span></span><br><span class="line">  <span class="keyword">const</span> date = basename.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 图片目录：source/images/2025-12-26</span></span><br><span class="line">  <span class="keyword">const</span> imagesDir = path.<span class="title function_">join</span>(</span><br><span class="line">    hexo.<span class="property">base_dir</span>,</span><br><span class="line">    <span class="string">&#x27;source/images&#x27;</span>,</span><br><span class="line">    date</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(imagesDir)) &#123;</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(imagesDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Created image folder: <span class="subst">$&#123;imagesDir&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于我的post创建格式在config里面改成了这样子<br /><code>new_post_name: :year-:month-:day-:title.md</code><br />故可以根据日期直接找到对应的图片,这样图片管理起来更加方便了,但原来的几十个文件夹我是真不想再改了.</p><h2 id="突然发现没必要用file-utils粘贴相对路径直接复制图片就好了1227"><a class="markdownIt-Anchor" href="#突然发现没必要用file-utils粘贴相对路径直接复制图片就好了1227"></a> 突然发现没必要用file utils粘贴相对路径,直接复制图片就好了(12/27)</h2><p>在settings.json里加上</p><figure class="highlight plaintext"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;**/*.md&quot;: &quot;images/$&#123;documentBaseName&#125;/&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>就可以在md里直接复制图片而不是自己写了<img src="" alt="" />这些东西了,<br />甚至会根据图片复制的位置智能选择是插入相对路径还是插入整个图片链接格式,又能偷一点懒了.</p><h2 id="每次hexo-d的时候都要报warning202611"><a class="markdownIt-Anchor" href="#每次hexo-d的时候都要报warning202611"></a> 每次hexo d的时候都要报warning(2026/1/1)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: <span class="keyword">in</span> the working copy of <span class="string">&#x27;tags/离散数学/index.html&#x27;</span>, LF will be replaced by CRLF the next <span class="keyword">time</span> Git touches it</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://zhuanlan.zhihu.com/p/586324681">详细解释CR和CRLF</a><br />LF和CRLF区别<br />LF: Line Feed换行<br />feed v.喂养,供给;将(信息)输入 line feed直译是”将行输入”,再意译”换行”<br />CRLF: Carriage Return Line Feed 回车换行<br />Carriage n.马车,火车车厢;运输费用 在carriage return中,carriage译为“车”,return译为“回”<br />在过去的机械打字机上有个部件叫「字车」（Typewriter carriage），每打一个字符，字车前进一格，打完一行后，我们需要让字车回到起始位置，而“Carriage Return”键最早就是这个作用，因此被直接翻译为「回车」。尽管后来回车键的作用已经不止” 倒回字车”那么简单，但这个译名一直被保留下来。</p></blockquote><blockquote><p><a href="https://github.com/g199209/BlogMarkdown/blob/master/Hexo%20Git%E9%83%A8%E7%BD%B2%E8%AD%A6%E5%91%8Awarning%20LF%20will%20be%20replaced%20by%20CRLF%E7%9A%84%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95.md">解决方法</a><br />这个警告的意思很直接，就是Git会把LF替换为CRLF，不过这是无关紧要的，完全可以禁用此功能，这样还可以避免这个警告信息刷屏。设置方法也很简单，在MinGW窗口中输入以下命令即可：<br />git config --global core.autocrlf false</p></blockquote><ul><li>很奇怪的是很少有人去想为什么回车叫做回车,这种粗暴的翻译在用电脑打字的时代显得非常奇怪,习惯的力量真有点可怕.</li><li><a href="https://www.163.com/dy/article/JEG01TL50511FQO9.html">扔掉CRLF</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo图片管理困难帖子多了很难阅读&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hexo图片管理困难帖子多了很难阅读&quot;&gt;&lt;/a&gt; hexo图片管理困难,帖子多了很难阅读&lt;/h2&gt;
&lt;p&gt;解决方法:&lt;br /&gt;
config_yml里</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-14 数据结构整理-(树和堆)</title>
    <link href="https://revival-of-hope.github.io/2025/12/14/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/"/>
    <id>https://revival-of-hope.github.io/2025/12/14/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/</id>
    <published>2025-12-14T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前序遍历中序遍历后序遍历层序遍历"><a class="markdownIt-Anchor" href="#前序遍历中序遍历后序遍历层序遍历"></a> 前序遍历,中序遍历,后序遍历,层序遍历</h2><p>依次为根左右,左根右,左右根,逐层遍历<br />![说明](/images/archives/2025/2025-12-14 数据结构整理-4/PixPin_2025-12-25_10-52-23.webp)<br />在递归里打印的顺序也是如此<br /><strong>以前序遍历为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> BinaryTree&lt;Type&gt;::</span><br><span class="line"><span class="built_in">PreOrder</span> ( BinTreeNode &lt;Type&gt; *current ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( current != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        cout &lt;&lt; current→data;</span><br><span class="line">        <span class="built_in">PreOrder</span> ( current→leftChild );</span><br><span class="line">        <span class="built_in">PreOrder</span> ( current→rightChild );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据前序和中序画二叉树"><a class="markdownIt-Anchor" href="#根据前序和中序画二叉树"></a> 根据前序和中序画二叉树</h3><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-55-59.webp" alt="例题" /></p><h2 id="线索化二叉树-threaded-binary-tree"><a class="markdownIt-Anchor" href="#线索化二叉树-threaded-binary-tree"></a> 线索化二叉树 (Threaded Binary Tree)</h2><p>简单说来就是空的左指针指向对应遍历顺序的前驱,若自己是第一个节点则为 nullptr,右指针指向对应遍历顺序的后驱,若自己为最后一个节点则为 nullptr.<br />![](/images/archives/2025/2025-12-14 数据结构整理-4/PixPin_2025-12-25_10-57-29.webp)</p><p>但我觉得这种不太会考算法,最多考我画画图,所以 pass 掉.</p><h2 id="最大堆和最小堆"><a class="markdownIt-Anchor" href="#最大堆和最小堆"></a> 最大堆和最小堆</h2><h3 id="向下调整算法"><a class="markdownIt-Anchor" href="#向下调整算法"></a> 向下调整算法</h3><p>调整顺序:自下而上,从右往左,其实就是从尾部节点开始倒着遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小堆的向下调整算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt; :: <span class="built_in">FilterDown</span> ( <span class="type">int</span> start, <span class="type">int</span></span><br><span class="line">EndOfHeap ) &#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    <span class="comment">// j 是 i 的左子女</span></span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= EndOfHeap ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( j &lt; EndOfHeap &amp;&amp; heap[j] &gt; heap[j<span class="number">+1</span>] ) j++; <span class="comment">//两子女中选小者</span></span><br><span class="line">        <span class="keyword">if</span> ( temp &lt;= heap[j] ) <span class="keyword">break</span>; <span class="comment">//不需要调整</span></span><br><span class="line">        <span class="keyword">else</span> &#123; heap[i] = heap[j]; i = j; j = <span class="number">2</span>*j<span class="number">+1</span>; &#125;</span><br><span class="line">        <span class="comment">//相当于把start一直通过swap向下调整到最优位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理可推得最大堆的向下调整算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MaxHeap&lt;Type&gt; :: <span class="built_in">FilterDown</span>(<span class="type">int</span> start,<span class="type">int</span> EndOfHeap)&#123;</span><br><span class="line">    <span class="type">int</span> i=start,j=<span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=EndOfHeap)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;EndofHeap&amp;&amp;heap[j]&lt;heap[j<span class="number">+1</span>]) j++;<span class="comment">//两子女选大者</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=hep[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            heap[i]=heap[j];</span><br><span class="line">            i=j;</span><br><span class="line">            j=<span class="number">2</span>*j<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入与向上调整算法"><a class="markdownIt-Anchor" href="#插入与向上调整算法"></a> 插入与向上调整算法</h3><p>简单说来就是插入到堆的末尾,然后向上逐层调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">int</span> MinHeap&lt;Type&gt; :: <span class="built_in">Insert</span> ( <span class="type">const</span> Type &amp;x ) &#123;</span><br><span class="line"><span class="comment">//在堆中插入新元素 x</span></span><br><span class="line"><span class="keyword">if</span> ( CurrentSize == MaxHeapSize ) <span class="comment">//堆满</span></span><br><span class="line">&#123; cout &lt;&lt; <span class="string">&quot;堆已满&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">heap[CurrentSize] = x;</span><br><span class="line"> <span class="comment">//插在表尾</span></span><br><span class="line"><span class="built_in">FilterUp</span> (CurrentSize);</span><br><span class="line"> <span class="comment">//向上调整为堆</span></span><br><span class="line">CurrentSize++;</span><br><span class="line"> <span class="comment">//堆元素增一</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt; :: <span class="built_in">FilterUp</span> ( <span class="type">int</span> start ) &#123;</span><br><span class="line"><span class="comment">//从 start 开始,向上直到0,调整堆</span></span><br><span class="line">    <span class="type">int</span> j = start, i = (j<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// i 是 j 的父结点</span></span><br><span class="line">    Type temp = heap[j];</span><br><span class="line">    <span class="keyword">while</span> ( j &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( heap[i] &lt;= temp ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; heap[j] = heap[i]; j = i; i = (i <span class="number">-1</span>)/<span class="number">2</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的删除"><a class="markdownIt-Anchor" href="#堆的删除"></a> 堆的删除</h3><p>通过把顶端和堆末尾元素交换来把顶端删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">int</span> MinHeap &lt;Type&gt; :: <span class="built_in">RemoveMin</span> (Type &amp;x)&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !CurrentSize )&#123;   </span><br><span class="line">        cout &lt;&lt; “ 堆已空 <span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    x = heap[0];</span></span><br><span class="line"><span class="string">    //删除最小元素</span></span><br><span class="line"><span class="string">    heap[0] = heap[CurrentSize-1];</span></span><br><span class="line"><span class="string">    CurrentSize--;</span></span><br><span class="line"><span class="string">    FilterDown ( 0, CurrentSize-1 ); // start, EndOfHeap</span></span><br><span class="line"><span class="string">    //从0号位置开始自顶向下调整为堆</span></span><br><span class="line"><span class="string">    return 1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="左孩子右兄弟表示法"><a class="markdownIt-Anchor" href="#左孩子右兄弟表示法"></a> 左孩子右兄弟表示法</h2><p>为了将多叉树转换成二叉树,从上往下遍历,左指针指向第一个孩子,右指针指向同层右边的兄弟<br />同理,将二叉树转换成多叉树,也是从上往下遍历,根据左右指针重新画图</p><h2 id="森林与二叉树的转换"><a class="markdownIt-Anchor" href="#森林与二叉树的转换"></a> 森林与二叉树的转换</h2><p>森林转化成二叉树</p><ul><li>核心转换规则：左孩子右兄弟表示法</li><li>先将每棵树转二叉树（左孩子右兄弟），再将二叉树按右子节点连接<br /><code>用人话说就是把根节点都看成是兄弟就可以了</code><br /><code>这样的话沿着根节点的右指针一直遍历拆分下去就可以找到这个森林的原始结构了</code><br />二叉树转换为森林</li><li>先按右子节点拆分二叉树，再将每棵二叉树还原为原树（逆左孩子右兄弟）</li></ul><h2 id="huffman编码"><a class="markdownIt-Anchor" href="#huffman编码"></a> Huffman编码</h2><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><blockquote><p>假定用于通信的电文仅由 8个字母 c1, c2, c3, c4, c5, c6, c7, c8 组成, 各字母在电文中出现的频率<br />分别为 5, 25, 3, 6, 10, 11, 36, 4。试为这 8 个字母设计不等长 Huffman编码, 并给出该电文的总码数。</p></blockquote><p>答案：257</p><details><summary>点击查看流程图</summary><p><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-26_13-06-42.webp" alt="" /></p></details><h2 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h2><p>稍微接触过一点算法的人都知道要怎么写吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[a]==a)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[a]=<span class="built_in">find</span>(f[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa=<span class="built_in">find</span>(a),fb=<span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">        f[fb]=fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> s,t;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="built_in">unite</span>(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_11-58-23.webp" alt="然而ppt中是这样写路径压缩的..." /><br /><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-00-58.webp" alt="而它的parent数组定义是这样的..." /><br />都用数组来存结点数了却没用数组存母节点吗,有点意思,为了不想让人轻易看懂真的是煞费苦心,我觉得这种代码要是考了就有点sm了,之后有时间我再瞅两眼,没时间就算了.</p><blockquote><p>【例1】请给出下列操作序列的运算结果，其中M是合并，F是查找：M(1,2),M(3,4),M(3,5),M(1,7),M(3,6),M(8,9),M(1,8),M(3,10),M(3,11),M(3,12),M(3,13),M(14,15),M(16,17),M(14,16),M(1,3),M(1,14)<br />根据树的高度执行合并（高度高的树作为根节点）：<br />1)画出并查集森林的构造过程。<br />2)画出存储该并查集的数组。</p></blockquote><p><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-06-42.webp" alt="解答" /></p><h2 id="bst二叉搜索树binary-search-tree"><a class="markdownIt-Anchor" href="#bst二叉搜索树binary-search-tree"></a> BST(二叉搜索树,Binary Search Tree)</h2><p>由于中序遍历是左根右,因此对BST进行中序遍历可以得到从小到大的顺序</p><p>很好奇教材上为什么都要故意用些七扭八歪的代码来写数据结构,光这样也就算了,顶多看的时候费力一点,问题是原理都不讲清楚,那就有点过分了.</p><h3 id="bst的插入和删除"><a class="markdownIt-Anchor" href="#bst的插入和删除"></a> BST的插入和删除</h3><p>插入很好理解,递归遇到空节点时直接插入就可以了,<br />删除需要分为三类</p><ol><li>无子女,这个时候直接删除</li><li>一个子女,把子女跟自己调换</li><li>双子女,寻找作用跟他相同的节点来替换,才不会破坏原二叉树,可以找到中序遍历下的上一个节点或者下一个节点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> BST&lt;Type&gt;::<span class="built_in">Remove</span>(<span class="type">const</span> Type&amp; x, BstNode&lt;Type&gt;*&amp; ptr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; ptr-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">Remove</span>(x, ptr-&gt;leftChild);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; ptr-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">Remove</span>(x, ptr-&gt;rightChild);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到要删除的结点</span></span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;leftChild &amp;&amp; ptr-&gt;rightChild) &#123;</span><br><span class="line">            BstNode&lt;Type&gt;* t = <span class="built_in">Min</span>(ptr-&gt;rightChild);</span><br><span class="line">            ptr-&gt;data = t-&gt;data;</span><br><span class="line">            <span class="built_in">Remove</span>(t-&gt;data, ptr-&gt;rightChild);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BstNode&lt;Type&gt;* t = ptr;</span><br><span class="line">            ptr = (ptr-&gt;leftChild) ? ptr-&gt;leftChild : ptr-&gt;rightChild;</span><br><span class="line">            <span class="keyword">delete</span> t;</span><br><span class="line">            <span class="comment">//一次考虑到无子女和一个子女两种情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><blockquote><p>编写算法在二叉排序树上找出任意两个不同结点的最近公共祖先。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">LCA_BST</span><span class="params">(BiTNode* root, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == p||root ==q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &lt; root-&gt;key &amp;&amp; q &lt; root-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LCA_BST</span>(root-&gt;lchild, p, q);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; root-&gt;key &amp;&amp; q &gt; root-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LCA_BST</span>(root-&gt;rchild, p, q);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avl树"><a class="markdownIt-Anchor" href="#avl树"></a> AVL树</h2><blockquote><p>一棵AVL树或者是空树，或者是具有下列性质的二叉搜索树：它的左子树和右子树都是AVL树，且左子树和右子树的高度之差的绝对值不超过1.</p></blockquote><p>有n个节点的AVL树高度不超过1.44log2​n,这可以由斐波那契数列推出来,只要让右子树一直比左子树高度加一就可以.(后面有例题)<br /><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-28_11-21-36.webp" alt="平衡因子" /><br /><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-28_11-26-24.webp" alt="旋转" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">    Type data;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLNode* left;</span><br><span class="line">    AVLNode* right;</span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">const</span> Type&amp; x)</span><br><span class="line">        : <span class="built_in">data</span>(x), <span class="built_in">height</span>(<span class="number">1</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVL</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> Type&amp; x, AVLNode&lt;Type&gt;*&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;Type&gt;(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; t-&gt;data) &#123;</span><br><span class="line">            <span class="built_in">Insert</span>(x, t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;left) - <span class="built_in">height</span>(t-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; t-&gt;left-&gt;data)</span><br><span class="line">                    t = <span class="built_in">rotateRight</span>(t);      <span class="comment">// LL</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    t = <span class="built_in">rotateLeftRight</span>(t); <span class="comment">// LR</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;data) &#123;</span><br><span class="line">            <span class="built_in">Insert</span>(x, t-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;right) - <span class="built_in">height</span>(t-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; t-&gt;right-&gt;data)</span><br><span class="line">                    t = <span class="built_in">rotateLeft</span>(t);       <span class="comment">// RR</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    t = <span class="built_in">rotateRightLeft</span>(t); <span class="comment">// RL</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;left), <span class="built_in">height</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(AVLNode&lt;Type&gt;* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t ? t-&gt;height : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">rotateRight</span><span class="params">(AVLNode&lt;Type&gt;* k2)</span> </span>&#123;</span><br><span class="line">        AVLNode&lt;Type&gt;* k1 = k2-&gt;left;</span><br><span class="line">        k2-&gt;left = k1-&gt;right;</span><br><span class="line">        k1-&gt;right = k2;</span><br><span class="line">        k2-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(k2-&gt;left), <span class="built_in">height</span>(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        k1-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(k1-&gt;left), <span class="built_in">height</span>(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">rotateLeft</span><span class="params">(AVLNode&lt;Type&gt;* k2)</span> </span>&#123;</span><br><span class="line">        AVLNode&lt;Type&gt;* k1 = k2-&gt;right;</span><br><span class="line">        k2-&gt;right = k1-&gt;left;</span><br><span class="line">        k1-&gt;left = k2;</span><br><span class="line">        k2-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(k2-&gt;left), <span class="built_in">height</span>(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        k1-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(k1-&gt;left), <span class="built_in">height</span>(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">rotateLeftRight</span><span class="params">(AVLNode&lt;Type&gt;* k3)</span> </span>&#123;</span><br><span class="line">        k3-&gt;left = <span class="built_in">rotateLeft</span>(k3-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotateRight</span>(k3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">rotateRightLeft</span><span class="params">(AVLNode&lt;Type&gt;* k3)</span> </span>&#123;</span><br><span class="line">        k3-&gt;right = <span class="built_in">rotateRight</span>(k3-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotateLeft</span>(k3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但我真的不想看代码了.下面是我的理解:<br />记三个节点从上往下依次为a,b,c<br />则这四种情况分别有</p><ol><li>a&gt;b&gt;c</li><li>a&lt;b&lt;c</li><li>b&lt;c&lt;a</li><li>a&lt;c&lt;b</li></ol><ul><li>只需把中间那个节点接上a的原位置就可以保证既满足BST,又能满足高度差为0.</li><li>第一种情况和第二种情况都只需要把b接到a的位置,然后把结构调整为BST</li><li>第三种和第四种就需要把c接到a的位置,然后把c的左右孩子按照BST规则接入其他节点</li></ul><h3 id="删除算法"><a class="markdownIt-Anchor" href="#删除算法"></a> 删除算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> AVL&lt;Type&gt;::<span class="built_in">Remove</span>(<span class="type">const</span> Type&amp; x, AVLNode&lt;Type&gt;*&amp; t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; t-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">Remove</span>(x, t-&gt;left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">Remove</span>(x, t-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到要删除的结点</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left &amp;&amp; t-&gt;right) &#123;</span><br><span class="line">            AVLNode&lt;Type&gt;* p = t-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;left) p = p-&gt;left;   <span class="comment">// 右子树最小结点</span></span><br><span class="line">            t-&gt;data = p-&gt;data;</span><br><span class="line">            <span class="built_in">Remove</span>(t-&gt;data, t-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AVLNode&lt;Type&gt;* old = t;</span><br><span class="line">            t = t-&gt;left ? t-&gt;left : t-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> old;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    t-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;left), <span class="built_in">height</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新平衡</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;left) - <span class="built_in">height</span>(t-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;left-&gt;left) &gt;= <span class="built_in">height</span>(t-&gt;left-&gt;right))</span><br><span class="line">            t = <span class="built_in">rotateRight</span>(t);       <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="built_in">rotateLeftRight</span>(t);   <span class="comment">// LR</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;right) - <span class="built_in">height</span>(t-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;right-&gt;right) &gt;= <span class="built_in">height</span>(t-&gt;right-&gt;left))</span><br><span class="line">            t = <span class="built_in">rotateLeft</span>(t);        <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="built_in">rotateRightLeft</span>(t);   <span class="comment">// RL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个要是考了就没天理了,要是给图我倒是能画一画.</p><h3 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h3><blockquote><p>高度为5的AVL树最多有多少个节点，最少有多少个节点(叶子节点高度为1)<br />显然AVL树可以是满二叉树,故直接用满二叉树来算就可以了.<br />而最少节点只需按照左右子树高度差最多为1来构造即可,构造的时候就很容易发现这是一个递归结构,有以下公式:<br /><code>f[0]=0,f[1]=1,f[n]=f[n-1]+f[n-2]+1</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前序遍历中序遍历后序遍历层序遍历&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前序遍历中序遍历后序遍历层序遍历&quot;&gt;&lt;/a&gt; 前序遍历,中序遍历,后序遍历,层序遍历&lt;/h2&gt;
&lt;p&gt;依次为根左右,左根右,左右根,逐层遍历&lt;br /&gt;
!</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-14 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/14/archives-2025-2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/14/archives-2025-2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-14T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7%C2%B7%E5%85%8B%E4%BC%A6%E6%96%AF%E5%9F%BA">克伦斯基wiki</a></p><p>今天翻wiki时通过多次跳转转到了克伦斯基的界面,之前对他的印象只有布尔什维克对他主政政府时期的控诉,以为他只是一个常见的反对派角色.</p><p><img src="images/2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/1.webp" alt="" /><br />看完wiki之后才发现他与<em>陈独秀</em>,<em>托洛茨基</em>并无区别,同样是内心向往着一个更加美好,自由的社会,同样是怀有或多或少的高士情怀,但是每况愈下的社会形势迫使他们站出来,担任自己本不想担任的领袖角色,在时代的浪潮下起起落落,最终被推上风口浪尖,只是因为不愿意参与尔虞我诈的政治斗争,狠不下心去为自己谋求应有的利益,怀着革命为人民的期望,最后却成为被革命的对象,从先驱者变成背叛者,不为敌我双方所认同,无路可走,跌下本就不属于自己的神坛,摔得粉碎.<br />被尘封在历史的角落,所有的功绩都被后来者掠夺殆尽.</p><p><strong>他们宛若一颗流星,照亮了整个世界,而后轰然坠落,再无人记得他们.</strong></p><p>这也是我厌恶英雄光环和领袖情结的原因,很多人之所以能够从渺渺众生中脱颖而出,原因便是对自己狠得下心,愿意去做那些旁人坚持不下去或者难以接受的事情,可是如果一个人对自己都能如此狠心,那对待别人又怎么可能会不狠心,不使用一些肮脏的手段,又怎么能让不甘居于人下的自己摘取桂冠,不通过残酷的斗争,又怎么可能胜过同样是英雄俊杰的对手甚至是同志.</p><p>可惜我对自己也狠不下心,又何从说对别人狠心,只好默默地给英雄们让道了.</p><p>之后会出一系列文章分析俄国革命的全流程,之所以写在这,是提醒自己别忘了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7%C2%B7%E5%85%8B%E4%BC%A6%E6%96%AF%E5%9F%BA&quot;&gt;克伦斯基wiki&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-11 数据结构整理-(排序专项)</title>
    <link href="https://revival-of-hope.github.io/2025/12/11/2025-12-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-3/"/>
    <id>https://revival-of-hope.github.io/2025/12/11/2025-12-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-3/</id>
    <published>2025-12-11T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="速通版"><a class="markdownIt-Anchor" href="#速通版"></a> 速通版</h2><h3 id="复杂度"><a class="markdownIt-Anchor" href="#复杂度"></a> 复杂度</h3><h2 id="排序算法"><a class="markdownIt-Anchor" href="#排序算法"></a> 排序算法</h2><h2 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2><p>O(n^2)不可取</p><h3 id="直接插入排序"><a class="markdownIt-Anchor" href="#直接插入排序"></a> 直接插入排序</h3><blockquote><p>思路:<br />找到upper_bound,插入后将后面的数组下标加一,重点是找到插入下标.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp=a[i],index=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;temp) index--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;index;j--)&#123;</span><br><span class="line">        a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    a[index]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a class="markdownIt-Anchor" href="#折半插入排序"></a> 折半插入排序</h3><blockquote><p>思路与上面相同,只是这次用二分法找到upper_bound</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp=a[i],index=i;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;temp)&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l=mid<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=l;j--)&#123;</span><br><span class="line">        a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    a[l]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><blockquote><p>思路:每次取增量的一半进行分组排序,直到增量为1,保证完全有序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;  <span class="comment">// 外层：缩小 gap</span></span><br><span class="line">        <span class="comment">// 对于当前 gap，进行分组插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;  <span class="comment">// 从 gap 开始，每个元素插入到前面的子序列</span></span><br><span class="line">            <span class="type">int</span> temp = a[i];  <span class="comment">// 当前元素</span></span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="comment">// 在子序列中向后移（步长 gap）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; a[j - gap] &gt; temp) &#123;</span><br><span class="line">                a[j] = a[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = temp;  <span class="comment">// 插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="交换排序"><a class="markdownIt-Anchor" href="#交换排序"></a> 交换排序</h2><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><p>每一轮排好一个数字,n个数字排n-1轮</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=a[j<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;a[j])&#123;</span><br><span class="line">            a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">            a[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以直接用swap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = a[l];</span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= pivot) j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a[i] = pivot;</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">// 返回 pivot 最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, l, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(a,<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为参考视频</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1205817791&bvid=BV1tf421Q7eh&cid=1596291120&p=1"   width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe><blockquote><p>吐槽一下B站直接在分享点嵌入代码给出的是<code>&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=1205817791&amp;bvid=BV1tf421Q7eh&amp;cid=1596291120&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;</code><br />结果只能在很小的一块区域显示,所以我用ai改成了<code>&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=1205817791&amp;bvid=BV1tf421Q7eh&amp;cid=1596291120&amp;p=1&quot; width=&quot;100%&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;速通版&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#速通版&quot;&gt;&lt;/a&gt; 速通版&lt;/h2&gt;
&lt;h3 id=&quot;复杂度&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#复杂度&quot;&gt;&lt;/a&gt; 复杂度&lt;/h3&gt;
&lt;h2 </summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当时只道是寻常</title>
  
  
  <link href="https://revival-of-hope.github.io/rss.xml" rel="self"/>
  
  <link href="https://revival-of-hope.github.io/"/>
  <updated>2026-01-03T14:22:33.667Z</updated>
  <id>https://revival-of-hope.github.io/</id>
  
  <author>
    <name>Revival-of-hope</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2026-01-03 考研人数的下降</title>
    <link href="https://revival-of-hope.github.io/2026/01/03/%E6%84%9F%E6%83%B3/"/>
    <id>https://revival-of-hope.github.io/2026/01/03/%E6%84%9F%E6%83%B3/</id>
    <published>2026-01-03T00:00:00.000Z</published>
    <updated>2026-01-03T14:22:33.667Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/2026-01-03/PixPin_2026-01-03_21-30-11.webp" alt="" /></p><p><img src="images/2026-01-03-%E6%84%9F%E6%83%B3/PixPin_2026-01-03_21-47-17.webp" alt="" /></p><p><img src="../images/2026-01-03/PixPin_2026-01-03_21-46-12.webp" alt="" /><br />可以看出来,尽管本科毕业人数越来越多,研究生招生人数越来越多,报考研究生的人数却越来越少,接着看下图<br /><img src="images/2026-01-03-%E6%84%9F%E6%83%B3/PixPin_2026-01-03_21-56-44.webp" alt="" /><br /><img src="images/2026-01-03-%E6%84%9F%E6%83%B3/PixPin_2026-01-03_21-57-46.webp" alt="" /><br />疫情的影响太大了,大家都开始捂住钱包,不会再去做大胆的投资了,因此收入较稳定的餐饮业扶摇直上,而旅游业直到现在也未必恢复了元气.<br /><img src="../images/2026-01-03/PixPin_2026-01-03_22-07-44.webp" alt="" /><br />越来越多的人选择去找一些稳定的工作如公务员,医护人员,不愿意去创业了.</p><p>顺带一提还有战败cg,尽管没有今年的数据,但我相信降幅不会相差太多<br /><img src="images/2026-01-03-%E6%84%9F%E6%83%B3/PixPin_2026-01-03_21-50-15.webp" alt="" /></p><blockquote><p>这也是普通人的无奈吧,尽管身处这个时代,却连发生了什么都难以把握,只能隐约感觉到大环境不好,却找不到合理的数据来帮自己掌握一点点情况,连知情权也被剥夺,不知道下一步要怎么走,迷茫的在原地打转,只好依着惯例提心吊胆的生活,提不上享受生活,只看得见压抑和悲哀,失去了相信他人的胆量,失去了期盼明天的幸福,只是靠本分承担着责任,不是为了自己,而是为了亲人</p></blockquote><p>很早就想要拿日本跟本国做一个对比了,尽管人口基数差的很离谱,但以前的日本或许就是现在的我们,现在这里预告提醒我自己一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../images/2026-01-03/PixPin_2026-01-03_21-30-11.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/2026-01-03-%E6%84%9F%E6%83%B3/PixPin_20</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-01 离散数学整理-群论</title>
    <link href="https://revival-of-hope.github.io/2026/01/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E7%BE%A4%E8%AE%BA/"/>
    <id>https://revival-of-hope.github.io/2026/01/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E7%BE%A4%E8%AE%BA/</id>
    <published>2026-01-01T00:00:00.000Z</published>
    <updated>2026-01-03T07:58:21.803Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113979489780353&bvid=BV1H2NoeiE1K&cid=28736228422&p=1"        width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe><p>由于学校规定的那本臭不可闻的ts离散教材已经沉浸在自己的优越感里了,找不到一点点系统性,只好我自己从头开始梳理,大多数定义都是直接引用的wiki</p><h2 id="运算律"><a class="markdownIt-Anchor" href="#运算律"></a> 运算律</h2><h3 id="结合律"><a class="markdownIt-Anchor" href="#结合律"></a> 结合律</h3><ul><li><code>a+(b+c)=(a+b)+c</code><br />结合律是群论中最为重要的部分,只有满足结合律的代数系统才可以进行两项以上的计算,例如计算a+b+c.如果(a+b)+c!=q+(b+c),那就无法得出唯一的结果了</li></ul><h3 id="交换律"><a class="markdownIt-Anchor" href="#交换律"></a> 交换律</h3><ul><li><code>a+b=b+a</code><br />很多代数系统不满足交换律,例如矩阵乘法</li></ul><h3 id="分配律"><a class="markdownIt-Anchor" href="#分配律"></a> 分配律</h3><p>如果<em>对+满足以下式子,则称</em>对+满足分配律</p><ul><li><code>a*(b+c)=a*b+a*c</code></li></ul><h3 id="幂等律"><a class="markdownIt-Anchor" href="#幂等律"></a> 幂等律</h3><ul><li><code>a+a=a</code><br />在幂等律成立的代数系统中，对同一元素重复运算不会产生新的结果，常见于集合的并运算与交运算中。</li></ul><h3 id="吸收律"><a class="markdownIt-Anchor" href="#吸收律"></a> 吸收律</h3><p>需要同时满足下面两个式子</p><ul><li><code>a+(a*b)=a</code></li><li><code>a*(a+b)=a</code></li></ul><h3 id="消去律"><a class="markdownIt-Anchor" href="#消去律"></a> 消去律</h3><p><img src="../images/archives/2026-01-01/PixPin_2026-01-01_15-47-28.webp" alt="例题" /><br />逆元和结合律保证了消去律的存在</p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><img src="../images/archives/2026-01-01/PixPin_2026-01-01_10-35-05.webp" alt="" /></p><h2 id="代数系统"><a class="markdownIt-Anchor" href="#代数系统"></a> 代数系统</h2><h3 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h3><p>半群满足加法,群还满足减法,环还满足乘法,域还满足除法<br /><img src="../images/archives/2026-01-01/PixPin_2026-01-02_23-06-11.webp" alt="" /></p><h3 id="子代数"><a class="markdownIt-Anchor" href="#子代数"></a> 子代数</h3><p>子代数与原代数系统含有相同的代数常数,且对于所有运算都是封闭的</p><h3 id="封闭性"><a class="markdownIt-Anchor" href="#封闭性"></a> 封闭性</h3><p><img src="../images/archives/2026-01-01/PixPin_2026-01-02_23-12-44.webp" alt="" /><br />封闭性其实是非常重要的性质,保证了集合内的运算结果保留在集合内,而不会出现任何特殊情况,而由于作为整个群论基础的半群具有封闭性,故下文讨论到的所有代数系统都具有封闭性.</p><h3 id="同态和同构"><a class="markdownIt-Anchor" href="#同态和同构"></a> 同态和同构</h3><p><img src="../images/archives/2026-01-01/PixPin_2026-01-02_22-38-55.webp" alt="" /></p><p>如果同态满足单射,称为单同态,满足满射,称为满同态,满足双射,则称为同构</p><h4 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h4><p><img src="../images/archives/2026-01-01/PixPin_2026-01-01_14-30-58.webp" alt="" /><br />通过这个例题可以明确几点关于映射的知识</p><ul><li>没参与映射的元素不会计入原像集合,例如这里的0在原像集合中,故一定有像存在</li><li>双射时像和原像一定是一一对应的</li></ul><h3 id="半群"><a class="markdownIt-Anchor" href="#半群"></a> 半群</h3><p>满足结合律的封闭代数系统称为半群</p><p>例子: 自然数下的加法</p><p>含有幺元的半群称为独异点(垃圾翻译)</p><h3 id="群"><a class="markdownIt-Anchor" href="#群"></a> 群</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p>存在一个数e,使得对于集合S内所有的元素a都满足以下公式,则称e为集合S的幺元</p><ul><li><code>e+a=a,a+e=a</code></li></ul><p>若一个半群S存在幺元e,且对于集合S内所有的元素a都有逆元b满足以下公式,则称S为群</p><ul><li><code>b+a=a+b=e</code></li></ul><ol><li>由于零元不存在逆元,故群都不含零元</li><li>除单位元素e外群不存在等幂元素</li></ol><h4 id="群的阶数"><a class="markdownIt-Anchor" href="#群的阶数"></a> 群的阶数</h4><p>群G中元素的个数称为阶数,记作|G|,若个数有限,称为有限群,否则为无限群,若G只有一个单位元素e,则称为平凡群</p><h4 id="交换群阿贝尔群"><a class="markdownIt-Anchor" href="#交换群阿贝尔群"></a> 交换群(阿贝尔群)</h4><blockquote><p>满足交换律的群称为交换群</p></blockquote><h4 id="klein四元群"><a class="markdownIt-Anchor" href="#klein四元群"></a> Klein四元群</h4><p><img src="../images/archives/2026-01-01/PixPin_2026-01-01_15-36-07.webp" alt="" /><br />G的运算具有以下特点:</p><ol><li>e为G中的幺元</li><li>.是可交换的</li><li>任何G中元素与自己运算的结果都为e</li><li>除幺元外任意两个元素的运算结果都等于另一个元素</li></ol><blockquote><p>可以看出Klein四元群既是交换群又是有限群</p></blockquote><h4 id="子群"><a class="markdownIt-Anchor" href="#子群"></a> 子群</h4><p>显然只要是群S的子集,并满足群的性质就可以称为子群,重点在于证明一个子集是一个群的子群<br /><img src="../images/archives/2026-01-01/PixPin_2026-01-02_23-22-23.webp" alt="" /></p><blockquote><p>关键在于一点点补全群的定义,首先找到幺元,接着找到逆元存在,由于集合被划分,故原来的封闭性可能被破坏,还需要证明封闭性,而结合律不用证明,因为所有半群的子集都是满足结合律的</p></blockquote><h4 id="循环群"><a class="markdownIt-Anchor" href="#循环群"></a> 循环群</h4><p><img src="../images/archives/2026-01-01/PixPin_2026-01-02_22-54-02.webp" alt="定义" /></p><ul><li>这里的幂次不一定是乘方,只是表示对g进行多次运算</li><li>生成元g与群G的阶数是一样的,无限循环群的生成元是a和a^-1,而n阶循环群的生成元是与a所有与n互质的幂次(互质:最大公约数为1,因此1也包含在互质的幂次里)</li><li>从定义可以知道循环群一定是交换群</li><li><blockquote><p>由于要满足封闭性,故n阶循环群子群的生成元的幂次一定都是n的因数,可以把g的n次方计为幺元e,这个刚看到时很难理解,但如果没有幺元,那么就可以一直运算下去,就不是有限群了,故一定存在一个边界保证阶数不超过n,那么把g的n次方看作e就非常合适了.</p></blockquote></li></ul><h4 id="置换群"><a class="markdownIt-Anchor" href="#置换群"></a> 置换群</h4><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">置换通常写作轮换形式。例如，在轮换表示法中，给定集合  </span><br><span class="line">M = &#123;1, 2, 3, 4&#125;。</span><br><span class="line"></span><br><span class="line">设 M 的一个置换 g 满足：</span><br><span class="line"><span class="bullet">-</span> g(1) = 2  </span><br><span class="line"><span class="bullet">-</span> g(2) = 4  </span><br><span class="line"><span class="bullet">-</span> g(4) = 1  </span><br><span class="line"><span class="bullet">-</span> g(3) = 3  </span><br><span class="line"></span><br><span class="line">则该置换可以写作：</span><br><span class="line">(1, 2, 4)(3)</span><br><span class="line"></span><br><span class="line">或者更常见地写作：</span><br><span class="line">(1, 2, 4)</span><br><span class="line"></span><br><span class="line">因为元素 3 在该置换下保持不变。</span><br><span class="line"></span><br><span class="line">当对象用单个字母或数字表示时，逗号通常也可以省略，因此也可记作：</span><br><span class="line">(1 2 4)</span><br></pre></td></tr></table></figure><ul><li>涉及集合S中m个不同数的置换称为m阶轮换</li></ul><h3 id="环和域"><a class="markdownIt-Anchor" href="#环和域"></a> 环和域</h3><p>显然wiki上定义的环是真环,乘法有幺元;教材里用的定义是伪环,乘法不含幺元</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个环是一个集合 R，具有两个二元运算（+ 和 ·），分别称为“加法”和“乘法”。</span><br><span class="line"></span><br><span class="line">其中，乘法对加法满足分配律,并且满足以下代数结构条件：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> (R, +) 是一个阿贝尔群  </span><br><span class="line"><span class="bullet">-</span> (R, ·) 是一个半群</span><br></pre></td></tr></table></figure><p><strong>零因子</strong>:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对所有 (a, b) ∈ R × R， 若当a,b都不为0时存在a × b = 0</span><br><span class="line">则a称为左零因子,b称为右零因子</span><br></pre></td></tr></table></figure><p><strong>证明零因子可以用消去律代替</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">假设 R 中没有零因子。</span><br><span class="line"></span><br><span class="line">已知：</span><br><span class="line">a ≠ 0 </span><br><span class="line">a x b = a x c</span><br><span class="line"></span><br><span class="line">两边相减，得到：</span><br><span class="line">a x (b − c) = 0</span><br><span class="line"></span><br><span class="line">由于 a ≠ 0，</span><br><span class="line">又因为没有零因子，</span><br><span class="line"></span><br><span class="line">只能推出：</span><br><span class="line">b − c = 0</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">b = c</span><br></pre></td></tr></table></figure><ul><li>只有所有非零数相乘都不为0才可以说环不存在零因子,称为无零因子环</li><li>若环R中乘法满足交换律,含有幺元,无零因子,则R称为整环</li><li>若环R至少含有两个元素且含有幺元,无零因子,所有非零元素都存在乘法逆元,则称R为除环</li></ul><blockquote><ul><li>简短说来,环中多了一个对有无零因子的考察,因为如果不满足消去律的话研究这个代数系统就很困难了,而整环中乘法是一个可交换独异点,除环除开零以外是一个群</li></ul></blockquote><blockquote><ul><li>若环R既是整环又是除环,则称R是域</li></ul></blockquote><h3 id="格与布尔代数"><a class="markdownIt-Anchor" href="#格与布尔代数"></a> 格与布尔代数</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">考虑一个偏序集合 (L, ≤)。  </span><br><span class="line">如果对集合 L 中的任意两个元素 a、b，  </span><br><span class="line">它们在 L 中都存在最大下界和最小上界，  </span><br><span class="line">则称 (L, ≤) 是一个格。</span><br><span class="line">(由于偏序符号不好打,这里的小于等于都是偏序符号,表示可比,可比要求两个元素在哈斯图里处于同一分支上)</span><br><span class="line">从这个定义可以看出：</span><br><span class="line">格并不要求像全序集合那样，任意两个元素都必须可比；</span><br><span class="line">但仍要求任意两个元素都具有最大下界和最小上界。</span><br></pre></td></tr></table></figure><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在这里，取 a、b 的最大下界的运算记作  </span><br><span class="line">a ∧ b；</span><br><span class="line"></span><br><span class="line">取 a、b 的最小上界的运算记作  </span><br><span class="line">a ∨ b。</span><br></pre></td></tr></table></figure><hr /><blockquote><ul><li>格和全序集的区别:<br />简单画哈斯图便可以知道,全序集是一条线,而格可以有多个分支,只要分支最后能汇合到一点就可以</li></ul></blockquote><blockquote><ul><li>格满足交换律,结合律,幂等律和吸收律,这些从定义来看就很好理解,故无需证明</li></ul></blockquote><h4 id="补充概念"><a class="markdownIt-Anchor" href="#补充概念"></a> 补充概念</h4><p><strong>最大元和最小元</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">设 (P, ≤) 为一个偏序集 ，S 为其子集。</span><br><span class="line"></span><br><span class="line">若 S 中的元素 g 满足：  </span><br><span class="line">对 S 的任意元素 s，都有 s ≤ g，  </span><br><span class="line">则称 g 为 S 的最大元（greatest element）。</span><br><span class="line"></span><br><span class="line">对偶地，若 S 中的元素 l 满足：  </span><br><span class="line">对 S 的任意元素 s，都有 l ≤ s，  </span><br><span class="line">则称 l 为 S 的最小元（least element）。</span><br><span class="line"></span><br><span class="line">由定义可知，S 的最大元（最小元）必定是 S 的上界（下界）。</span><br><span class="line"></span><br><span class="line">并且集合 S 至多只能有一个最大元：  </span><br><span class="line">若 g₁ 和 g₂ 都是 S 的最大元，则由定义有  </span><br><span class="line">g₁ ≤ g₂，且 g₂ ≤ g₁，  </span><br><span class="line">由反对称性可得 g₁ = g₂。</span><br><span class="line"></span><br><span class="line">因此，若 S 存在最大元,则该最大元必定是唯一的,最小元同理</span><br></pre></td></tr></table></figure><p><strong>最小上界和最大上界</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设 (A, ≤) 为一个偏序集，B ⊆ A。</span><br><span class="line"></span><br><span class="line">若存在 y ∈ A，使得对任意 x ∈ B 都有  </span><br><span class="line">x ≤ y，  </span><br><span class="line">则称 y 为集合 B 的上界。</span><br><span class="line"></span><br><span class="line">对称地，若存在 z ∈ A，使得对任意 x ∈ B 都有  </span><br><span class="line">z ≤ x，  </span><br><span class="line">则称 z 为集合 B 的下界。</span><br><span class="line"></span><br><span class="line">偏序集A的子集B在A中的上界集合的最小元称为最小上界,对偶概念即为最大下界</span><br></pre></td></tr></table></figure><h4 id="特殊的格"><a class="markdownIt-Anchor" href="#特殊的格"></a> 特殊的格</h4><p><strong>分配格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个格。  </span><br><span class="line">若对任意 a、b、c ∈ L，都有：</span><br><span class="line"></span><br><span class="line">a ∧ (b ∨ c) = (a ∧ b) ∨ (a ∧ c)  </span><br><span class="line">a ∨ (b ∧ c) = (a ∨ b) ∧ (a ∨ c)</span><br><span class="line"></span><br><span class="line">则称 L 为一个分配格。</span><br></pre></td></tr></table></figure><hr /><p><strong>有界格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个格。  </span><br><span class="line">若 L 有最小元0和最大元1,即对任意 a ∈ L 都满足  </span><br><span class="line">a ∨ 0 = a 和 a ∧ 1 = a，  </span><br><span class="line">则称 L 为一个有界格,这里的最小元称为全下界,最大元称为全上界</span><br></pre></td></tr></table></figure><ul><li>可以认为所有元素有限的格都是有界格,因为格的定义就要求了哈斯图的两端是封闭的,故一定有上下界</li></ul><hr /><p><strong>有补格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个有界格  </span><br><span class="line">并且 L 中的每个元素 a 都存在一个b ∈ L 使得  </span><br><span class="line">a ∨ b = 1 且 a ∧ b = 0。  </span><br><span class="line">这样的 b 称为 a 的补元。</span><br><span class="line">L则称为有补格</span><br></pre></td></tr></table></figure><p><em>证明分配格中任意元素的补元唯一</em></p><blockquote><p>设 L 是一个分配格，有界格，且 a ∈ L 有两个补元 b 和 c。<br />根据补元的定义：</p><ol><li>a ∨ b = 1 且 a ∧ b = 0</li><li>a ∨ c = 1 且 a ∧ c = 0</li></ol><p>要证明 b = c。</p><p>步骤 1：利用分配律</p><p>考虑 b ∧ (a ∨ c)：</p><p>b ∧ (a ∨ c) = (b ∧ a) ∨ (b ∧ c)  （分配律）</p><p>代入已知 a ∧ b = 0：</p><p>0 ∨ (b ∧ c) = b ∧ c</p><p>而 a ∨ c = 1，所以：</p><p>b ∧ 1 = b</p><p>所以 b = b ∧ c。</p><p>步骤 2：对称地</p><p>同理，c = a ∨ b ∧ c，经过类似推导可得：</p><p>c = b ∧ c</p><p>步骤 3：结合得到</p><p>b = b ∧ c = c</p><p>因此，补元是唯一的。</p></blockquote><p><strong>布尔格(布尔代数)</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">布尔格是一个有补分配格,换句话说，它是一个有最小元 0 和最大元 1 的格,</span><br><span class="line">满足分配律，并且每个元素都有补元</span><br></pre></td></tr></table></figure><ul><li>由上述证明可以明确布尔代数每个元素的补元唯一,求补元可以看成是一元运算</li></ul><hr /><p><strong>仔细一看就算都理解透了,还是有一堆要背的,因为不可能到考试的时候现推啊,能把数学课教成文科也是挺nb的.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=113979489780353&amp;bvid=BV1H2NoeiE1K&amp;cid=28736228422&amp;p=1&quot;        width=&quot;100%&quot;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-01 浏览器实用插件</title>
    <link href="https://revival-of-hope.github.io/2026/01/01/dynamic-2026-01-01-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>https://revival-of-hope.github.io/2026/01/01/dynamic-2026-01-01-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</id>
    <published>2026-01-01T00:00:00.000Z</published>
    <updated>2026-01-01T09:25:11.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gitzip-for-github"><a class="markdownIt-Anchor" href="#gitzip-for-github"></a> <a href="https://microsoftedge.microsoft.com/addons/detail/gitzip-for-github/iemilfmlaliblejogfofhmjbfiaiegnd">GitZip for github</a></h1><h1 id="octotree"><a class="markdownIt-Anchor" href="#octotree"></a> <a href="https://www.octotree.io/">Octotree</a></h1><h1 id="pixiv-downloader"><a class="markdownIt-Anchor" href="#pixiv-downloader"></a> <a href="https://github.com/xuejianxianzun/PixivBatchDownloader">Pixiv Downloader</a></h1><h1 id="competitive-companion-customed"><a class="markdownIt-Anchor" href="#competitive-companion-customed"></a> <a href="https://github.com/lnw143/competitive-companion-customized">Competitive Companion customed</a></h1><h1 id="lingvanex"><a class="markdownIt-Anchor" href="#lingvanex"></a> <a href="https://microsoftedge.microsoft.com/addons/detail/lingvanex-%E7%BF%BB%E8%AF%91%E5%92%8C%E8%AF%8D%E5%85%B8%E3%80%82%E5%97%93%E9%9F%B3/pppgidljpojmcjehgdnfmmffbhifdloh">Lingvanex</a></h1><h1 id="unpaywall"><a class="markdownIt-Anchor" href="#unpaywall"></a> <a href="https://chromewebstore.google.com/detail/unpaywall/iplffkdpngmdjhlpjmppncnlhomiipha">unpaywall</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gitzip-for-github&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#gitzip-for-github&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://microsoftedge.microsoft.com/addons/d</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025 年终总结</title>
    <link href="https://revival-of-hope.github.io/2025/12/31/archives-2025-2025-12-31-%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <id>https://revival-of-hope.github.io/2025/12/31/archives-2025-2025-12-31-%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%A7%E4%BD%9C%E4%B8%9A/</id>
    <published>2025-12-31T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周都在忙cocos大作业,差点在30号晚上熬通宵.今天下午答辩,答辩前五分钟才把ppt写完,而项目到演示时都没能完整运行,还好老师们都不怎么在意真正的成品,反而是一直拷打代码中继承和多态的应用,侥幸过关,如果真的要当场演示,那估计就有大问题了.</p><p>究其原因,是小组合作的环节出了问题,我们组有一个本来能自己单干的大佬,而剩下的两人包括我则是不一般的菜鸡,大多数代码都是由AI完成的,很多报错也只有问AI才能解决,因为我之前根本就没接触过CPP的工程构建,多文件的集成也都是靠AI解决的.</p><p>尽管大佬给了很详细的接口文档,但由于文档全是英文,于是我们就直接贴给AI让它翻译,又没好意思让他一个人帮我们看代码,那样他就把活儿都干了.于是就悲剧了.尽管UI层的隔离测试可以跑通,Gameplay和Engine部分单独跑也可以,但由于我们这边的实现不够完全,接口没能全部写完整,于是在答辩前三天的合并时就出问题了,而且在大佬很早就提出要对齐接口的时候我们不够重视,导致接口一直有偏差,等发现是由于接口没对齐导致报错的时候离答辩只有不到一天了.而大佬以为我们都实现好了,只是路径包含或者平台差异导致报错,之前就没有来帮我们改代码,而这个时候再改就已经来不及了.</p><p><strong>复盘</strong><br>小组项目成功的必要条件:</p><ul><li>组员之间关系平等,不存在不好意思说话的情况,只有好好的沟通交流才能保证项目协作正常</li><li>组员之间能力不能相差太大,如果能力都有限反而更好团队协作,光是抱大腿未免有些太要不得了</li><li>组员需要掌握基本的Debug能力,光是靠AI或者求爷爷告奶奶是不行的,而是要能够自己独立解决基本的技术问题</li><li>每次更新都需要及时通过文档告知其他组员,详细写明更改的地方,以及对合作者的接口要求,最好是中文(😀)</li><li>在开始项目之前就要搭出一个最基本的框架,即使再抽象也可以,把所有必须要实现的功能要求先列出来,才可以保证后续运行的时候不跑偏</li><li>分工不合理很有可能导致组员间暗藏怨气,需要找到一个合理的分工方式和架构保证工作量分配均匀</li><li>使用git进行版本控制,每次commit时不要偷懒,多打几个字把本次commit好好说清楚,才不会在日后受罪</li><li>需要尽早进行合并,才能确认基本功能有没有正常实现,否则后期的合并会极其痛苦</li><li>永远不要孤军奋战,给代码一通乱改,而是虚心请教他人,如果拉不下脸,想想项目失败的后果</li></ul><p>想来这也是对我这一个学期课业的一个糟糕的总结吧,学的不够精,学的不够多,到最后啥都没剩下,还有三个小时就跨年了,祝新的一年我能更成熟一点,更好学一点,更活泼一点,更努力一点,不用太多,一点点就够了,能让我自己感觉到就够了.</p><p><strong>目标</strong></p><ul><li>[ ] cpp工程学习</li><li>[ ] 后端学习(数据库+Java)</li><li>[ ] 网络安全学习</li><li>[ ] 编写一个开源项目</li><li>[ ] 参加十场以上的比赛</li><li>[ ] 明确就业还是读研</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一周都在忙cocos大作业,差点在30号晚上熬通宵.今天下午答辩,答辩前五分钟才把ppt写完,而项目到演示时都没能完整运行,还好老师们都不怎么在意真正的成品,反而是一直拷打代码中继承和多态的应用,侥幸过关,如果真的要当场演示,那估计就有大问题了.&lt;/p&gt;
&lt;p&gt;究其原因</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-27 各种grammar集合</title>
    <link href="https://revival-of-hope.github.io/2025/12/27/dynamic-2025-12-27-grammar/"/>
    <id>https://revival-of-hope.github.io/2025/12/27/dynamic-2025-12-27-grammar/</id>
    <published>2025-12-27T00:00:00.000Z</published>
    <updated>2026-01-01T06:06:00.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索引擎命令">搜索引擎命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">设关键词为计算机</span><br><span class="line"><span class="string">&quot;计算机&quot;</span>:        <span class="comment"># 必须含有计算机三个字</span></span><br><span class="line">计算机 after:2023-01-01 before:2024-01-01 <span class="comment"># 限定日期</span></span><br><span class="line">计算机 past:1y <span class="comment"># 过去一年</span></span><br><span class="line">计算机 filetype:pdf <span class="comment"># 限定文件类型</span></span><br><span class="line">计算机 site:baidu.com <span class="comment"># 限定网站  </span></span><br><span class="line">计算机 -考研 <span class="comment">#排除关键词</span></span><br><span class="line">site:.edu        （教育机构）</span><br><span class="line">site:.gov        （政府网站）</span><br><span class="line">site:.org        （组织机构）</span><br><span class="line">site:.cn         （中国网站）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="git命令">git命令</h2><p>windows端先设置代理端口</p><figure class="highlight plaintext"><figcaption><span>http_proxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>git init //初始化git,只运行一次<br>git add . //所有文件加入本地git<br>git commit -m “first commit” //提交到本地<br>git branch -M main //设置提交分支为main,之后可以不必运行<br>git remote add origin <a href="https://github.com/revival-of-hope/Clash_of_Clans.git">https://github.com/revival-of-hope/Clash_of_Clans.git</a> //关联选定仓库并在本地设置标签为origin,只要运行一次<br>git push -u origin main //-u(upstream)设置上游分支为origin的main分支,以后默认提交到origin仓库的main分支,以后只写git push就行</p><p>之后再修改只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">#可加上origin main关键字,但由于已经设置默认上游,故可以省略</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;描述修改&quot;</span> <span class="comment">#不加引号也可以</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>即可</p><h2 id="hexo命令行">hexo命令行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hexo new post/draft/page</span><br><span class="line">hexo publish draft&quot;文章名&quot;</span><br><span class="line">hexo d           --push my blog  deploy</span><br><span class="line">hexo new  +name     --new blog</span><br><span class="line">hexo g            --apply changes  generate</span><br><span class="line">hexo s            --local static html #预览</span><br><span class="line">hexo g -d   #一次完成</span><br><span class="line"></span><br><span class="line">draft也就是草稿，在使用hexo创建文章时，可以先指定为草稿。</span><br><span class="line">hexo new draft &lt;title&gt;</span><br><span class="line">然后在完成之后，使用publish命令将draft转移到post下。</span><br><span class="line">hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure><h2 id="markdown">markdown</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">##</span><br><span class="line">###</span><br><span class="line">####</span><br></pre></td></tr></table></figure><p>均为标题</p><p><code>[]() 插入链接和说明</code><br><code>![]() 插入图片</code><br>`</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113979489780353&bvid=BV1H2NoeiE1K&cid=28736228422&p=1"        width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe> 插入图片`<figure class="highlight plaintext"><figcaption><span>插入代码块</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`代码` 行内代码</span><br><span class="line">`*斜体*`</span><br><span class="line">`**粗体** `</span><br><span class="line">`~~删除线~~`</span><br><span class="line">`==高亮==`</span><br></pre></td></tr></table></figure><ul><li>项目</li></ul><ul><li>项目</li></ul><ul><li>项目</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三种方式均可以表示列表</span><br></pre></td></tr></table></figure><ul><li>[ ] 未完成</li><li>[x] 已完成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ol><li>项目</li><li>项目</li><li>项目</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&gt; 引用内容</span><br><span class="line">&gt;&gt; 嵌套引用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br><span class="line">___</span><br><span class="line">三种方式均可以表示分割线</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 列1 | 列2 | 列3 |</span><br><span class="line">| --- | --- | --- |</span><br><span class="line">| A   | B   | C   |</span><br><span class="line"></span><br><span class="line">表格</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搜索引擎命令&quot;&gt;搜索引擎命令&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-26 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/26/archives-2025-2025-12-26-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/26/archives-2025-2025-12-26-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-26T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://ipotato.me/article/65">来源</a><br>说实话大三上就开始找实习其实是一个有些冒险，但相应收益会比较高的做法。风险点在于学校的课程安排趋近于收尾，一些比较难的专业课也会集中在这个学期，如何平衡好学习和工作是一个首先要考虑的因素，这一点上我的做法比较粗暴：直接翘课。一是因为成绩也够不着保研的尾巴，无需那么在意绩点，二是因为除了体育课这种比较难逃的课，其他一律统统全翘，只是为了挤出了一周 4 天的实习时长，至于课业，只能安排到工作日下班，周末以及考试临近时的请假进行学习。但即便是翘课，对于一些专业课程还是要用心，比如 OS 以及编译原理等课程，可以说是专业的重中之重，不光学习会接触，在面试以及工作中也是非常核心的内容。好在一个学期下来课虽然都翘了，但最后的结果也不坏，没有顾此失彼而整出来个挂科。</p></blockquote><ul><li>其实如果没打算读研的话就可以这么做,既然是本科毕业就工作,那绩点的意义就消失了.</li></ul><p>这几天用<a href="https://rawweb.org/">rawweb</a>不知道看了多少博客,足够大的体量保证了我搜任何一个关键词基本都能找到答案,每一个博客对我来说都是一个全新的领域,仿佛博主的生活就是我的生活,他们的迷惘和彷徨就是我的迷惘和彷徨.就比如我搜索关键词保研,一下就得到了一千多条结果,里面的很多文章对我来说都是对读研和工作这一抉择的重新认识.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ipotato.me/article/65&quot;&gt;来源&lt;/a&gt;&lt;br&gt;
说实话大三上就开始找实习其实是一个有些冒险，但相应收益会比较高的做法。风险点在于学校的课程安排趋近于收尾，一些比较难的专业课也会集中在这个学期，如</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25 离散数学整理-逻辑关系</title>
    <link href="https://revival-of-hope.github.io/2025/12/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/25/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/</id>
    <published>2025-12-25T00:00:00.000Z</published>
    <updated>2026-01-05T09:50:54.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命题逻辑"><a class="markdownIt-Anchor" href="#命题逻辑"></a> 命题逻辑</h1><h2 id="逻辑联结词"><a class="markdownIt-Anchor" href="#逻辑联结词"></a> 逻辑联结词</h2><h3 id="析取与合取"><a class="markdownIt-Anchor" href="#析取与合取"></a> 析取与合取</h3><blockquote><p>析取符号: ∨<br />合取符号: ∧</p></blockquote><ul><li>想象合取就是两个条件都要满足,析取符号就像漏斗一样析取东西,因此朝上</li></ul><h3 id="蕴含与等价"><a class="markdownIt-Anchor" href="#蕴含与等价"></a> 蕴含与等价</h3><blockquote><p>p-&gt;q =¬p∨q</p></blockquote><ul><li>不要读作<code>如果p,那么q</code>,而是读作p蕴含q,表示p是q的充分条件,q是p的必要条件</li><li>我的理解:当p为真自然可以推出q为真,故p真q假真值为F,当p为假时无法得知q的情况,故只能默认为T</li></ul><p><strong>真值表</strong><br /><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/image.png" alt="来自知乎大佬" /></p><blockquote><p>p ↔ q=(¬p∨q)∧(¬q∨p)</p></blockquote><ul><li>由于p,q互为充要条件,故p与q真值相同时等价式为真</li></ul><h2 id="命题"><a class="markdownIt-Anchor" href="#命题"></a> 命题</h2><p>设A为一个命题公式</p><ul><li>若A在所有赋值下都为真,则为重言式</li><li>若A在所有赋值下都为假,则为矛盾式</li><li>若至少有一组成真赋值,则为可满足式</li></ul><hr /><blockquote><p><em>不能被分解</em>,<em>真值确定</em>的简单陈述句称为<strong>简单命题</strong>(<em>原子命题</em>,<em>命题常项</em>)<br />真值可以变化的简单陈述句称为命题变项(<strong>不是命题!!!</strong>)<br />使用联结词联结简单命题形成的命题称为复合命题</p></blockquote><h2 id="逻辑等值式汇总"><a class="markdownIt-Anchor" href="#逻辑等值式汇总"></a> 逻辑等值式汇总</h2><p><strong>双重否定律</strong></p><ul><li><code>¬¬A ⇔ A</code></li></ul><p><strong>幂等律</strong></p><ul><li><code>A ∧ A ⇔ A</code></li><li><code>A ∨ A ⇔ A</code></li></ul><p><strong>交换律</strong></p><ul><li><code>A ∨ B ⇔ B ∨ A</code></li><li><code>A ∧ B ⇔ B ∧ A</code></li></ul><p><strong>结合律</strong></p><ul><li><code>(A ∧ B) ∧ C ⇔ A ∧ (B ∧ C)</code></li><li><code>(A ∨ B) ∨ C ⇔ A ∨ (B ∨ C)</code></li></ul><p><strong>分配律</strong></p><ul><li><code>A ∨ (B ∧ C) ⇔ (A ∨ B) ∧ (A ∨ C)</code></li><li><code>A ∧ (B ∨ C) ⇔ (A ∧ B) ∨ (A ∧ C)</code></li></ul><p><strong>德·摩根律</strong></p><ul><li><code>¬(A ∨ B) ⇔ ¬A ∧ ¬B</code></li><li><code>¬(A ∧ B) ⇔ ¬A ∨ ¬B</code></li></ul><p><strong>吸收律</strong></p><ul><li><code>A ∨ (A ∧ B) ⇔ A</code></li><li><code>A ∧ (A ∨ B) ⇔ A</code></li></ul><p><strong>零律</strong></p><ul><li><code>A ∨ 1 ⇔ 1</code></li><li><code>A ∧ 0 ⇔ 0</code></li></ul><p><strong>同一律</strong></p><ul><li><code>A ∨ 0 ⇔ A</code></li><li><code>A ∧ 1 ⇔ A</code></li></ul><p><strong>排中律</strong></p><ul><li><code>A ∨ ¬A ⇔ 1</code></li></ul><p><strong>矛盾律</strong></p><ul><li><code>A ∧ ¬A ⇔ 0</code></li></ul><p><strong>蕴涵等值式</strong></p><ul><li><code>A → B ⇔ ¬A ∨ B</code></li></ul><p><strong>等价等值式</strong></p><ul><li><code>A ↔ B ⇔ (A → B) ∧ (B → A)</code></li></ul><p><strong>假言易位（逆否命题）</strong></p><ul><li><code>A → B ⇔ ¬B → ¬A</code></li></ul><p><strong>等价否定等值式</strong></p><ul><li><code>A ↔ B ⇔ ¬A ↔ ¬B</code></li></ul><p><strong>归谬论</strong></p><ul><li><code>(A → B) ∧ (A → ¬B) ⇔ ¬A</code></li></ul><p><strong>对称差等值式</strong></p><ul><li><code>A ⊕ B ⇔ (A ∨ B) ∧ ¬(A ∧ B)</code></li><li><code>A ⊕ B ⇔ (A ∧ ¬B) ∨ (¬A ∧ B)</code></li></ul><h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2><h3 id="合取范式和析取范式"><a class="markdownIt-Anchor" href="#合取范式和析取范式"></a> 合取范式和析取范式</h3><blockquote><p>析取范式:由有限个简单合取式构成的析取式<br />合取范式:由有限个简单析取式构成的合取式</p></blockquote><p><code>极小项:简单合取式中每个命题变项及其否定有且只有一个出现过一次</code><br /><code>极大项:简单析取式中每个命题变项及其否定有且只有一个出现过一次</code></p><blockquote><p>为什么说是极小项,因为所有命题的交集覆盖范围是最小的,效力最弱;而极大则是因为所有命题的并集覆盖范围是最大的,效力最强</p></blockquote><ul><li>若命题A的析取范式中所有合取式都是极小项,则称为A的<strong>主析取范式</strong></li><li>若命题A的合取范式中所有析取式都是极大项,则称为A的<strong>主合取范式</strong></li></ul><blockquote><p>这时可以对每个极小项进行编码成m(001),每个极大项为M(001)这样的形式,用角标来表示主析取范式和主合取范式</p></blockquote><h4 id="计算方法"><a class="markdownIt-Anchor" href="#计算方法"></a> 计算方法</h4><p>求A的主析取范式的方法</p><blockquote><p>若合取式B中不含命题变项p及其否定,则将B展开为合取形式B ∧ (p ∨ ¬p),消去重复出现的命题和极小项,将极小项按照角标由小到大的形式排列</p></blockquote><ul><li>至于为什么用合取形式而不是用析取形式B ∨(p ∧ ¬p),是因为要保证每个字式仍然是简单合取式</li></ul><blockquote><p>求出主析取范式后就可以求主合取范式了,主析取范式中没出现的极小项的角标作为极大项的角标,这些极大项构成的合取式为A的主合取范式.</p></blockquote><ul><li>当然反过来也是可以的</li></ul><h2 id="全功能集"><a class="markdownIt-Anchor" href="#全功能集"></a> 全功能集</h2><h1 id="一阶逻辑"><a class="markdownIt-Anchor" href="#一阶逻辑"></a> 一阶逻辑</h1><h2 id="个体与谓词"><a class="markdownIt-Anchor" href="#个体与谓词"></a> 个体与谓词</h2><blockquote><ul><li>个体常项:表示具体或特定个体的词,用a,b,c…表示</li><li>个体变项:表示抽象或泛指个体的词,用x,y,z…表示</li><li>个体变项的取值范围称为个体域<br />当无特殊声明时,个体域可以表示所有事物,称为全总个体域</li><li>谓词常项与谓词变项和上述概念对应,用F,G,H…表示<br />谓词中包含的个体数称为元数,n元谓词含有n个个体词,0元谓词就是简单命题</li></ul></blockquote><h2 id="合式公式"><a class="markdownIt-Anchor" href="#合式公式"></a> 合式公式</h2><blockquote><p>合式公式:也叫谓词公式,简称<strong>公式</strong>,看做是命题A加上量词或者个体变项后的形态例如&quot;∀x(A∧B)&quot;就行了</p><p>在&quot;∀xA&quot;,&quot;∃xA&quot;中的x称为指导变项,A为相应量词的辖域,在辖域x的所有出现称为约束出现,不受辖域约束的出现称为自由出现</p></blockquote><ul><li>若公式A中<strong>无自由出现的个体变项</strong>,则称A为封闭的合式公式,简称闭式</li></ul><blockquote><p><strong>换名规则</strong>: 将一个指导变项及其在辖域中所有的约束出现替换成没出现过的个体变项符号</p></blockquote><ul><li>换句话说换名就是让公式中不存在既是自由出现又是约束出现的个体变项</li></ul><p>解释: 对公式A中出现的每个个体常项和谓词变项进行赋值,由以下四部分构成</p><ol><li>非空个体域D</li><li>给个体常项指定一个D中的元素</li><li>给函数变项指定一个D上的函数</li><li>给谓词变项指定一个D上的谓词</li></ol><blockquote><p>这个时候∀可以看作是∧,∃就看作是∨,这个通过下面的例题就很好理解了</p></blockquote><p><strong>例子</strong><br /><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2026-01-05_12-59-09.webp" alt="alt text" /></p><ul><li>(1)中直接把x=2和x=3的情况用∧连接了</li></ul><h2 id="等值式和前束范式"><a class="markdownIt-Anchor" href="#等值式和前束范式"></a> 等值式和前束范式</h2><blockquote><p>等值式:若A ↔ B为永真式,则称A与B是等值的,记作<code>A⇔B</code><br />前束范式:A=QB,其中Q为∀x或者∃x这样的形式,B为不含量词的谓词公式</p></blockquote><h3 id="一-量词否定等值式"><a class="markdownIt-Anchor" href="#一-量词否定等值式"></a> 一、量词否定等值式</h3><ul><li><code>¬∀xA(x) ⇔ ∃x¬A(x)</code></li><li><code>¬∃xA(x) ⇔ ∀x¬A(x)</code></li></ul><h3 id="二-量词辖域收缩与扩张等值式b-中不含-x"><a class="markdownIt-Anchor" href="#二-量词辖域收缩与扩张等值式b-中不含-x"></a> 二、量词辖域收缩与扩张等值式（B 中不含 x）</h3><ul><li><p><code>∀x(A(x) ∨ B) ⇔ ∀xA(x) ∨ B</code></p></li><li><p><code>∀x(A(x) ∧ B) ⇔ ∀xA(x) ∧ B</code></p></li><li><p><code>∀x(A(x) → B) ⇔ ∃xA(x) → B</code></p></li><li><p><code>∀x(B → A(x)) ⇔ B → ∀xA(x)</code></p></li><li><p><code>∃x(A(x) ∨ B) ⇔ ∃xA(x) ∨ B</code></p></li><li><p><code>∃x(A(x) ∧ B) ⇔ ∃xA(x) ∧ B</code></p></li><li><p><code>∃x(A(x) → B) ⇔ ∀xA(x) → B</code></p></li><li><p><code>∃x(B → A(x)) ⇔ B → ∃xA(x)</code></p></li></ul><h3 id="三-量词分配等值式"><a class="markdownIt-Anchor" href="#三-量词分配等值式"></a> 三、量词分配等值式</h3><ul><li><code>∀x(A(x) ∧ B(x)) ⇔ ∀xA(x) ∧ ∀xB(x)</code></li><li><code>∃x(A(x) ∨ B(x)) ⇔ ∃xA(x) ∨ ∃xB(x)</code></li></ul><p>注意到∀对∨是不可分配的,∃对∧是不可分配的,这也很好理解.</p><blockquote><p>因为含有B的公式中的约束变元x都本应该写成y(防止与A中的x相同),但在<code>∀xA(x) ∧ ∀yB(y)</code>中由于<code>∧</code>需要满足两边式子都成立,因此x=y时也要成立,所以可以写成<code>∀x(A(x) ∧ B(x))</code>,而若 是<code>∀xA(x) ∨ ∀yB(y)</code>只需要有一边式子成立,故当x=y时可能有一边不满足.</p><p>同时,<code>∃xA(x) ∨ ∃yB(y)</code>由于只要找到一个数z满足一边条件就能让式子成立,无论是x=z还是y=z都可以,因此可以写成<code>∃x(A(x) ∨ B(x)) </code>,而<code>∃xA(x) ∧ ∃yB(y)</code>中由于需要找到两个数z1,z2使得这个式子满足,而这两个数不一定相等,故不能合并.</p></blockquote><h1 id="集合与关系"><a class="markdownIt-Anchor" href="#集合与关系"></a> 集合与关系</h1><h2 id="集合运算"><a class="markdownIt-Anchor" href="#集合运算"></a> 集合运算</h2><h3 id="对称差"><a class="markdownIt-Anchor" href="#对称差"></a> 对称差</h3><ul><li><code>A ⊕ B = (A − B) ∪ (B − A)</code></li><li><code>A ⊕ B = (A ∪ B) − (A ∩ B)</code></li></ul><blockquote><p>对称差运算满足结合律,交换律,分配律,消去律<br />其中分配律最难理解</p></blockquote><p>证明：<code>A ∩ (B ⊕ C) = (A ∩ B) ⊕ (A ∩ C)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A ∩ (B ⊕ C)</span><br><span class="line">= A ∩ [(B − C) ∪ (C − B)]</span><br><span class="line">= [A ∩ (B − C)] ∪ [A ∩ (C − B)]</span><br><span class="line">= [(A ∩ B) − (A ∩ C)] ∪ [(A ∩ C) − (A ∩ B)]</span><br><span class="line">= (A ∩ B) ⊕ (A ∩ C)</span><br></pre></td></tr></table></figure><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-25_21-34-39.webp" alt="" /></p><p><strong>重要的德摩根律</strong><br /><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-25_21-37-39.webp" alt="" /></p><h2 id="关系的定义"><a class="markdownIt-Anchor" href="#关系的定义"></a> 关系的定义</h2><p><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-49-58.webp" alt="定义" /></p><ul><li>A到A的关系R称为A上的关系<br /><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_14-53-32.webp" alt="" /></li></ul><h2 id="关系的几种性质"><a class="markdownIt-Anchor" href="#关系的几种性质"></a> 关系的几种性质</h2><p>这里都是对于A上的关系R进行展开的</p><table><thead><tr><th><strong>性质名称</strong></th><th><strong>定义</strong></th><th><strong>关系矩阵特点</strong></th><th><strong>关系图特点</strong></th></tr></thead><tbody><tr><td><strong>自反性</strong></td><td><code>∀x∈A，(x,x)∈R</code></td><td><strong>主对角线元素全为 <code>1</code></strong></td><td><strong>每个结点都有自环</strong></td></tr><tr><td><strong>反自反性</strong></td><td><code>∀x∈A，(x,x)∉R</code></td><td><strong>主对角线元素全为 <code>0</code></strong></td><td><strong>所有结点均无自环</strong></td></tr><tr><td><strong>对称性</strong></td><td><code>∀x,y∈A，(x,y)∈R ⇒ (y,x)∈R</code></td><td><strong>矩阵关于主对角线对称</strong></td><td><strong>任一有向边必有反向边</strong></td></tr><tr><td><strong>反对称性</strong></td><td><code>∀x,y∈A，(x,y)∈R 且 (y,x)∈R ⇒ x=y</code></td><td><strong>主对角线外不出现对称的 <code>1</code></strong></td><td><strong>不同结点间不能出现双向边</strong></td></tr><tr><td><strong>传递性</strong></td><td><code>∀x,y,z∈A，(x,y)∈R 且 (y,z)∈R ⇒ (x,z)∈R</code></td><td><strong>若 <code>m_xy=1</code> 且 <code>m_yz=1</code>，则 <code>m_xz=1</code></strong></td><td><strong>存在长度为 2 的路径则必须有直接边</strong></td></tr></tbody></table><p>注意到反对称和对称可以是在单位矩阵中同时存在,因为两个对称位置都为0也可以认为是反对称的</p><h2 id="关系闭包"><a class="markdownIt-Anchor" href="#关系闭包"></a> 关系闭包</h2><p><img src="../images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-27_16-02-46.webp" alt="" /></p><h3 id="自反闭包"><a class="markdownIt-Anchor" href="#自反闭包"></a> 自反闭包</h3><ul><li><code>R(r) = R ∪ &#123;(x,x) | x ∈ A&#125;</code><br />相当于加上单位矩阵I</li></ul><h3 id="对称闭包"><a class="markdownIt-Anchor" href="#对称闭包"></a> 对称闭包</h3><ul><li><code>R(s) = R ∪ R⁻¹</code><br />补全另一半即可</li></ul><h3 id="传递闭包"><a class="markdownIt-Anchor" href="#传递闭包"></a> 传递闭包</h3><ul><li><code>R(t) = R ∪ R² ∪ R³ ∪ ···</code><br />这个只好一个个推了,不出错就行’</li></ul><h2 id="划分"><a class="markdownIt-Anchor" href="#划分"></a> 划分</h2><p>即将集合A分成多个不相交的子集的并集,每个子集称为划分块</p><h2 id="等价关系与偏序关系"><a class="markdownIt-Anchor" href="#等价关系与偏序关系"></a> 等价关系与偏序关系</h2><blockquote><p>等价关系:要求集合A上的R关系是自反,对称,传递的.<br />偏序关系:要求集合A上的R关系是自反,反对称,传递的.</p></blockquote><ul><li><em>从定义可以知道偏序关系图中不存在双向箭头.</em></li><li><em>注意下面的小于等于只是表示偏序关系中的上下级关系</em></li></ul><blockquote><p><strong>偏序集</strong>:A与A上的偏序关系R一起称做偏序集,记为&lt;A,R&gt;,对于任意的x,y∈A,若x&lt;=y或者y&lt;=x成立,则称x与y是可比的,若x&lt;y,且x与y之间不存在z∈A使得x&lt;z&lt;y,则称y盖住x.</p></blockquote><ul><li>简略一点说,y盖住x表示y是x的直属上司,y与x可比表示二者在同一条分支上,具有亲缘关系</li></ul><blockquote><p><strong>全序集</strong>:若偏序集中∀x,y∈A,x与y都可比,则称(A,&lt;=)是全序集</p></blockquote><blockquote><p>设 (A, ≤) 为偏序集，B ⊆ A。</p><ul><li><strong>最小元</strong>：若存在 m ∈ B，使得 ∀x ∈ B，都有 m ≤ x，则称 m 为 B 的最小元。</li><li><strong>最大元</strong>：若存在 M ∈ B，使得 ∀x ∈ B，都有 x ≤ M，则称 M 为 B 的最大元。</li><li><strong>极小元</strong>：若 m ∈ B，且不存在 x ∈ B 使得 x &lt; m，则称 m 为 B 的极小元。</li><li><strong>极大元</strong>：若 M ∈ B，且不存在 x ∈ B 使得 M &lt; x，则称 M 为 B 的极大元。</li></ul><hr /><ul><li><strong>上界</strong>：若 u ∈ A，使得 ∀x ∈ B，都有 x ≤ u，则称 u 为 B 的一个上界。</li><li><strong>下界</strong>：若 l ∈ A，使得 ∀x ∈ B，都有 l ≤ x，则称 l 为 B 的一个下界。</li><li><strong>最小上界</strong>：u是B的上界集合中的最小元，则称 u 为 B 的最小上界。</li><li><strong>最大下界</strong>：l是B的下界集合中的最大元，则称 l 为 B 的最大下界。</li></ul></blockquote><ul><li>简单一点说,最大元就是跟所有元素都可比,故需要位于哈斯图的上顶点,约束所有分支,故只能有一个,同理,最小元位于哈斯图的下顶点,只能有一个</li><li>极小元和极大元可以有多个,只要位于某一条分支的上顶点或者下顶点就可以了,因此最大元也是极小元,最小元也是极大元.</li><li>如果有多个极大元,就一定没有最大元,有多个极小元,就一定没有最小元,因为分支没有收束.</li><li>上界可以看成是偏序集中所有元素的上司,可以有多个,但最小上界只能有一个</li></ul><blockquote><p>我想到的问题:如果一个偏序子集B上方连接的两个直属上司构成了一个三角形时还会有最小上界吗</p></blockquote><ul><li>经过思考后我发现偏序关系图中<strong>不存在三角形</strong>,因为反对称性决定了<code>如果a&lt;=b,b&lt;=a则a=b</code>,故不会有两个分支在同级连接的情况,否则两个元素就相互可比了.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命题逻辑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#命题逻辑&quot;&gt;&lt;/a&gt; 命题逻辑&lt;/h1&gt;
&lt;h2 id=&quot;逻辑联结词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#逻辑联结词&quot;&gt;&lt;/a&gt; 逻辑联结词&lt;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-25 cocos模块学习</title>
    <link href="https://revival-of-hope.github.io/2025/12/25/archives-2025-2025-12-25-cocos%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/25/archives-2025-2025-12-25-cocos%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-12-25T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cocos命令">cocos命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143 -DUSE_COCOS_ENGINE=OFF -DBUILD_APP=OFF -DBUILD_TESTS=ON</span><br><span class="line">cmake --build build -j10</span><br><span class="line">ctest --test-dir build --output-on-failure</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143 -DUSE_COCOS_ENGINE=ON -DBUILD_APP=ON -DBUILD_TESTS=OFF</span><br><span class="line">cmake --build build --config Debug -j12</span><br></pre></td></tr></table></figure><p><code>cocos new &lt;项目名&gt;  -l cpp</code><br>当前目录下生成<br><code>cmake -S . -B build -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143</code><br>在新项目里强制改cmake方式,其中-s指定cmakelists目录,-b指定build生成文件夹名字,-g指定编译器<br><code>cmake --build build j10</code></p><p>新增加文件时,在cmake里面加入对应的文件路径<br>再运行<code>cmake .</code>就行了<br>resource目录下的文件默认会全部添加,不用改cmakelists,而cpp和头文件需要手动添加,或者换成默认全部添加的代码<br>之后在build文件夹运行cmake …后即可<br>单纯修改文件时会同步修改,不用担心</p><p><code>cmake -S . -G &quot;Visual Studio 17 2022&quot; -A win32 -T v143</code></p><h2 id="概念部分">概念部分</h2><p>精灵:可以理解为人物和物品,是可操作的对象<br>label: 可以理解为字幕,大到开始界面标题,小到物品资源名字,都能用</p><h2 id="初始化部分">初始化部分</h2><p>写好场景的h文件和cpp文件后,在AppDelegate.cpp里使用并运行</p><h3 id="加载场景">加载场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myScene = Scene::<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//runWithScene() 用于开始游戏，加载第一个场景。只用于第一个场景！</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">runWithScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//replaceScene() 使用传入的场景替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">replaceScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pushScene() 将当前运行中的场景暂停并压入到场景栈中，再将传入的场景设置为当前运行场景。只有存在正在运行的场景时才能调用该方法。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">pushScene</span>(myScene);</span><br><span class="line"></span><br><span class="line"><span class="comment">//popScene() 释放当前场景，再从场景栈中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。</span></span><br><span class="line">Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">popScene</span>();</span><br></pre></td></tr></table></figure><h2 id="窗口部分">窗口部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> visibleSize = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleSize</span>();</span><br><span class="line">    <span class="comment">//窗口对角线向量,这个向量可以调用visibleSize.width</span></span><br><span class="line">    <span class="comment">//和visibleSize.height两个子属性</span></span><br><span class="line">    <span class="keyword">auto</span> origin = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleOrigin</span>();</span><br><span class="line">    <span class="comment">//左下角坐标(0,0)</span></span><br></pre></td></tr></table></figure><p>在AppDelegate.cpp下有一行<br><code>glview = GLViewImpl::createWithRect(&quot;test&quot;, cocos2d::Rect(0, 0, designResolutionSize.width, designResolutionSize.height));</code><br>修改designResolutionSize为其他大小(如largeResolutionSize)即可修改窗口默认大小</p><h2 id="创建部分">创建部分</h2><h3 id="创建元素">创建元素</h3><p><strong>所有创建的精灵和场景,动作都会自动销毁</strong><br><em>创建精灵</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> child = Sprite::<span class="built_in">create</span>(<span class="string">&quot;Images/test.png&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> mySprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;mysprite.png&quot;</span>, <span class="built_in">Rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>));</span><br><span class="line"><span class="comment">//可以指定裁剪区域,(0,0)为左上角坐标,大小为200X200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多边形精灵.</span></span><br><span class="line"><span class="keyword">auto</span> pinfo = AutoPolygon::<span class="built_in">generatePolygon</span>(<span class="string">&quot;filename.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sprite with polygon info.</span></span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::<span class="built_in">create</span>(pinfo);</span><br></pre></td></tr></table></figure><p><a href="https://docs.cocos.com/cocos2d-x/manual/zh/sprites/spritesheets.html">还可以使用图集来创建</a></p><p><em>创建label</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> label = Label::<span class="built_in">createWithTTF</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, <span class="number">16.0f</span>);</span><br><span class="line"><span class="keyword">auto</span> label = Label::<span class="built_in">create</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, <span class="number">16.0f</span>);</span><br><span class="line"><span class="comment">//两种方法均可以,下面一种在字体不能正常加载时使用系统字体,那我肯定用下面一种啊</span></span><br></pre></td></tr></table></figure><p><em>创建menu</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最复杂的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建一个image对象</span></span><br><span class="line"><span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(</span><br><span class="line">                                        <span class="string">&quot;CloseNormal.png&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">                                        <span class="built_in">CC_CALLBACK_1</span>(HelloWorld::menuCloseCallback,<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//可以用回调函数,但用lamda表达式更像人类一点,官方例子如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 lambda 表达式作为菜单项的回调函数：</span></span><br><span class="line"><span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(<span class="string">&quot;CloseNormal.png&quot;</span>, <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">[&amp;](Ref* sender)&#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还是看不懂的话有以下例子</span></span><br><span class="line"><span class="keyword">auto</span> showPlayerDlgItem = MenuItemImage::<span class="built_in">create</span>(<span class="string">&quot;Images/Pea.png&quot;</span>,</span><br><span class="line">                                               <span class="string">&quot;Images/Pea.png&quot;</span>,</span><br><span class="line">                                               [<span class="keyword">this</span>](Ref* sender)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_playerDlg-&gt;<span class="built_in">setVisible</span>(!<span class="keyword">this</span>-&gt;_playerDlg-&gt;<span class="built_in">isVisible</span>());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//简单说来就是点击这个菜单图片会发生什么</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在用图像来创建菜单</span></span><br><span class="line"><span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem,closeItem2,closeItem3, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//可以一直叠下去</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指定元素位置-菜单-ui组件通用">指定元素位置(菜单,UI组件通用)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(origin.x,origin.y));</span><br><span class="line">child-&gt;<span class="built_in">setPosition</span>(<span class="built_in">vec2</span>(visibleSize/<span class="number">2</span>));</span><br><span class="line"><span class="comment">//两种方法都可以</span></span><br></pre></td></tr></table></figure><p><strong>改变精灵的中心点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DEFAULT anchor point for all Sprites</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom left</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// top left</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bottom right</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// top right</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setAnchorPoint</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="将元素加入指定图层-通用">将元素加入指定图层(通用)</h3><p><code>this-&gt;addChild(child, 1,people);</code></p><blockquote><p>原定义部分<br>void Node::addChild(Node *child, int localZOrder, int tag)</p></blockquote><p>即第一个参数是元素名称,第二个参数是指定图层坐标,第三个参数是标签,<br>后两个均为可选</p><h2 id="动作部分">动作部分</h2><h3 id="旋转">旋转</h3><p>通过 setRotation() 方法，设置一个角度值可以控制精灵的旋转，正值精灵顺时针旋转，负值精灵逆时针旋转，默认位置的角度值是 0.0。<br><code>mySprite-&gt;setRotation(20.0f);</code></p><h3 id="缩放">缩放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// increases X and Y size by 2.0 uniformly</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScale</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increases just X scale by 2.0</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScaleX</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// increases just Y scale by 2.0</span></span><br><span class="line">mySprite-&gt;<span class="built_in">setScaleY</span>(<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p><strong>动作中的缩放方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scale uniformly by 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleBy = ScaleBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleBy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale X by 2 and Y by 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleBy = ScaleBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleBy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale to uniformly to 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleTo = ScaleTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scale X to 2 and Y to 3x over 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> scaleTo = ScaleTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(scaleTo);</span><br></pre></td></tr></table></figure><h3 id="移动">移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move sprite to position 50,10 in 2 seconds.</span></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">50</span>, <span class="number">10</span>));</span><br><span class="line">mySprite1-&gt;<span class="built_in">runAction</span>(moveTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move sprite 20 points to right in 2 seconds</span></span><br><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">20</span>,<span class="number">0</span>));</span><br><span class="line">mySprite2-&gt;<span class="built_in">runAction</span>(moveBy);</span><br></pre></td></tr></table></figure><p>注意到每个动作都要先创建为对象再用runAction执行</p><p><strong>可以创建一个移动序列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> moveBy = MoveBy::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">500</span>, mySprite-&gt;<span class="built_in">getPositionY</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// MoveTo - lets move the new sprite to 300 x 256 over 2 seconds</span></span><br><span class="line"><span class="comment">// MoveTo is absolute - The sprite gets moved to 300 x 256 regardless of</span></span><br><span class="line"><span class="comment">// where it is located now.</span></span><br><span class="line"><span class="keyword">auto</span> moveTo = MoveTo::<span class="built_in">create</span>(<span class="number">2</span>, <span class="built_in">Vec2</span>(<span class="number">300</span>, mySprite-&gt;<span class="built_in">getPositionY</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delay - create a small delay</span></span><br><span class="line"><span class="keyword">auto</span> delay = DelayTime::<span class="built_in">create</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> seq = Sequence::<span class="built_in">create</span>(moveBy, delay, moveTo, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(seq);</span><br></pre></td></tr></table></figure><p>注意到cocos里面用到数组对象时总要指定最后一位为空指针</p><p>查看源码发现runAction指接收一个参数,也就是说延迟动作只能显示写一个delay对象实现</p><h3 id="色彩混合">色彩混合</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mySprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;mysprite.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tints a node to the specified RGB values</span></span><br><span class="line"><span class="keyword">auto</span> tintTo = TintTo::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">120.0f</span>, <span class="number">232.0f</span>, <span class="number">254.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(tintTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tints a node BY the delta of the specified RGB values.</span></span><br><span class="line"><span class="keyword">auto</span> tintBy = TintBy::<span class="built_in">create</span>(<span class="number">2.0f</span>, <span class="number">120.0f</span>, <span class="number">232.0f</span>, <span class="number">254.0f</span>);</span><br><span class="line">mySprite-&gt;<span class="built_in">runAction</span>(tintBy);</span><br></pre></td></tr></table></figure><p>可用于实现药水对兵种的作用效果</p><h2 id="瓦片地图">瓦片地图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建地图</span></span><br><span class="line">map=TMXTiledMap::<span class="built_in">create</span>(<span class="string">&quot;test.tmx&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//瓦片处理</span></span><br><span class="line">Size tileSize = map-&gt;<span class="built_in">getTileSize</span>();        <span class="comment">// 单个瓦片像素大小（如 64x64）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放地图</span></span><br><span class="line"><span class="comment">// Step 1: 计算横竖各能放多少个完整瓦片（向下取整）</span></span><br><span class="line"><span class="type">int</span> maxTilesX = (<span class="type">int</span>)(visibleSize.width / tileSize.width);</span><br><span class="line"><span class="type">int</span> maxTilesY = (<span class="type">int</span>)(visibleSize.height / tileSize.height);</span><br><span class="line"><span class="comment">//注意到这里的visiblesize根据需要选择获取全屏还是裁剪掉菜单栏的区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止除零或瓦片太大的情况</span></span><br><span class="line"><span class="keyword">if</span> (maxTilesX &lt;= <span class="number">0</span>) maxTilesX = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (maxTilesY &lt;= <span class="number">0</span>) maxTilesY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 计算两种缩放比例</span></span><br><span class="line"><span class="type">float</span> scaleIfFitWidth = visibleSize.width / (maxTilesX * tileSize.width);</span><br><span class="line"><span class="type">float</span> scaleIfFitHeight = visibleSize.height / (maxTilesY * tileSize.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 选择「宁可裁掉一点地图，也绝不留黑边」的策略 → 取较大值</span></span><br><span class="line"><span class="type">float</span> finalScale = std::<span class="built_in">max</span>(scaleIfFitWidth, scaleIfFitHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 应用缩放 + 严格左上角对齐 + 防1像素缝隙</span></span><br><span class="line">map-&gt;<span class="built_in">setScale</span>(finalScale);</span><br><span class="line">map-&gt;<span class="built_in">setAnchorPoint</span>(<span class="built_in">Vec2</span>(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">// 左上角为锚点</span></span><br><span class="line">map-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(<span class="number">-0.5f</span>, visibleSize.height + <span class="number">0.5f</span>));   </span><br></pre></td></tr></table></figure><p>尽管写了这么多,但最后我还是用AI完成绝大部分代码的,AI的文献阅读能力让期末周的我泪流满面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cocos命令&quot;&gt;cocos命令&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-24 病毒攻击</title>
    <link href="https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/</id>
    <published>2025-12-24T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>下了一个破解版游戏,结果火绒直接弹出窗口提示我有三百多个exe感染了jadtre ax 病毒<br><img src="/images/archives/2025/2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/PixPin_2025-12-24_09-58-14.webp" alt=""></p><p>到这个时候我才发现我对网络安全实际上是一窍不通,<br>只好先用火绒把所有感染的exe放到隔离区,然后来了一个全盘扫描,我以后一定要好好研究一下计算机的底层知识和病毒攻击原理.</p><p>首先我找到了<a href="https://www.virusview.net/malware/Virus/Win32/Jadtre">计算机病毒百科</a>里关于这个病毒的详细信息</p><blockquote><p>它会修改系统文件，包括操作系统的关键文件，以隐藏自身并且避免被杀软检测到。<br>该病毒会通过劫持用户的浏览器、修改主页和搜索引擎设置等方式，进行钓鱼攻击，诱导用户点击恶意链接，从而进一步传播病毒。<br>它会窃取用户的个人敏感信息，如登录密码、银行账号等，并将这些信息发送到黑客的服务器上。<br>病毒会利用系统的漏洞，进行远程控制，从而盗取用户的隐私信息或者操控计算机进行其他恶意行为。<br>该病毒还会利用系统资源进行挖矿或者进行分布式拒绝服务（DDoS）攻击。<br>它会禁用或损坏杀软程序的功能，以保证自身不被杀软识别和清除。</p></blockquote><p>发现它主要是诱导用户点击恶意链接,还好火绒直接帮我拦截了网页跳转.</p><p>顺藤摸瓜找到了这个<a href="https://www.antiycloud.com/#/antiy/safeinfor">网站</a>,我才发现网络安全确实是一个壁垒高却极为重要的领域,<br>想着在网上找一点入门教程,结果用中文搜全是AI文章或者垃圾文字,再一次体会到中文互联网的封闭性,只好问gpt,找到了以下网站:</p><blockquote><p>By Sunday evening, you could have taken your first real step into cybersecurity.<br>Here are 15 websites to kick-start your cybersecurity journey (all beginner-friendly):<br>1.TryHackMe  – Hands-on labs for all skill levels<br><a href="https://tryhackme.com">https://tryhackme.com</a><br>2.Hack The Box  – Gamified hacking challenges<br><a href="https://www.hackthebox.com">https://www.hackthebox.com</a><br>3.Blue Team Labs Online  – Defensive security scenarios<br><a href="https://lnkd.in/dckAehnQ">https://lnkd.in/dckAehnQ</a><br>4.OverTheWire – Fun war games to learn Linux &amp; networking<br><a href="https://lnkd.in/d66wAqDb">https://lnkd.in/d66wAqDb</a><br>5.PortSwigger Web Security Academy – Web app hacking from the pros<br><a href="https://lnkd.in/dyrBGjRh">https://lnkd.in/dyrBGjRh</a><br>6.VulnHub – Download vulnerable machines and hack away<br><a href="https://www.vulnhub.com">https://www.vulnhub.com</a><br>7.LetsDefend  – SOC analyst simulation<br><a href="https://letsdefend.io">https://letsdefend.io</a><br>8.CyberDefenders  – Threat hunting and forensics labs<br><a href="https://cyberdefenders.org">https://cyberdefenders.org</a><br>9.CTFtime – Find Capture the Flag competitions<br><a href="https://ctftime.org">https://ctftime.org</a><br>10.Security Blue Team  – Blue teaming certifications and practice<br><a href="https://lnkd.in/dmuUFfQX">https://lnkd.in/dmuUFfQX</a><br>11.PentesterLab – Web security training<br><a href="https://pentesterlab.com">https://pentesterlab.com</a><br>12.MITRE ATT&amp;CK – Learn real adversary tactics and techniques<br><a href="https://attack.mitre.org">https://attack.mitre.org</a><br>13.OWASP – Secure coding &amp; app security resources<br><a href="https://owasp.org">https://owasp.org</a><br>14.DFIR Diva – Free digital forensics resources<br><a href="https://dfirdiva.com">https://dfirdiva.com</a><br>15.Flare-On Challenges – Reverse engineering practice<br><a href="https://flare-on.com">https://flare-on.com</a></p></blockquote><blockquote><p><a href="https://github.com/404notf0und/Security-Data-Analysis-and-Visualization">找到了一个汇总链接</a><br>不多说了,尽管期末周快来了,兴趣学习的时间还是有的,开练.</p></blockquote><hr><p><strong>25号更新</strong><br>一开始我觉得这个病毒没什么危害性,就又把火绒隔离区里的exe给恢复了,现在发现我确实是智障,今晚扫描全盘发现基本所有的exe文件都被感染了,<br>里面有几百款游戏exe和工具exe,受不了了,太蠢了这也.我决定不再点击恢复文件,只能把这些文件全部删掉了.<br>好的,这下真的激发我对网络安全的兴趣了,做病毒真有这么好玩吗(😡)</p><p>这件事还让我看到火绒并不好用,虽然平时没什么弹窗打扰我,但是一但出事一点都救不了我.<br>病急乱投医,我甚至下载了360来试试,果不其然,连安装页面都没弹出来,就已经在修改我的注册表了,去你的吧!</p><p>然后看了看别人的推荐,又综合了各种考虑,先拿卡巴斯基来试试全盘扫描,竟然要花9个小时多.</p><p><strong>26号更新</strong><br>今天早上来看,发现问题并没有那么严重,大多数都是火绒的误报,我把那些隔离区里的exe上传到<a href="https://internxt.com/virus-scanner">文件病毒检测网站</a>里发现根本没有病毒,受不了了.而卡巴斯基也成功地把那些真正的病毒删除干净了,滚吧您呐,让我投入卡巴斯基的怀抱吧!</p><h3 id="参考链接">参考链接</h3><p><a href="https://iliu.org/thoughts-on-struggling-with-antivirus-software/">1</a><br><a href="https://meledee.com/2025/03/4617.html">2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下了一个破解版游戏,结果火绒直接弹出窗口提示我有三百多个exe感染了jadtre ax 病毒&lt;br&gt;
&lt;img src=&quot;/images/archives/2025/2025-12-24-%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB/PixPin</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-24 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/24/archives-2025-2025-12-24-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-24T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/">来源</a><br>我是一个习惯于早做规划与反复思索的人。<br>而坚持写博客最大的好处就是，可以时不时翻看之前写的文章，宛若跨越时间的荆棘，与曾经的自己促膝长谈。</p></blockquote><blockquote><p>现在想来，十九岁时，我的迷惘归结下来，即是对将来自己的出路无所适从：出国留学，国内升学，抑或是早日进入职场。这几条路上，都有前人留下的无数足迹与丰碑，但也无可避免地悬着前人用泪水濯洗的种种失败警示牌。我曾尝试从中选出最优解，然而反复的纠结过后，我所意识到的，是这种比较的注定无结果：每当我觉得某个选择优于其他选择时，总会有某些信息刷新我的认知，让我匆忙撤回自己的决定。一如盲人同时摸象与鲸鱼，用片面的认知去比较复杂的事物，注定失败。</p></blockquote><blockquote><p>先是出国。关于这个选项，我曾仔细考虑，然而最终出于经济上的原因（赴美读硕开销实在过于昂贵）和人生规划的原因（<strong>我对学术无甚兴趣，不愿耗费多年去追求博士学位</strong>），出国成为了三者中第一个被排除的选项。而站在当下（2020 年）来看，全球疫情的扩散与民族主义情绪的对立，出国虽然依旧有着不可抗拒的诱惑力（比如优渥的学术环境与工作环境），但是更显得充满了极度未知的不确定性。</p></blockquote><blockquote><p>「选择比努力更重要。」这句话近年来已经广为人知，不少人以此自我调侃，感叹自己当初选择的失误（比如选错学校、选错专业），但当下一次选择到来时，却又不假思索地下意识地站到了主流的人群中，甚至拼尽全力挤出一条道路以加入主流人群。</p><p>诚然，作为一个才识普通的人，我或许不具备选择最合适的道路的能力，但我所希望的，是不盲从、不追随，依靠自身的观察与思考，尽量选出一条相对合适的道路。<br>人类的悲欢并不相通，但是相似。</p><p>关于读研与工作，面临同样困扰的也并非只有我一个人。</p><p>在做出决定的过程中，我阅读了不少人的博客与帖子，从中获得了一些宝贵的信息与经验，或多或少地影响了我最终的决定。</p><p>由于之前并未刻意保存浏览过的网页，在此，仅仅列出其中的一小部分：</p></blockquote><ul><li><a href="https://laike9m.com/blog/suo-yi-dao-di-yao-bu-yao-du-yan,119/">所以，到底要不要读研？ - laike9m’s blog</a></li><li><a href="http://gaocegege.com/Blog/%E9%9A%8F%E7%AC%94/master">研究生复盘 | 高策</a></li><li><a href="https://ipotato.me/article/65">iPotato | 在读研 &amp; 工作中选择后者</a></li><li><a href="https://www.v2ex.com/t/580275">已有名校 CS 本科学历，读研对于计算机行业的职业发展有多大的意义？ - V2EX</a></li></ul><p>这恰恰是我当下迷惘而又感到无路可走的心境,专业课程的枯燥与无用让我感到厌烦,愈加激烈的保研争夺战让我望而却步,而那些学术论文里面的水分都可以让海平面再升高一米了.</p><p>可日愈恶化的工作环境阻断了我得过且过的想法,作为雏鸟在第一家公司所学习的架构未必对我的技术提升有任何的助益,而我的学历劣势也将在很长一段时间内保持下去.</p><p>这种左右为难的状况让我一边痛苦一边踟蹰,只好到处翻阅博客,搜寻资源,希望能够对当前的我有些微的救赎.</p><p>这篇博客可惜的地方在于没有考虑到提前工作的坏处,但看了看他<a href="https://www.zackwu.com/posts/2025-11-26-think-long-term-and-work-hard/">最近的文章</a>,过得还算不错,可我现在还没有那个胆量去直接放弃保研,因为我讨厌唯一的选择,希望能多几条路可以走,而现在我仅仅是在本专业保研排名的边缘上(笑).这解释为是对我自己负责,但更可能只是我胆小罢了.</p><h2 id="题外话">题外话:</h2><p>博客是我最喜欢的信息传播方式,我永远都可以在某个博客里找到一些用一般手段怎么搜都搜不到的棘手问题的解决方案,永远都可以找到一个处境和你相似的人,永远都可以找到能够为你指引道路的人.</p><p>这半年来我搜集了差不多一百多个博客,我打算之后整理一下把里面的精华部分传到GitHub上,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/&quot;&gt;来源&lt;/a&gt;&lt;br&gt;
我是一个习惯于早做规划与反复思索的人。&lt;br&gt;
</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-21 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/21/archives-2025-2025-12-21-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/21/archives-2025-2025-12-21-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-21T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li></li></ol></blockquote><p><a href="https://ruanyf-weekly.vercel.app/weekly/issue-210">周刊210期</a><br>诺拉·劳森还说了一个观点。大家通常认为，复杂系统往往会在经济繁荣的时候崩溃，因为业务太多，支撑不过来，但他认为不是这样的，系统崩溃往往发生在经济收缩期。<br>经济繁荣时期，软件公司会大量雇佣新员工，投入更多的财力和人力，支撑复杂系统。等到经济收缩期，公司开始减少投入、冻结招聘或裁员，复杂系统可能就会在这个时候出问题，变得难以维护。<br>现在就是经济收缩期，那么接下来，会不会就是软件故障的高发期，我们将看到很多复杂系统的崩溃？</p><blockquote><ol start="2"><li></li></ol></blockquote><p>IT 行业与传统制造业有一个重要区别，就是 IT 行业有着严重的垄断。<br>全世界的智能手机有70亿部，比汽车多出5倍（14亿辆）。但是，智能手机制造商比汽车制造商少了好几个数量级。搜索引擎、社交网络、操作系统都是这样，几个巨头就垄断了整个市场。</p><blockquote><p>3.<a href="https://blog.amamiyayuuko.com/p/ai-new-bing/">来源</a><br>各个互联网公司都试图把自己的网站做成一个完全封闭的APP，你没法在搜索引擎上搜索到微信公众号的文章、小红书的内容、淘宝的商品描述……这就导致bing只能从非常有限的地方获得中文语料，最后就导致他的回答特别池沼……而且比别的AI都池沼十倍甚至九倍……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ruanyf-weekly.vercel.app/weekly/issue-210&quot;&gt;周刊210期&lt;/a&gt;&lt;br&gt;
诺拉·劳森还说了一个观点。大</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>重要文章存档</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-20T02:58:05.000Z</published>
    <updated>2026-01-01T10:11:09.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cpp构造与析构"><a class="markdownIt-Anchor" href="#cpp构造与析构"></a> <a href="https://blog.csdn.net/2501_91275995/article/details/156042381">cpp构造与析构</a></h2><h2 id="校招流程"><a class="markdownIt-Anchor" href="#校招流程"></a> <a href="https://www.zackwu.com/posts/2020-10-05-an-incomplete-guide-to-campus-recruitment-interviews/">校招流程</a></h2><h2 id="还是校招"><a class="markdownIt-Anchor" href="#还是校招"></a> <a href="https://blog.cugxuan.cn/2021/01/06/Campus/guide-capmus-v2/">还是校招</a></h2><h2 id="微软实习"><a class="markdownIt-Anchor" href="#微软实习"></a> <a href="https://ddadaal.me/articles/2019-spring-ms-intern-interview-experiences">微软实习</a></h2><h2 id="cpp书单"><a class="markdownIt-Anchor" href="#cpp书单"></a> <a href="https://csguide.cn/books/cpp.html">cpp书单</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cpp构造与析构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cpp构造与析构&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://blog.csdn.net/2501_91275995/article/details/156042381&quot;</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-20 数据结构重点例题分析</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/</id>
    <published>2025-12-20T00:00:00.000Z</published>
    <updated>2026-01-02T02:14:58.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="稀疏矩阵的三元组表"><a class="markdownIt-Anchor" href="#稀疏矩阵的三元组表"></a> 稀疏矩阵的三元组表</h2><p>三元组表需要把行,列,值分别列出来(意义在哪里?)<br /><img src="images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image.webp" alt="" /></p><p>甚至还要再写辅助数组rowSize和rowStart,把很明显的东西再写一遍,却又不考算法,没招了.</p><h2 id="链表反转"><a class="markdownIt-Anchor" href="#链表反转"></a> 链表反转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    LNode* q;</span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;   <span class="comment">// 断开头结点与原链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;      <span class="comment">// 保存后继</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;      <span class="comment">// 头插</span></span><br><span class="line">        p = q;            <span class="comment">// 处理下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴下代码就能看懂了,其实我觉得就是两端交换</p><h2 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h2><p><a href="https://www.cnblogs.com/Higurashi-kagome/p/18013626">参考1</a><br /><a href="https://www.xdull.cn/kmp.html">参考2</a><br />都讲的挺好.</p><p>重点是明确next数组的作用,之所以存储模式的对应字串最长公共前后缀,是因为当匹配失败时,原字符串中在匹配失败位置前的成功匹配部分刚好可以作为重置后的模式字符串的前缀,它同时也是先前匹配时得到对应长度模式字串的后缀.搞懂了这个就能彻底理解kmp了.</p><blockquote><p>例题: 设主串T=”abaabaabcabaabc”，模式串P=”abaabc”，采用KMP算法进行模式匹配，到匹配成功为止，在匹配过程中进行的单个字符间的比较次数是（ ）.</p></blockquote><blockquote><p>解题: int num=0,<br />先写出next数组[0,0,1,1,2,0],第一次匹配到abaab,num+=5,但由于失败的匹配也要算上,num+=1<br />指针移到后缀ab,接着比较找到abaabc,num+=4,故num=10</p></blockquote><h2 id="组合数求解"><a class="markdownIt-Anchor" href="#组合数求解"></a> 组合数求解</h2><blockquote><p>【例4】编写一个递归算法，找出从自<br />然数1,2,3,4,…,n中任取r个数的所有组<br />合。例如，n=5，r=3时的组合是543，<br />542，541，532，531，521，432，431<br />，421，321.</p><p>【解答】本问题就是求解组合数。<br />int Combin(int m, int n)<br />{ if(m<mark>n||n</mark>0) return 1;<br />else return Combin(m-1,n)+<br />Combin(m-1,n-1);}</p></blockquote><p>一开始是用dfs写的,但没想到ppt里根本没考虑把组合写出来,不过这个递归也挺难想到的.</p><h2 id="广义表"><a class="markdownIt-Anchor" href="#广义表"></a> 广义表</h2><blockquote><p>假设广义表是由带头节点的链<br />表存储，请画出广义表A(a, B((),<br />C(1)))的存储结构；假设head，tail分<br />别是求首元素操作和求尾表操作，求<br />如何获得元素1.</p></blockquote><p><img src="images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image2.webp" alt="解答" /><br />其中,一个结点的定义如下:</p><blockquote><p>utype = 0/1/2/3 ;<br />value = ref /intgrinfo /charinfo / hlink ;tlink</p></blockquote><p>0表示该节点为头节点,1表示为整数,2表示为char,3表示为子表节点,∧表示该节点为尾节点,指向该子表头节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GenList :: <span class="built_in">depth</span> ( GenListNode *ls ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ls→tlink == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//空表</span></span><br><span class="line">GenListNode *temp = ls→tlink;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( temp != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> <span class="comment">//横扫广义表</span></span><br><span class="line"><span class="keyword">if</span> ( temp→utype == LST ) &#123;</span><br><span class="line"> <span class="comment">//子表深度</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">depth</span> ( temp→value.hlink );</span><br><span class="line"><span class="keyword">if</span> ( m &lt; n ) m = n;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//不是子表不加深度</span></span><br><span class="line">temp = temp→tlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉链的应用"><a class="markdownIt-Anchor" href="#二叉链的应用"></a> 二叉链的应用</h2><blockquote><p>假设二叉树采用二叉链存储，设计一个算法Level()求二叉树中值为 x 的节点的层数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Level</span><span class="params">(BiNode *T, <span class="type">int</span> x, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data == x) <span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">Level</span>(T-&gt;lchild, x, level + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (l) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Level</span>(T-&gt;rchild, x, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树与森林典型例题"><a class="markdownIt-Anchor" href="#二叉树与森林典型例题"></a> 二叉树与森林典型例题</h2><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-34-19.webp" alt="题目" /></p><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-35-26.webp" alt="解答" /></p><h2 id="静态搜索表的应用"><a class="markdownIt-Anchor" href="#静态搜索表的应用"></a> 静态搜索表的应用</h2><h3 id="顺序搜索"><a class="markdownIt-Anchor" href="#顺序搜索"></a> 顺序搜索</h3><p><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-12-10.webp" alt="不能写个循环吗急死我了" /><br />还装模做样加一个概念ASL(Average Search Length)<br /><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-13-47.webp" alt="" /><br /><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-25_10-52-23.webp" alt="公式" /></p><h3 id="折半搜索"><a class="markdownIt-Anchor" href="#折半搜索"></a> 折半搜索</h3><p><img src="../images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-27_12-34-38.webp" alt="代码" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;稀疏矩阵的三元组表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#稀疏矩阵的三元组表&quot;&gt;&lt;/a&gt; 稀疏矩阵的三元组表&lt;/h2&gt;
&lt;p&gt;三元组表需要把行,列,值分别列出来(意义在哪里?)&lt;br /&gt;
&lt;img src=&quot;images/ar</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>我遇到的各种调试问题</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-19T01:58:56.000Z</published>
    <updated>2026-01-01T05:51:44.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode-powershell终端打字缺字漏字">vscode powershell终端打字缺字漏字</h2><p>解决方法:<br>搜索设置<br>Terminal &gt; Integrated &gt; Default Profile: Windows<br>换为cmd</p><h2 id="左斜线和右斜线问题">左斜线和右斜线问题</h2><p>windows路径都是,转义符是,而网页链接,linux都是/<br>解决方法:<br>在搜索框输入：“Explorer: Copy Relative Path Separator”<br>将\改为正斜杠/<br><a href="https://blog.csdn.net/kdz6511/article/details/148712726">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vscode-powershell终端打字缺字漏字&quot;&gt;vscode powershell终端打字缺字漏字&lt;/h2&gt;
&lt;p&gt;解决方法:&lt;br&gt;
搜索设置&lt;br&gt;
Terminal &amp;gt; Integrated &amp;gt; Default Profile: Windo</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-19 数据结构整理-(图论)</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/</id>
    <published>2025-12-19T00:00:00.000Z</published>
    <updated>2026-01-05T07:19:32.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="邻接矩阵和邻接表"><a class="markdownIt-Anchor" href="#邻接矩阵和邻接表"></a> 邻接矩阵和邻接表</h2><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_08-07-22.webp" alt="邻接矩阵图示" /><br />时间复杂度:O(n*n)<br /><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_08-37-15.webp" alt="无向图邻接表" /><br /><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_08-38-48.webp" alt="有向图邻接表" /></p><h3 id="邻接表的遍历"><a class="markdownIt-Anchor" href="#邻接表的遍历"></a> 邻接表的遍历</h3><p><strong>bfs</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxConnectedComponent</span><span class="params">(Graph&amp; g)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = g.n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> max_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; q = &#123;i&#125;;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; q.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="type">int</span> u = q[j];</span><br><span class="line">                ++size;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : g.adj[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                        visited[v] = <span class="literal">true</span>;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            max_size = <span class="built_in">max</span>(max_size, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dfs</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;  <span class="comment">// 当前结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">            cnt += <span class="built_in">dfs</span>(v, adj, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxConnectedComponent</span><span class="params">(<span class="type">int</span> n, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="type">int</span> size = <span class="built_in">dfs</span>(i, adj, visited);</span><br><span class="line">            <span class="keyword">if</span> (size &gt; maxSize)</span><br><span class="line">                maxSize = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用visited数组来保证取到所有的连通分量,从而找到最大连通分量<br />时间复杂度:O(n+e)</p><h2 id="bfs搜索"><a class="markdownIt-Anchor" href="#bfs搜索"></a> bfs搜索</h2><p>特点:使用队列,可以得到最短路径,无论是否会重复访问,都能一个节点一直是最优状态.<br />写法:<br /><strong>以大佬的八数码解法为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//转移数组；</span></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    map&lt;ll,ll&gt; m;</span><br><span class="line">    m[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); <span class="comment">//初始状态入队列</span></span><br><span class="line">        <span class="type">int</span> c[<span class="number">3</span>][<span class="number">3</span>],f=<span class="number">0</span>,g=<span class="number">0</span>,n=u;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">123804765</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=n%<span class="number">10</span>,n/=<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(!c[i][j])f=i,g=j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll nx=f+dx[i],ny=g+dy[i],ns=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||ny&lt;<span class="number">0</span>||nx&gt;<span class="number">2</span>||ny&gt;<span class="number">2</span>)<span class="keyword">continue</span>; <span class="comment">//越界就不执行</span></span><br><span class="line">            <span class="built_in">swap</span>(c[nx][ny],c[f][g]);</span><br><span class="line">            <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">                <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)ns=ns*<span class="number">10</span>+c[i][j];<span class="comment">//矩阵转数列 </span></span><br><span class="line">            <span class="keyword">if</span>(!m.<span class="built_in">count</span>(ns))</span><br><span class="line">            &#123;</span><br><span class="line">                m[ns]=m[u]<span class="number">+1</span>;<span class="comment">//map去重的同时顺便统计到达这个状态所需的步数</span></span><br><span class="line">                q.<span class="built_in">push</span>(ns);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(c[nx][ny],c[f][g]);<span class="comment">//状态复原</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m[<span class="number">123804765</span>]&lt;&lt;endl; <span class="comment">// map的下标直接用数列表示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dfs搜索"><a class="markdownIt-Anchor" href="#dfs搜索"></a> dfs搜索</h2><p>特点:有时候会使用栈,可以得到方案总数,有次数要求时使用这个方法.<br />写法:<br /><strong>以最经典的八皇后问题为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> col[N], d1[N], d2[N];  <span class="comment">// 列、主对角线、副对角线标记</span></span><br><span class="line"><span class="type">int</span> pos[N];                <span class="comment">// pos[x] = 皇后在第 x 行放的列号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                cout &lt;&lt; pos[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[c] || d1[row + c] || d2[row - c + n]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        col[c] = d1[row + c] = d2[row - c + n] = <span class="number">1</span>;</span><br><span class="line">        pos[row] = c;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        col[c] = d1[row + c] = d2[row - c + n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到,无论是dfs还是bfs,重点是将当前状态判定后再重置状态,保证后来的方案不会受到这次修改影响.</p><h2 id="dfs解疑"><a class="markdownIt-Anchor" href="#dfs解疑"></a> dfs解疑</h2><p>dfs有两种结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll sum)</span> </span>&#123;  <span class="comment">// 前一半</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">push_back</span>(sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(l<span class="number">+1</span>, r, sum);        <span class="comment">// 不选</span></span><br><span class="line">    <span class="built_in">dfs1</span>(l<span class="number">+1</span>, r, sum + a[l]);  <span class="comment">// 选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就像背包问题,一般都能用动态规划解决,每一步都只有两个分支</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在每一步都有多个选择</span><br></pre></td></tr></table></figure><p>(突然发现下面这部分期末不考算法,懒得挂代码上来了)<br />(第二次复习时需要画图补充)</p><h2 id="最小生成树算法"><a class="markdownIt-Anchor" href="#最小生成树算法"></a> 最小生成树算法</h2><h3 id="kruskal"><a class="markdownIt-Anchor" href="#kruskal"></a> kruskal</h3><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_09-33-05.webp" alt="" /><br />模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; other.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用lamda或许更好,这个重载太难理解了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5005</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">e</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按边权排序</span></span><br><span class="line">    <span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 已加入 MST 的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kruskal,用引用更安全</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ed : e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(ed.u) != <span class="built_in">find</span>(ed.v))&#123;</span><br><span class="line">            <span class="built_in">unite</span>(ed.u, ed.v);</span><br><span class="line">            ans += ed.w;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt != n - <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz\n&quot;</span>; <span class="comment">// 图不连通</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是用避圈法,难点是确保不形成圈,<br />用并查集来处理这我自己真想不出来,拿ai生成的我也不好意思在luogu上提交.<br />由于还是看不太懂,于是我用ai做了一个网页.</p><details><summary>点击展开 Kruskal 最小生成树演示</summary><p>下面是 Kruskal 最小生成树演示：</p><!-- Canvas 和按钮 --><canvas id="graphCanvas" width="600" height="400" style="border:1px solid #ccc;"></canvas><div style="margin-top:10px;">  <button id="nextStep">下一步</button>  <button id="reset">重置</button>  <span id="mstSum" style="margin-left:20px;">当前 MST 总权值: 0</span></div><script>// ------------------- 数据 -------------------const nodes = [  {id:0,x:100,y:100},{id:1,x:300,y:100},{id:2,x:500,y:100},  {id:3,x:200,y:300},{id:4,x:400,y:300}];const edges = [  {u:0,v:1,w:2},{u:0,v:3,w:3},{u:1,v:2,w:4},  {u:1,v:3,w:2},{u:2,v:4,w:1},{u:3,v:4,w:3}];// ------------------- Canvas 绘图 -------------------const canvas = document.getElementById('graphCanvas');const ctx = canvas.getContext('2d');function drawGraph(highlightEdge=null, skip=false) {  ctx.clearRect(0,0,canvas.width,canvas.height);  edges.forEach(e => {    const n1 = nodes[e.u], n2 = nodes[e.v];    if(e === highlightEdge){ ctx.strokeStyle = skip?'#aaa':'red'; ctx.lineWidth = 4; }    else if(e.inMST){ ctx.strokeStyle = 'green'; ctx.lineWidth = 3; }    else { ctx.strokeStyle = '#ccc'; ctx.lineWidth = 2; }    ctx.beginPath(); ctx.moveTo(n1.x,n1.y); ctx.lineTo(n2.x,n2.y); ctx.stroke();    const mx = (n1.x+n2.x)/2, my=(n1.y+n2.y)/2;    ctx.fillStyle='black'; ctx.font='14px sans-serif';    ctx.fillText(e.w,mx+5,my-5);  });  nodes.forEach(n => {    ctx.beginPath(); ctx.arc(n.x,n.y,15,0,Math.PI*2);    ctx.fillStyle='#fff'; ctx.fill();    ctx.strokeStyle='#000'; ctx.stroke();    ctx.fillStyle='black'; ctx.fillText(n.id,n.x-5,n.y+5);  });}// ------------------- 并查集 -------------------let parent = nodes.map(n=>n.id);function find(u){ return parent[u]===u ? u : (parent[u]=find(parent[u])); }function unite(u,v){ parent[find(u)] = find(v); }// ------------------- Kruskal -------------------edges.sort((a,b)=>a.w-b.w);let step=0;let mstSum = 0;document.getElementById('nextStep').onclick = function(){  if(step >= edges.length) return;  const e = edges[step];  let skip = false;  if(find(e.u) !== find(e.v)){    unite(e.u,e.v); e.inMST = true; mstSum += e.w;  } else skip = true;  drawGraph(e, skip);  document.getElementById('mstSum').textContent = "当前 MST 总权值: " + mstSum;  step++;}document.getElementById('reset').onclick = function(){  step = 0;  parent = nodes.map(n=>n.id);  edges.forEach(e=>e.inMST=false);  mstSum = 0;  drawGraph();  document.getElementById('mstSum').textContent = "当前 MST 总权值: " + mstSum;}// 初始化drawGraph();</script></details><h3 id="prim算法"><a class="markdownIt-Anchor" href="#prim算法"></a> prim算法</h3><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_09-43-39.webp" alt="" /><br />写<a href="https://www.luogu.com.cn/problem/P1194">P1194</a>的时候脑袋卡壳了,怎么都想不出如何得到和更新当前的最小代价<br />于是问了ai,发现还有prim算法可以用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> k[MAX][MAX];</span><br><span class="line"><span class="type">int</span> dist[MAX];</span><br><span class="line"><span class="type">bool</span> vis[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入代价矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">            cin &gt;&gt; k[i][j];</span><br><span class="line">            <span class="comment">// 如果通过别人得到比直接买还贵，直接舍弃</span></span><br><span class="line">            <span class="keyword">if</span> (k[i][j] &gt; a||k[i][j]==<span class="number">0</span>) k[i][j] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        dist[i] = a;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim 主循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mn = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找当前未加入生成树、代价最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dist[j] &lt; mn) &#123;</span><br><span class="line">                mn = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入生成树</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans += dist[u];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 u 更新其他点的最小代价</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= b; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                dist[v] = <span class="built_in">min</span>(dist[v], k[u][v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实好理解不少,可以看出来prim是点驱动的,每次找到代价最小的点,起点任意选择;<br />而kruskal是边驱动的,每次找到代价最小的不成环边,起点选最小边.</p><h2 id="最短路径算法"><a class="markdownIt-Anchor" href="#最短路径算法"></a> 最短路径算法</h2><h3 id="会画图就行dijkstra"><a class="markdownIt-Anchor" href="#会画图就行dijkstra"></a> (会画图就行)Dijkstra</h3><h4 id="证明"><a class="markdownIt-Anchor" href="#证明"></a> 证明</h4><p><a href="https://gallery.selfboot.cn/zh/algorithms/dijkstra">极好的证明</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 归纳基础：k = 1 时，T 中只包含起点 s，dist[s] = short[s] = 0，因此命题在 k = 1 时成立。</span><br><span class="line"></span><br><span class="line">2. 归纳假设：假设命题在第 k 步时成立，即 T 中所有节点的 dist 值都是最短路径长度。</span><br><span class="line"></span><br><span class="line">3. 归纳步骤：证明第 k+1 步时命题也成立：</span><br><span class="line"></span><br><span class="line">设第 k+1 步选择的节点为 v（v 是未访问节点中 dist 值最小的）；v 与集合 T 中的某个节点 u 相连；</span><br><span class="line">需要证明：dist[v] = short[v]。</span><br><span class="line">这里用反证法：</span><br><span class="line"></span><br><span class="line">假设存在一条从起点 s 到 v 的路径 P，其长度是 short[v]，且 short[v] &lt; dist[v]。</span><br><span class="line">由于起点 s 在集合 T 中，而终点 v 不在集合 T 中，路径 P 必然至少经过一个集合 T 中的节点（除起点外）。因为起点 s 到任何不在 T 中节点的距离，都是通过 T 中的节点来计算和更新的。</span><br><span class="line">设路径 P 上最后一个在集合 T 中的节点为 last，之后经过未访问集合中的节点 y 最终到达 v；下面看路径 P 的长度计算：</span><br><span class="line">  short[v] = dist[last] + distance[last,y] + distance[y,v]  // 路径 P 的长度</span><br><span class="line">           ≥ dist[y] + distance[y,v]                        // 根据 dist[y] 的更新规则</span><br><span class="line">           ≥ dist[v]      </span><br><span class="line">要理解下面这两个点才能明白上面的推导：</span><br><span class="line">首先由归纳假设，到达 last 的距离 dist[last] 是最短的；对于节点 y，根据 Dijkstra 算法的更新规则：dist[y] ≤ dist[last] + distance[last,y]</span><br><span class="line"></span><br><span class="line">又因为算法第 k+1 步选择了 v 作为当前最小距离节点，所以 dist[v] ≤ dist[y] + distance[y,v]。</span><br><span class="line">于是就推导出 short[v] &gt;= dist[v]，这和我们的假设 short[v] &lt; dist[v] 矛盾，因此假设不成立，dist[v] 就是从起点到 v 的最短路径长度。这也证明了算法每一步选择的节点的距离都是最短路径长度。</span><br></pre></td></tr></table></figure><p>这个归纳证明直接讲明白了算法的核心步骤,每次取未vis的最短路后更新其他未vis的最短路,直到遍历完所有节点就可以了</p><h4 id="画图"><a class="markdownIt-Anchor" href="#画图"></a> 画图</h4><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-29_09-54-09.webp" alt="" /><br />这里的path记录的是最短路径上的前驱节点</p><h3 id="不考floyd"><a class="markdownIt-Anchor" href="#不考floyd"></a> (不考)floyd</h3><p>重点是确认初始状态,之后将所有点遍历作为中间点更新最短路径,写一个三重循环,可得到任意两点之间的最短路径.<br />可以看出来floyd更为通用,dijkstra只能得到单源最短路径</p><h2 id="aov网络"><a class="markdownIt-Anchor" href="#aov网络"></a> aov网络</h2><h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h3><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-30_09-03-33.webp" alt="方法" /><br /><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2025-12-30_09-11-51.webp" alt="例题" /><br /><strong>算法</strong></p><h4 id="栈方法"><a class="markdownIt-Anchor" href="#栈方法"></a> 栈方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::TopologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>; <span class="comment">// 栈顶初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将所有入度为 0 的顶点压入链栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            count[i] = top; </span><br><span class="line">            top = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 依次处理顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;图中存在环路&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = top;          <span class="comment">// 出栈</span></span><br><span class="line">        top = count[top];     <span class="comment">// 移动栈顶</span></span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;     <span class="comment">// 输出顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历该顶点的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;<span class="type">float</span>&gt;* l = NodeTable[j].adj; l != <span class="literal">nullptr</span>; l = l-&gt;link) &#123;</span><br><span class="line">            <span class="type">int</span> k = l-&gt;dest;</span><br><span class="line">            <span class="keyword">if</span> (--count[k] == <span class="number">0</span>) &#123; <span class="comment">// 入度减1后为0则进栈</span></span><br><span class="line">                count[k] = top;</span><br><span class="line">                top = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看得出来教材已经扣到不愿意用队列了,每次更新的时候把原栈顶top指针存入最新入栈的count数组对应位置,然后将top指针指向这个位置</p><h4 id="队列方法"><a class="markdownIt-Anchor" href="#队列方法"></a> 队列方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Graph::TopologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// 创建一个正常的队列</span></span><br><span class="line">    <span class="type">int</span> count_processed = <span class="number">0</span>; <span class="comment">// 用于计数最后输出了多少个顶点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 扫描入度数组，把所有入度为 0 的顶点直接扔进队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 只要队列不为空，就继续处理</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> j = q.<span class="built_in">front</span>(); <span class="comment">// 取出队首顶点</span></span><br><span class="line">        q.<span class="built_in">pop</span>();           <span class="comment">// 出队</span></span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出该顶点</span></span><br><span class="line">        count_processed++; <span class="comment">// 记录处理过的顶点数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历该顶点的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;<span class="type">float</span>&gt;* l = NodeTable[j].adj; l != <span class="literal">nullptr</span>; l = l-&gt;link) &#123;</span><br><span class="line">            <span class="type">int</span> k = l-&gt;dest;</span><br><span class="line">            <span class="comment">// 将邻接点的入度减 1</span></span><br><span class="line">            <span class="keyword">if</span> (--count[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果减完后入度变为 0，则该顶点可以去排队了</span></span><br><span class="line">                q.<span class="built_in">push</span>(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 判断是否有环</span></span><br><span class="line">    <span class="keyword">if</span> (count_processed &lt; n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n网络中有回路(有向环)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="aoe网络"><a class="markdownIt-Anchor" href="#aoe网络"></a> aoe网络</h2><h3 id="关键路径"><a class="markdownIt-Anchor" href="#关键路径"></a> 关键路径</h3><p><a href="https://blog.csdn.net/ROBOT_a/article/details/147289874">讲的最清楚</a></p><blockquote><p>关键路径所经过的结点的最迟发生时间和最早发生时间是一致的。如果不好理解的话，打个比方，比如小组作业中，有个同学做的特别慢（关键路径）。所有人同时开始做，其他组员都做完了，他还没有做完，而小组只有等所有人都做完才能上交作品，那么完成小组作业所需的总时间就取决于他的时间。为了不拖后腿，对于他来说，他所做的n个事情就没有“最早什么时候做”“最晚什么时候做”这个说法，而是要马不停蹄地一直做。其他组员则可以选择早一点或晚一点做，只要不比他（关键路径）慢就行。<br />————————————————<br />版权声明：本文为CSDN博主「木卫三上的下午茶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br />原文链接：<a href="https://blog.csdn.net/ROBOT_a/article/details/147289874">https://blog.csdn.net/ROBOT_a/article/details/147289874</a></p></blockquote><p>这个解释非常妙,让我一下看懂了.</p><blockquote><p>关键是先求每个节点的最早发生时间和最迟发生时间,<br />再根据节点反推边对应事件的最早发生时间和最迟发生时间,相减得到差额,等于0的就是关键路径所经过的边.<br />需要明确的是递推方向,最早从前往后推,最迟从后往前推,节点和事件都是这样.<br />(到处搜资料还是没看懂,一翻到这篇文章就看懂了)</p></blockquote><blockquote><p>注意到递推的时候应该按照拓扑排序和逆拓扑排序 的顺序来进行,才能保证不遗漏点和边</p></blockquote><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><h4 id="例题1"><a class="markdownIt-Anchor" href="#例题1"></a> 例题1</h4><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2026-01-02_10-12-45.webp" alt="" /></p><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2026-01-02_10-13-39.webp" alt="解答" /></p><h4 id="例题2"><a class="markdownIt-Anchor" href="#例题2"></a> 例题2</h4><p><img src="../images/archives/2025/2025-12-19-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/PixPin_2026-01-02_10-14-53.webp" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;邻接矩阵和邻接表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#邻接矩阵和邻接表&quot;&gt;&lt;/a&gt; 邻接矩阵和邻接表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../images/archives/2025/2025-12-19-%E6%95%B0</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18 触动过我的文章</title>
    <link href="https://revival-of-hope.github.io/2025/12/18/dynamic-2025-12-18-%E8%A7%A6%E5%8A%A8%E8%BF%87%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/18/dynamic-2025-12-18-%E8%A7%A6%E5%8A%A8%E8%BF%87%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-18T00:00:00.000Z</published>
    <updated>2026-01-01T15:01:33.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十年前的实习面试"><a class="markdownIt-Anchor" href="#十年前的实习面试"></a> <a href="https://zhuanlan.zhihu.com/p/117315093">十年前的实习面试</a></h3><h3 id="疫情求职"><a class="markdownIt-Anchor" href="#疫情求职"></a> <a href="https://juejin.cn/post/7180678820796563516?searchId=20251125151954D8EF0E1FE1D09C7C0330">疫情求职</a></h3><h3 id="github-stars-wont-pay-your-rent"><a class="markdownIt-Anchor" href="#github-stars-wont-pay-your-rent"></a> <a href="https://www.kitze.io/posts/github-stars-wont-pay-your-rent">github-stars-wont-pay-your-rent</a></h3><h3 id="git考古"><a class="markdownIt-Anchor" href="#git考古"></a> <a href="https://blog.brachiosoft.com/">git考古</a></h3><h3 id="速通日语"><a class="markdownIt-Anchor" href="#速通日语"></a> <a href="https://galgame.dev/topic/639/%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%80%E5%B9%B4%E4%B8%8D%E5%88%B0%E9%80%9F%E9%80%9An1%E8%BF%99%E4%BB%B6%E4%BA%8B-%E5%9F%BA%E4%BA%8E%E5%95%83%E7%94%9F%E8%82%89galgame%E7%9A%84%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/8">速通日语</a></h3><h3 id="加拿大体验"><a class="markdownIt-Anchor" href="#加拿大体验"></a> <a href="https://ramsayleung.github.io/zh/post/2024/%E7%99%BB%E9%99%86%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/">加拿大体验</a></h3><h3 id="日本游记"><a class="markdownIt-Anchor" href="#日本游记"></a> <a href="https://nekonull.me/archive/2310-jp-travel/">日本游记</a></h3><h3 id="python的问题"><a class="markdownIt-Anchor" href="#python的问题"></a> <a href="https://www.dongwm.com/post/be-a-gopher/">python的问题</a></h3><h3 id="my-solopreneur-story-zero-to-45kmo-in-2-years"><a class="markdownIt-Anchor" href="#my-solopreneur-story-zero-to-45kmo-in-2-years"></a> <a href="https://news.tonydinh.com/p/my-solopreneur-story-zero-to-45kmo">My solopreneur story: zero to $45K/mo in 2 years</a></h3><h3 id="肮脏的交易"><a class="markdownIt-Anchor" href="#肮脏的交易"></a> <a href="https://www.mooreslawisdead.com/post/sam-altman-s-dirty-dram-deal">肮脏的交易</a></h3><h3 id="十年学会编程"><a class="markdownIt-Anchor" href="#十年学会编程"></a> <a href="http://daiyuwen.freeshell.org/gb/misc/21-days-cn.html">十年学会编程</a></h3><h3 id="契诃夫分析"><a class="markdownIt-Anchor" href="#契诃夫分析"></a> <a href="https://mhperng.blogspot.com/2025/12/anton-chekhov.html">契诃夫分析</a></h3><h3 id="软件开发经验"><a class="markdownIt-Anchor" href="#软件开发经验"></a> <a href="https://cloud.tencent.com/developer/article/1004735">软件开发经验</a></h3><h3 id="保研与工作"><a class="markdownIt-Anchor" href="#保研与工作"></a> <a href="https://www.zackwu.com/posts/2020-07-19-why-i-choose-to-work-after-graduation/">保研与工作</a></h3><h3 id="ai编程"><a class="markdownIt-Anchor" href="#ai编程"></a> <a href="https://blog.ch3nyang.top/post/AI%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/">AI编程</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;十年前的实习面试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#十年前的实习面试&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://zhuanlan.zhihu.com/p/117315093&quot;&gt;十年前的实习面试&lt;/a&gt;&lt;/h3&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/18/archives-2025-2025-12-18-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/18/archives-2025-2025-12-18-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-18T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://exquora.thoughtstorms.info/"></a></p><p>我对 Quora 上瘾，情不自禁使用这个网站。那里有一些很棒的问题和讨论，激发了我的灵感和想法。</p><p>但是当我重新阅读自己写的答案，一方面欣赏我的修辞和洞察力，另一方面也看到了很多想法可以成长为更大的成果。它们本可能进一步发展为软件、文章、论文、创业公司、书籍或社会运动，但任何事都没有发生。</p><p>不仅如此，还有许多篇我写的长篇大论已经无关紧要，沦为了废文。还有很多我花了好几个小时写的评论，试图说服对于这些问题永远不可能改变观点的那些读者。</p><p>我花了数千（也许是数万）小时在 Quora 上写作。我写的远不止11000个答案，还有5000多个草稿答案，其中很多已经写得很长了，只是因为来不及最终润色而没​​有发表。</p></blockquote><p>这篇文章说出了我想说的,我见过很多极其优秀的故事或者技术讲解,可作者发布的网站恰恰是贴吧,天涯或者知乎这样的问答网站或者论坛,作者的观点被一篇篇孤立的文章或者一条条回复分割开来,很难形成一个完整的体系.</p><p>而天涯的倒闭也说明了在这些自己不能掌控的平台上并不能保证自己的思想可以永久保留下来,那些优秀的文章随着服务器的关闭直接成为了无法触及的历史,即便是作者本人也无法找回.</p><p>因此,我拒绝在论坛里写长篇大论,而是作为读者去发掘优秀的文章,可惜的是现在优秀的文章也越来越少了,而AI生成的无意义内容充斥着论坛的每个角落,很难找到真正有意义的东西,这也是我悲哀的一点.</p><p>一方面,论坛不能让作者的文字体系化,另一方面,博客不能保证作者的文章能广泛传播,比如我这个博客就不是所有国人都能访问到的,很难找到一个折衷点.</p><p>如果我有那个能力,我可能会去开发一个跨平台的博客论坛吧,侧重点在于分享生活和技术,每个人都能像写博客一样把文章从自己本地上传,改进一下SEO算法,保证最好的文章优先显示,集成了评论系统和follow功能,最大幅度减少作者需要折腾的东西,只写md就行了,呈现的页面也由作者自己在前端设置.重点是这个网站能长久保存,不会让作者的心血白费.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://exquora.thoughtstorms.info/&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我对 Quora 上瘾，情不自禁使用这个网站。那里有一些很棒的问题和讨论，激发了我的灵感和想法。&lt;/p&gt;
&lt;p&gt;但是当我重新阅读自己</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 道路与选择</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/archives-2025-2025-12-16-%E9%81%93%E8%B7%AF%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/archives-2025-2025-12-16-%E9%81%93%E8%B7%AF%E4%B8%8E%E9%80%89%E6%8B%A9/</id>
    <published>2025-12-16T08:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>这几天有点焦躁和郁闷,总有种无所适从的感觉,浑浑噩噩的,对很多事都不上心了,于是现在静下来认真思考了一下当前的处境.</p><p>人生是由一大堆选择构成的,每一个分岔路口都决定了我以后的人生道路,有时候选择多种多样,似乎哪里都是通路,有时候仿佛是山穷水尽,让我别无选择.</p><p>人自然是希望选择越多越好,这就是我以前为什么倾向于做事提早做准备的原因,为的就是不让自己在ddl的时候显得无路可走.</p><p>但过多的选择,太多的可能,悲观的现实又让我痛苦万分,人生的道路总是要自己走的,但如果有一个引路人就更好了.看不清未来的道路只会使我无所适从,一边厌恶着填鸭式的教育,一边追求绩点的完美,只怕到头来也是一场空.</p><h2 id="梁甫吟">梁甫吟</h2><p><strong>唐 · 李白</strong></p><blockquote><p>長嘯梁甫吟，何時見陽春？<br>君不見，朝歌屠叟辭棘津，八十西來釣渭濱。<br>寧羞白髮照清水，逢時壯氣思經綸。<br>廣張三千六百釣，風期暗與文王親。<br>大賢虎變愚不測，當年頗似尋常人。</p><p>君不見，高陽酒徒起草中，長揖山東隆準公。<br>入門不拜逞雄辯，兩女輟洗來趨風。<br>東下齊城七十二，指揮楚漢如鏇蓬。<br>狂客落魄尚如此，何況壯士當群雄！</p><p>我欲攀龍見明主，雷公砰訇震天鼓。<br>帝旁投壺多玉女，三時大笑開電光，<br>倏爍晦冥起風雨。<br>閶闔九門不可通，以額扣關閽者怒。</p><p>白日不照我精誠，杞國無事憂天傾。<br>猰貐磨牙競人肉，騶虞不折生草莖。<br>手接飛猱搏雕虎，側足焦原未言苦。</p><p>智者可卷愚者豪，世人見我輕鴻毛。<br>力排南山三壯士，齊相殺之費二桃。<br>吳楚弄兵無劇孟，亞夫咍爾為徒勞。</p><p>梁甫吟，聲正悲。<br>張公兩龍劍，神物合有時。<br>風雲感會起屠釣，大人臲屼當安之。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天有点焦躁和郁闷,总有种无所适从的感觉,浑浑噩噩的,对很多事都不上心了,于是现在静下来认真思考了一下当前的处境.&lt;/p&gt;
&lt;p&gt;人生是由一大堆选择构成的,每一个分岔路口都决定了我以后的人生道路,有时候选择多种多样,似乎哪里都是通路,有时候仿佛是山穷水尽,让我别无选择.&lt;</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 折腾记录-动态更新</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/dynamic-2025-12-16-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/dynamic-2025-12-16-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/</id>
    <published>2025-12-16T00:00:00.000Z</published>
    <updated>2026-01-01T09:13:38.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo图片管理困难帖子多了很难阅读"><a class="markdownIt-Anchor" href="#hexo图片管理困难帖子多了很难阅读"></a> hexo图片管理困难,帖子多了很难阅读</h2><p>解决方法:<br />config_yml里修改<br /><code>new_post_name: :year-:month-:day-:title.md</code><br />同时,听从大佬建议,将所有图片改成webp格式,效果立竿见影<br /><img src="../../images/archives/2025/2025-12-16%20%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/tmpDAFA.png" alt="" /></p><h2 id="还是图片问题每次复制images子文件夹路径太麻烦"><a class="markdownIt-Anchor" href="#还是图片问题每次复制images子文件夹路径太麻烦"></a> 还是图片问题,每次复制images子文件夹路径太麻烦</h2><p>根据<a href="https://www.hwpo.top/posts/d87f7e0c/index.html"></a>教程在post文件夹里设置同名文件夹没解决</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>最后写了一个脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 用 data.path 生成文件夹名</span></span><br><span class="line">  <span class="comment">// data.path 是相对于 source/_posts 的路径，带后缀</span></span><br><span class="line">  <span class="keyword">const</span> filename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, path.<span class="title function_">extname</span>(data.<span class="property">path</span>)); <span class="comment">// 去掉扩展名</span></span><br><span class="line">  <span class="keyword">const</span> imagesDir = path.<span class="title function_">join</span>(hexo.<span class="property">base_dir</span>, <span class="string">&#x27;source/images&#x27;</span>, filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(imagesDir)) &#123;</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(imagesDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Created image folder: <span class="subst">$&#123;imagesDir&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在同级目录下生成图像文件夹来管理,麻烦的是每次都要删去相对路径里的’source/’</p><h2 id="改用butterfly主题"><a class="markdownIt-Anchor" href="#改用butterfly主题"></a> 改用butterfly主题</h2><p>这个主题确实好用了不少</p><h2 id="增加评论系统"><a class="markdownIt-Anchor" href="#增加评论系统"></a> 增加评论系统</h2><p><a href="https://tech.yemengstar.com/vercel-twikoo-comment-your-hexo/">参考文章</a></p><h2 id="尝试新部署方式"><a class="markdownIt-Anchor" href="#尝试新部署方式"></a> 尝试新部署方式</h2><p><a href="https://tech.yemengstar.com/github-actions-auto-hexo/"></a></p><h2 id="增加了category条目tag条目和背景图片"><a class="markdownIt-Anchor" href="#增加了category条目tag条目和背景图片"></a> 增加了category条目,tag条目和背景图片</h2><p>原来要用<code>hexo new page tag</code>才能在hexo里显示tag页和category页</p><h2 id="发现md只要在posts下都能被直接解析251221"><a class="markdownIt-Anchor" href="#发现md只要在posts下都能被直接解析251221"></a> 发现md只要在posts下都能被直接解析(25/12/21)</h2><p>于是我将不会再修改的文章都移动到了archives文件夹,图片路径也做了对应的修改,<br />之前我还想文章多了要怎么处理呢.</p><h2 id="还是图片问题hexo本地无法正确解析相对路径"><a class="markdownIt-Anchor" href="#还是图片问题hexo本地无法正确解析相对路径"></a> 还是图片问题,hexo本地无法正确解析相对路径</h2><p>例如<code>source/images/archives/2025/2025-11-26/image.png</code><br />需要改为’images/archives/2025/2025-11-26/image.png’,每次改就很麻烦了<br />于是找ai弄了脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data.<span class="property">cover</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    data.<span class="property">cover</span> = data.<span class="property">cover</span>.<span class="title function_">replace</span>(</span><br><span class="line">      <span class="regexp">/^\/?source\//</span>,</span><br><span class="line">      <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完美解决,以后只要把复制相对路径就可以了,不要再删删减减了.</p><h2 id="增加rss订阅图标"><a class="markdownIt-Anchor" href="#增加rss订阅图标"></a> 增加rss订阅图标</h2><p><a href="https://mitpoppy.github.io/posts/fe13d434.html">参考文章</a><br />发现了RSS订阅方式,于是增加了这一功能</p><h2 id="更改了图像文件夹创建方式251226"><a class="markdownIt-Anchor" href="#更改了图像文件夹创建方式251226"></a> 更改了图像文件夹创建方式(25/12/26)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// data.path: 2025-12-26-xxx.md</span></span><br><span class="line">  <span class="keyword">const</span> basename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, path.<span class="title function_">extname</span>(data.<span class="property">path</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取前 10 个字符作为日期</span></span><br><span class="line">  <span class="keyword">const</span> date = basename.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 图片目录：source/images/2025-12-26</span></span><br><span class="line">  <span class="keyword">const</span> imagesDir = path.<span class="title function_">join</span>(</span><br><span class="line">    hexo.<span class="property">base_dir</span>,</span><br><span class="line">    <span class="string">&#x27;source/images&#x27;</span>,</span><br><span class="line">    date</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(imagesDir)) &#123;</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(imagesDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Created image folder: <span class="subst">$&#123;imagesDir&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于我的post创建格式在config里面改成了这样子<br /><code>new_post_name: :year-:month-:day-:title.md</code><br />故可以根据日期直接找到对应的图片,这样图片管理起来更加方便了,但原来的几十个文件夹我是真不想再改了.</p><h2 id="突然发现没必要用file-utils粘贴相对路径直接复制图片就好了1227"><a class="markdownIt-Anchor" href="#突然发现没必要用file-utils粘贴相对路径直接复制图片就好了1227"></a> 突然发现没必要用file utils粘贴相对路径,直接复制图片就好了(12/27)</h2><p>在settings.json里加上</p><figure class="highlight plaintext"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;**/*.md&quot;: &quot;images/$&#123;documentBaseName&#125;/&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>就可以在md里直接复制图片而不是自己写了<img src="" alt="" />这些东西了,<br />甚至会根据图片复制的位置智能选择是插入相对路径还是插入整个图片链接格式,又能偷一点懒了.</p><h2 id="每次hexo-d的时候都要报warning202611"><a class="markdownIt-Anchor" href="#每次hexo-d的时候都要报warning202611"></a> 每次hexo d的时候都要报warning(2026/1/1)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: <span class="keyword">in</span> the working copy of <span class="string">&#x27;tags/离散数学/index.html&#x27;</span>, LF will be replaced by CRLF the next <span class="keyword">time</span> Git touches it</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://zhuanlan.zhihu.com/p/586324681">详细解释CR和CRLF</a><br />LF和CRLF区别<br />LF: Line Feed换行<br />feed v.喂养,供给;将(信息)输入 line feed直译是”将行输入”,再意译”换行”<br />CRLF: Carriage Return Line Feed 回车换行<br />Carriage n.马车,火车车厢;运输费用 在carriage return中,carriage译为“车”,return译为“回”<br />在过去的机械打字机上有个部件叫「字车」（Typewriter carriage），每打一个字符，字车前进一格，打完一行后，我们需要让字车回到起始位置，而“Carriage Return”键最早就是这个作用，因此被直接翻译为「回车」。尽管后来回车键的作用已经不止” 倒回字车”那么简单，但这个译名一直被保留下来。</p></blockquote><blockquote><p><a href="https://github.com/g199209/BlogMarkdown/blob/master/Hexo%20Git%E9%83%A8%E7%BD%B2%E8%AD%A6%E5%91%8Awarning%20LF%20will%20be%20replaced%20by%20CRLF%E7%9A%84%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95.md">解决方法</a><br />这个警告的意思很直接，就是Git会把LF替换为CRLF，不过这是无关紧要的，完全可以禁用此功能，这样还可以避免这个警告信息刷屏。设置方法也很简单，在MinGW窗口中输入以下命令即可：<br />git config --global core.autocrlf false</p></blockquote><ul><li>很奇怪的是很少有人去想为什么回车叫做回车,这种粗暴的翻译在用电脑打字的时代显得非常奇怪,习惯的力量真有点可怕.</li><li><a href="https://www.163.com/dy/article/JEG01TL50511FQO9.html">扔掉CRLF</a></li></ul><h2 id="嵌入数学公式unsolved"><a class="markdownIt-Anchor" href="#嵌入数学公式unsolved"></a> 嵌入数学公式(unsolved)</h2><p>按照<a href="https://butterfly.js.org/posts/4aa8abbe/">官方文档</a>的步骤进行操作并没有解决,尝试了<a href="https://nickxu.me/2022/04/17/Hexo-Butterfly-%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E5%85%AB%EF%BC%89%E4%BD%BF%E7%94%A8-KaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">这个教程</a>也没有解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo图片管理困难帖子多了很难阅读&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hexo图片管理困难帖子多了很难阅读&quot;&gt;&lt;/a&gt; hexo图片管理困难,帖子多了很难阅读&lt;/h2&gt;
&lt;p&gt;解决方法:&lt;br /&gt;
config_yml里</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-14 数据结构整理-(树和堆)</title>
    <link href="https://revival-of-hope.github.io/2025/12/14/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/"/>
    <id>https://revival-of-hope.github.io/2025/12/14/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/</id>
    <published>2025-12-14T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前序遍历-中序遍历-后序遍历-层序遍历">前序遍历,中序遍历,后序遍历,层序遍历</h2><p>依次为根左右,左根右,左右根,逐层遍历<br>![说明](/images/archives/2025/2025-12-14 数据结构整理-4/PixPin_2025-12-25_10-52-23.webp)<br>在递归里打印的顺序也是如此<br><strong>以前序遍历为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> BinaryTree&lt;Type&gt;::</span><br><span class="line"><span class="built_in">PreOrder</span> ( BinTreeNode &lt;Type&gt; *current ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( current != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        cout &lt;&lt; current→data;</span><br><span class="line">        <span class="built_in">PreOrder</span> ( current→leftChild );</span><br><span class="line">        <span class="built_in">PreOrder</span> ( current→rightChild );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据前序和中序画二叉树">根据前序和中序画二叉树</h3><p><img src="/images/archives/2025/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/PixPin_2025-12-26_12-55-59.webp" alt="例题"></p><h2 id="线索化二叉树-threaded-binary-tree">线索化二叉树 (Threaded Binary Tree)</h2><p>简单说来就是空的左指针指向对应遍历顺序的前驱,若自己是第一个节点则为 nullptr,右指针指向对应遍历顺序的后驱,若自己为最后一个节点则为 nullptr.<br>![](/images/archives/2025/2025-12-14 数据结构整理-4/PixPin_2025-12-25_10-57-29.webp)</p><p>但我觉得这种不太会考算法,最多考我画画图,所以 pass 掉.</p><h2 id="最大堆和最小堆">最大堆和最小堆</h2><h3 id="向下调整算法">向下调整算法</h3><p>调整顺序:自下而上,从右往左,其实就是从尾部节点开始倒着遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小堆的向下调整算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt; :: <span class="built_in">FilterDown</span> ( <span class="type">int</span> start, <span class="type">int</span></span><br><span class="line">EndOfHeap ) &#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = <span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    <span class="comment">// j 是 i 的左子女</span></span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= EndOfHeap ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( j &lt; EndOfHeap &amp;&amp; heap[j] &gt; heap[j<span class="number">+1</span>] ) j++; <span class="comment">//两子女中选小者</span></span><br><span class="line">        <span class="keyword">if</span> ( temp &lt;= heap[j] ) <span class="keyword">break</span>; <span class="comment">//不需要调整</span></span><br><span class="line">        <span class="keyword">else</span> &#123; heap[i] = heap[j]; i = j; j = <span class="number">2</span>*j<span class="number">+1</span>; &#125;</span><br><span class="line">        <span class="comment">//相当于把start一直通过swap向下调整到最优位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理可推得最大堆的向下调整算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MaxHeap&lt;Type&gt; :: <span class="built_in">FilterDown</span>(<span class="type">int</span> start,<span class="type">int</span> EndOfHeap)&#123;</span><br><span class="line">    <span class="type">int</span> i=start,j=<span class="number">2</span>*i<span class="number">+1</span>;</span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=EndOfHeap)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;EndofHeap&amp;&amp;heap[j]&lt;heap[j<span class="number">+1</span>]) j++;<span class="comment">//两子女选大者</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=hep[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            heap[i]=heap[j];</span><br><span class="line">            i=j;</span><br><span class="line">            j=<span class="number">2</span>*j<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入与向上调整算法">插入与向上调整算法</h3><p>简单说来就是插入到堆的末尾,然后向上逐层调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">int</span> MinHeap&lt;Type&gt; :: <span class="built_in">Insert</span> ( <span class="type">const</span> Type &amp;x ) &#123;</span><br><span class="line"><span class="comment">//在堆中插入新元素 x</span></span><br><span class="line"><span class="keyword">if</span> ( CurrentSize == MaxHeapSize ) <span class="comment">//堆满</span></span><br><span class="line">&#123; cout &lt;&lt; <span class="string">&quot;堆已满&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">heap[CurrentSize] = x;</span><br><span class="line"> <span class="comment">//插在表尾</span></span><br><span class="line"><span class="built_in">FilterUp</span> (CurrentSize);</span><br><span class="line"> <span class="comment">//向上调整为堆</span></span><br><span class="line">CurrentSize++;</span><br><span class="line"> <span class="comment">//堆元素增一</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt; :: <span class="built_in">FilterUp</span> ( <span class="type">int</span> start ) &#123;</span><br><span class="line"><span class="comment">//从 start 开始,向上直到0,调整堆</span></span><br><span class="line">    <span class="type">int</span> j = start, i = (j<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">// i 是 j 的父结点</span></span><br><span class="line">    Type temp = heap[j];</span><br><span class="line">    <span class="keyword">while</span> ( j &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( heap[i] &lt;= temp ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; heap[j] = heap[i]; j = i; i = (i <span class="number">-1</span>)/<span class="number">2</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的删除">堆的删除</h3><p>通过把顶端和堆末尾元素交换来把顶端删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">int</span> MinHeap &lt;Type&gt; :: <span class="built_in">RemoveMin</span> (Type &amp;x)&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !CurrentSize )&#123;   </span><br><span class="line">        cout &lt;&lt; “ 堆已空 <span class="string">&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    x = heap[0];</span></span><br><span class="line"><span class="string">    //删除最小元素</span></span><br><span class="line"><span class="string">    heap[0] = heap[CurrentSize-1];</span></span><br><span class="line"><span class="string">    CurrentSize--;</span></span><br><span class="line"><span class="string">    FilterDown ( 0, CurrentSize-1 ); // start, EndOfHeap</span></span><br><span class="line"><span class="string">    //从0号位置开始自顶向下调整为堆</span></span><br><span class="line"><span class="string">    return 1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="左孩子右兄弟表示法">左孩子右兄弟表示法</h2><p>为了将多叉树转换成二叉树,从上往下遍历,左指针指向第一个孩子,右指针指向同层右边的兄弟<br>同理,将二叉树转换成多叉树,也是从上往下遍历,根据左右指针重新画图</p><h2 id="森林与二叉树的转换">森林与二叉树的转换</h2><p>森林转化成二叉树</p><ul><li>核心转换规则：左孩子右兄弟表示法</li><li>先将每棵树转二叉树（左孩子右兄弟），再将二叉树按右子节点连接<br><code>用人话说就是把根节点都看成是兄弟就可以了</code><br><code>这样的话沿着根节点的右指针一直遍历拆分下去就可以找到这个森林的原始结构了</code><br>二叉树转换为森林</li><li>先按右子节点拆分二叉树，再将每棵二叉树还原为原树（逆左孩子右兄弟）</li></ul><h2 id="huffman编码">Huffman编码</h2><h3 id="例题">例题</h3><blockquote><p>假定用于通信的电文仅由 8个字母 c1, c2, c3, c4, c5, c6, c7, c8 组成, 各字母在电文中出现的频率<br>分别为 5, 25, 3, 6, 10, 11, 36, 4。试为这 8 个字母设计不等长 Huffman编码, 并给出该电文的总码数。</p></blockquote><p>答案：257</p><details><summary>点击查看流程图</summary><p><img src="/images/archives/2025/2025-12-25-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB/PixPin_2025-12-26_13-06-42.webp" alt=""></p></details><h2 id="并查集">并查集</h2><p>稍微接触过一点算法的人都知道要怎么写吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[a]==a)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[a]=<span class="built_in">find</span>(f[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa=<span class="built_in">find</span>(a),fb=<span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">        f[fb]=fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> s,t;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">        <span class="built_in">unite</span>(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_11-58-23.webp" alt="然而ppt中是这样写路径压缩的..."><br><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-00-58.webp" alt="而它的parent数组定义是这样的..."><br>都用数组来存结点数了却没用数组存母节点吗,有点意思,为了不想让人轻易看懂真的是煞费苦心,我觉得这种代码要是考了就有点sm了,之后有时间我再瞅两眼,没时间就算了.</p><blockquote><p>【例1】请给出下列操作序列的运算结果，其中M是合并，F是查找：M(1,2),M(3,4),M(3,5),M(1,7),M(3,6),M(8,9),M(1,8),M(3,10),M(3,11),M(3,12),M(3,13),M(14,15),M(16,17),M(14,16),M(1,3),M(1,14)<br>根据树的高度执行合并（高度高的树作为根节点）：<br>1)画出并查集森林的构造过程。<br>2)画出存储该并查集的数组。</p></blockquote><p><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-27_12-06-42.webp" alt="解答"></p><h2 id="bst-二叉搜索树-binary-search-tree">BST(二叉搜索树,Binary Search Tree)</h2><p>由于中序遍历是左根右,因此对BST进行中序遍历可以得到从小到大的顺序</p><p>很好奇教材上为什么都要故意用些七扭八歪的代码来写数据结构,光这样也就算了,顶多看的时候费力一点,问题是原理都不讲清楚,那就有点过分了.</p><h3 id="bst的插入和删除">BST的插入和删除</h3><p>插入很好理解,递归遇到空节点时直接插入就可以了,<br>删除需要分为三类</p><ol><li>无子女,这个时候直接删除</li><li>一个子女,把子女跟自己调换</li><li>双子女,寻找作用跟他相同的节点来替换,才不会破坏原二叉树,可以找到中序遍历下的上一个节点或者下一个节点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> BST&lt;Type&gt;::<span class="built_in">Remove</span>(<span class="type">const</span> Type&amp; x, BstNode&lt;Type&gt;*&amp; ptr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; ptr-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">Remove</span>(x, ptr-&gt;leftChild);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; ptr-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">Remove</span>(x, ptr-&gt;rightChild);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到要删除的结点</span></span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;leftChild &amp;&amp; ptr-&gt;rightChild) &#123;</span><br><span class="line">            BstNode&lt;Type&gt;* t = <span class="built_in">Min</span>(ptr-&gt;rightChild);</span><br><span class="line">            ptr-&gt;data = t-&gt;data;</span><br><span class="line">            <span class="built_in">Remove</span>(t-&gt;data, ptr-&gt;rightChild);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BstNode&lt;Type&gt;* t = ptr;</span><br><span class="line">            ptr = (ptr-&gt;leftChild) ? ptr-&gt;leftChild : ptr-&gt;rightChild;</span><br><span class="line">            <span class="keyword">delete</span> t;</span><br><span class="line">            <span class="comment">//一次考虑到无子女和一个子女两种情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题">例题</h3><blockquote><p>编写算法在二叉排序树上找出任意两个不同结点的最近公共祖先。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTNode* <span class="title">LCA_BST</span><span class="params">(BiTNode* root, <span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == p||root ==q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &lt; root-&gt;key &amp;&amp; q &lt; root-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LCA_BST</span>(root-&gt;lchild, p, q);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; root-&gt;key &amp;&amp; q &gt; root-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LCA_BST</span>(root-&gt;rchild, p, q);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avl树">AVL树</h2><blockquote><p>一棵AVL树或者是空树，或者是具有下列性质的二叉搜索树：它的左子树和右子树都是AVL树，且左子树和右子树的高度之差的绝对值不超过1.</p></blockquote><p>有n个节点的AVL树高度不超过1.44log2​n,这可以由斐波那契数列推出来,只要让右子树一直比左子树高度加一就可以.(后面有例题)<br><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-28_11-21-36.webp" alt="平衡因子"><br><img src="../images/archives/2025/2025-12-14%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/PixPin_2025-12-28_11-26-24.webp" alt="旋转"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> &#123;</span><br><span class="line">    Type data;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLNode* left;</span><br><span class="line">    AVLNode* right;</span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">const</span> Type&amp; x)</span><br><span class="line">        : <span class="built_in">data</span>(x), <span class="built_in">height</span>(<span class="number">1</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVL</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> Type&amp; x, AVLNode&lt;Type&gt;*&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;Type&gt;(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; t-&gt;data) &#123;</span><br><span class="line">            <span class="built_in">Insert</span>(x, t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;left) - <span class="built_in">height</span>(t-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; t-&gt;left-&gt;data)</span><br><span class="line">                    t = <span class="built_in">rotateRight</span>(t);      <span class="comment">// LL</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    t = <span class="built_in">rotateLeftRight</span>(t); <span class="comment">// LR</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;data) &#123;</span><br><span class="line">            <span class="built_in">Insert</span>(x, t-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;right) - <span class="built_in">height</span>(t-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; t-&gt;right-&gt;data)</span><br><span class="line">                    t = <span class="built_in">rotateLeft</span>(t);       <span class="comment">// RR</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    t = <span class="built_in">rotateRightLeft</span>(t); <span class="comment">// RL</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;left), <span class="built_in">height</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(AVLNode&lt;Type&gt;* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t ? t-&gt;height : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">rotateRight</span><span class="params">(AVLNode&lt;Type&gt;* k2)</span> </span>&#123;</span><br><span class="line">        AVLNode&lt;Type&gt;* k1 = k2-&gt;left;</span><br><span class="line">        k2-&gt;left = k1-&gt;right;</span><br><span class="line">        k1-&gt;right = k2;</span><br><span class="line">        k2-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(k2-&gt;left), <span class="built_in">height</span>(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        k1-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(k1-&gt;left), <span class="built_in">height</span>(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">rotateLeft</span><span class="params">(AVLNode&lt;Type&gt;* k2)</span> </span>&#123;</span><br><span class="line">        AVLNode&lt;Type&gt;* k1 = k2-&gt;right;</span><br><span class="line">        k2-&gt;right = k1-&gt;left;</span><br><span class="line">        k1-&gt;left = k2;</span><br><span class="line">        k2-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(k2-&gt;left), <span class="built_in">height</span>(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        k1-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(k1-&gt;left), <span class="built_in">height</span>(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> k1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">rotateLeftRight</span><span class="params">(AVLNode&lt;Type&gt;* k3)</span> </span>&#123;</span><br><span class="line">        k3-&gt;left = <span class="built_in">rotateLeft</span>(k3-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotateRight</span>(k3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">rotateRightLeft</span><span class="params">(AVLNode&lt;Type&gt;* k3)</span> </span>&#123;</span><br><span class="line">        k3-&gt;right = <span class="built_in">rotateRight</span>(k3-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotateLeft</span>(k3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但我真的不想看代码了.下面是我的理解:<br>记三个节点从上往下依次为a,b,c<br>则这四种情况分别有</p><ol><li>a&gt;b&gt;c</li><li>a&lt;b&lt;c</li><li>b&lt;c&lt;a</li><li>a&lt;c&lt;b</li></ol><ul><li>只需把中间那个节点接上a的原位置就可以保证既满足BST,又能满足高度差为0.</li><li>第一种情况和第二种情况都只需要把b接到a的位置,然后把结构调整为BST</li><li>第三种和第四种就需要把c接到a的位置,然后把c的左右孩子按照BST规则接入其他节点</li></ul><h3 id="删除算法">删除算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> AVL&lt;Type&gt;::<span class="built_in">Remove</span>(<span class="type">const</span> Type&amp; x, AVLNode&lt;Type&gt;*&amp; t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; t-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">Remove</span>(x, t-&gt;left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; t-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">Remove</span>(x, t-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到要删除的结点</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left &amp;&amp; t-&gt;right) &#123;</span><br><span class="line">            AVLNode&lt;Type&gt;* p = t-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;left) p = p-&gt;left;   <span class="comment">// 右子树最小结点</span></span><br><span class="line">            t-&gt;data = p-&gt;data;</span><br><span class="line">            <span class="built_in">Remove</span>(t-&gt;data, t-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AVLNode&lt;Type&gt;* old = t;</span><br><span class="line">            t = t-&gt;left ? t-&gt;left : t-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> old;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    t-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(t-&gt;left), <span class="built_in">height</span>(t-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新平衡</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;left) - <span class="built_in">height</span>(t-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;left-&gt;left) &gt;= <span class="built_in">height</span>(t-&gt;left-&gt;right))</span><br><span class="line">            t = <span class="built_in">rotateRight</span>(t);       <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="built_in">rotateLeftRight</span>(t);   <span class="comment">// LR</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;right) - <span class="built_in">height</span>(t-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>(t-&gt;right-&gt;right) &gt;= <span class="built_in">height</span>(t-&gt;right-&gt;left))</span><br><span class="line">            t = <span class="built_in">rotateLeft</span>(t);        <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="built_in">rotateRightLeft</span>(t);   <span class="comment">// RL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个要是考了就没天理了,要是给图我倒是能画一画.</p><h3 id="例题">例题</h3><blockquote><p>高度为5的AVL树最多有多少个节点，最少有多少个节点(叶子节点高度为1)<br>显然AVL树可以是满二叉树,故直接用满二叉树来算就可以了.<br>而最少节点只需按照左右子树高度差最多为1来构造即可,构造的时候就很容易发现这是一个递归结构,有以下公式:<br><code>f[0]=0,f[1]=1,f[n]=f[n-1]+f[n-2]+1</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前序遍历-中序遍历-后序遍历-层序遍历&quot;&gt;前序遍历,中序遍历,后序遍历,层序遍历&lt;/h2&gt;
&lt;p&gt;依次为根左右,左根右,左右根,逐层遍历&lt;br&gt;
![说明](/images/archives/2025/2025-12-14 数据结构整理-4/PixPin_2025</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>

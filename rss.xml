<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>独角恋歌</title>
  
  
  <link href="https://revival-of-hope.github.io/rss.xml" rel="self"/>
  
  <link href="https://revival-of-hope.github.io/"/>
  <updated>2026-02-03T06:58:33.361Z</updated>
  <id>https://revival-of-hope.github.io/</id>
  
  <author>
    <name>Revival-of-hope</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2026-02-03 fastapi模板项目学习</title>
    <link href="https://revival-of-hope.github.io/2026/02/03/fastapi%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://revival-of-hope.github.io/2026/02/03/fastapi%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2026-02-03T00:00:00.000Z</published>
    <updated>2026-02-03T06:58:33.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你像我一样没怎么用过docker,不了解前后端之间具体如何工作,而只是照着模板项目的md边问ai边运行项目的话,看到这个界面肯定是懵的</p></blockquote><p><img src="/images/2026-02-03/PixPin_2026-02-03_13-56-30.webp" alt="alt text" /></p><blockquote><p>当我尝试问ai时,它直接告诉我有这么多端口</p></blockquote><p><img src="/images/2026-02-03/PixPin_2026-02-03_13-59-17.webp" alt="alt text" /><br />点进去是这些画面<br /><img src="/images/2026-02-03/PixPin_2026-02-03_14-00-27.webp" alt="alt text" /><br /><img src="/images/2026-02-03/PixPin_2026-02-03_14-00-51.webp" alt="alt text" /><br /><img src="/images/2026-02-03/PixPin_2026-02-03_14-01-06.webp" alt="alt text" /></p><p>即便我大致看过了fastapi的教程,稍微了解了一点数据库知识,自以为可以开始做项目了,这些界面直接将我打回原形,显然工程上的前后端还是很难懂的,不是一个普通学生可以轻易学会的</p><p>于是我开始翻阅项目文档,并发现项目中基本没写原理,写的都是运行方法,问了问ai,给了以下回答.</p><blockquote><p>这个模板（full-stack-fastapi-template）针对生产级最佳实践设计，不是为零基础初学者写的。官方文档和 README 假设你已有 FastAPI、Docker、React 基础知识。GitHub discussion #1115 明确说：not beginner friendly，目标是给有经验开发者提供起点。</p></blockquote><p>也正是如此,如果我连这个项目都可以驾驭的话,那么之后做任何前后端应该都不会有任何问题了,下面是我的学习历程</p><h2 id="what-is-docker-how-does-it-works"><a class="markdownIt-Anchor" href="#what-is-docker-how-does-it-works"></a> What is docker? How does it works?</h2><p><strong>参考</strong></p><ul><li><a href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">阮一峰教程</a></li></ul><blockquote><p>不得不说大牛的教程就是写的深入浅出</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果你像我一样没怎么用过docker,不了解前后端之间具体如何工作,而只是照着模板项目的md边问ai边运行项目的话,看到这个界面肯定是懵的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/2026-02-03/PixP</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ramírez</title>
    <link href="https://revival-of-hope.github.io/2026/02/01/archives-2026-02-01-Ramirez/"/>
    <id>https://revival-of-hope.github.io/2026/02/01/archives-2026-02-01-Ramirez/</id>
    <published>2026-02-01T03:48:58.000Z</published>
    <updated>2026-02-01T05:04:52.184Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2026-02-01/PixPin_2026-02-01_11-50-05.webp" alt="alt text" /></p><p>阅读fastapi和sqlmodel的教程就觉得作者是一个风趣,谦虚,对于疑问要穷追不舍,对于新手非常友好的hacker</p><blockquote><p><a href="https://github.com/tiangolo">Ramírez主页</a><br /><a href="https://tiangolo.medium.com/concurrent-burgers-understand-async-await-eeec05ae7cfe">汉堡店比喻</a></p></blockquote><p>潦草搜了搜,互联网上关于他的信息还是比较少的,也没有什么比较亮眼的镜头表现,他的英语口音我也比较难接受.只大概知道他没有读大学,从哥伦比亚到了德国工作.</p><p>看得出来,他将几乎所有的心血都投入到了开源项目中,所以才不会有时间去包装,宣传自己.</p><p>这是一位真正令人尊重的hacker.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/2026-02-01/PixPin_2026-02-01_11-50-05.webp&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;
&lt;p&gt;阅读fastapi和sqlmodel的教程就觉得作者是一个风趣,谦虚,对于疑问要穷追不舍,对于新手非</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-31 ai幻想</title>
    <link href="https://revival-of-hope.github.io/2026/01/31/archives-2026-01-31-ai%E5%B9%BB%E6%83%B3/"/>
    <id>https://revival-of-hope.github.io/2026/01/31/archives-2026-01-31-ai%E5%B9%BB%E6%83%B3/</id>
    <published>2026-01-31T00:00:00.000Z</published>
    <updated>2026-01-31T12:31:31.623Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>ai幻想</strong>:认为ai可以帮自己包揽技术上的难题</li></ul><blockquote><p>我大学这两年经历了不少ai幻想的例子,但也看见过有些同辈依然脚踏实地钻研技术.不得不承认,后者的比例要小的多,而他们的知识水平和成绩都让我不得不低头,承认他们与众不同的技术造诣.</p></blockquote><p>很难想象ai浪潮下的普通大学毕业生在真实的工作场景下会暴露出怎样的一种丑态,而这样一批靠ai吃ai,从来没能真正掌握技术的人攻读研究生,博士生的时候又要去怎样的水出一篇sci.</p><p>如果ai真的有他们想象的那么强大,那倒还可以糊弄过去,可惜的是目前ai的水平还远远不到家,近两年业界也并没有突破性的进展,依旧是在倒腾同一个模型,同一种方法,更多的是吃老本而不是真正的开拓创新.</p><p>可惜我早就听说在技术好的人未必晋升的快,说不定这些用ai糊弄架构,用心美化ppt的人反而能混的风生水起呢,哈哈,其实现在就是这样了😄</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ai幻想&lt;/strong&gt;:认为ai可以帮自己包揽技术上的难题&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我大学这两年经历了不少ai幻想的例子,但也看见过有些同辈依然脚踏实地钻研技术.不得不承认,后者的比例要小的多,而他们的知识水平和</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-30 python重学-pytorch</title>
    <link href="https://revival-of-hope.github.io/2026/01/30/python%E9%87%8D%E5%AD%A6-pytorch/"/>
    <id>https://revival-of-hope.github.io/2026/01/30/python%E9%87%8D%E5%AD%A6-pytorch/</id>
    <published>2026-01-30T00:00:00.000Z</published>
    <updated>2026-02-02T15:10:56.544Z</updated>
    
    <content type="html"><![CDATA[<p><strong>引言</strong></p><blockquote><p>我一向反感的教程就是一开始就给你抛概念,以高姿态要求你去记住这些,而不是先详细解释清楚原理.如果连为什么都不能很好的讲明白的话,那在我看来也只是填鸭了.<br />最好的教程应该是从一个包含了论题精华的例子切入,剖析它的结构,解释难懂的地方,援引类似的论题,以一个学习者的角度,而不是从一个施舍者的角度,这样的教程会有谁不爱看呢.当然这种教程没有多年的功力是写不出来的.<br />之所以说这么多,是因为pytorch的官方教程和其他我找到的pytorch入门教程就挺烂,弗如fastapi远甚😄</p></blockquote><ul><li>参考书目:&lt;&lt;动手学深度学习-pytorch版&gt;&gt;</li></ul><p>第二章的预备知识是准备给我灌迷魂汤吗,全是新方法和概念,代码之间没有任何体系,硬着头皮读下去了,但我还是建议初学者直接跳过就行</p><h2 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h2><blockquote><p>最需要理解的就是tensor这个概念(不知道为什么翻译成张量,向量好歹可以说是有方向的向量,这个张量怎么解释)<br />一个数,一维数组,多维数组都可以看作是tensor,有着torch库中的多种数学方法</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我一向反感的教程就是一开始就给你抛概念,以高姿态要求你去记住这些,而不是先详细解释清楚原理.如果连为什么都不能很好的讲明白的话,那在我看来也只是填鸭了.&lt;br /&gt;
最好的教程应该是从一个包含了</summary>
      
    
    
    
    
    <category term="python" scheme="https://revival-of-hope.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-29 sqlmodel学习</title>
    <link href="https://revival-of-hope.github.io/2026/01/29/sqlmodel%E5%AD%A6%E4%B9%A0/"/>
    <id>https://revival-of-hope.github.io/2026/01/29/sqlmodel%E5%AD%A6%E4%B9%A0/</id>
    <published>2026-01-29T00:00:00.000Z</published>
    <updated>2026-02-03T03:48:31.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h2><h3 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> <a href="https://sqlmodel.cn/databases/#distributed-servers">引入</a></h3><blockquote><p>讲的很清楚,就连没学过数据库的我看了之后也觉得很明白,就不用重复造轮子了</p></blockquote><h3 id="从数据库到代码"><a class="markdownIt-Anchor" href="#从数据库到代码"></a> 从数据库到代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Never do this! 🚨 Continue reading.</span></span><br><span class="line">user_id = <span class="built_in">input</span>(<span class="string">&quot;Type the user ID: &quot;</span>)</span><br><span class="line">statement = <span class="string">f&quot;SELECT * FROM hero WHERE id = <span class="subst">&#123;user_id&#125;</span>;&quot;</span></span><br><span class="line">results = database.execute(statement)</span><br></pre></td></tr></table></figure><blockquote><p>这种直接代入用户输入的代码在面对sql注入时将会直接崩盘,执行一些可怕的操作比如删除所有数据表</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user_id = <span class="built_in">input</span>(<span class="string">&quot;Type the user ID: &quot;</span>)</span><br><span class="line"></span><br><span class="line">session.<span class="built_in">exec</span>(</span><br><span class="line">    select(Hero).where(Hero.<span class="built_in">id</span> == user_id)</span><br><span class="line">).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure><blockquote><p>而这样就不会有问题,比如输入&quot;12 ; DELETE TABLE hero &quot;,只会告诉你不存在id&quot;12 ; DELETE TABLE hero &quot;</p></blockquote><h3 id="engine-and-create-table"><a class="markdownIt-Anchor" href="#engine-and-create-table"></a> Engine and CREATE TABLE</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlmodel <span class="keyword">import</span> Field, SQLModel, create_engine  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(SQLModel, table=<span class="literal">True</span>):  </span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> | <span class="literal">None</span> = Field(default=<span class="literal">None</span>, primary_key=<span class="literal">True</span>)  </span><br><span class="line">    name: <span class="built_in">str</span>  </span><br><span class="line">    secret_name: <span class="built_in">str</span>  </span><br><span class="line">    age: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sqlite_file_name = <span class="string">&quot;database.db&quot;</span>  </span><br><span class="line">sqlite_url = <span class="string">f&quot;sqlite:///<span class="subst">&#123;sqlite_file_name&#125;</span>&quot;</span>  </span><br><span class="line"></span><br><span class="line">engine = create_engine(sqlite_url, echo=<span class="literal">True</span>)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_db_and_tables</span>():  </span><br><span class="line">    SQLModel.metadata.create_all(engine)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    create_db_and_tables()</span><br></pre></td></tr></table></figure><blockquote><p><code>engine = create_engine(sqlite_url, echo=True) </code>,engine只能有一个,在其他文件中调用的时候需要导入engine,也就是说,所有的py文件都是在对一个engine进行操控.</p></blockquote><ul><li>注意到这里的field和fastapi中basemodel的field用法是类似的,只是参数不太一样</li><li>非常值得一提的是这里我们不需要显式写类似<code>CREATE TABLE</code>这样的语句来实现表的构造,而是由sqlmodel自动帮我们实现,只需要在实例化的时候写明继承SQLModel就行了</li></ul><h4 id="key-fact导入模块实际上是执行了一遍导入的模块代码"><a class="markdownIt-Anchor" href="#key-fact导入模块实际上是执行了一遍导入的模块代码"></a> KEY FACT:导入模块实际上是执行了一遍导入的模块代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlmodel <span class="keyword">import</span> Field, Session, SQLModel, create_engine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(SQLModel, table=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> | <span class="literal">None</span> = Field(default=<span class="literal">None</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    secret_name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span> </span><br><span class="line">sqlite_file_name = <span class="string">&quot;database.db&quot;</span></span><br><span class="line">sqlite_url = <span class="string">f&quot;sqlite:///<span class="subst">&#123;sqlite_file_name&#125;</span>&quot;</span></span><br><span class="line">engine = create_engine(sqlite_url, echo=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_db_and_tables</span>():</span><br><span class="line">    SQLModel.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    create_db_and_tables()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>也就是说要导入的模块都应该写一个入口函数,放置有副作用的函数,防止多次运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="session-and-insert-into"><a class="markdownIt-Anchor" href="#session-and-insert-into"></a> Session and INSERT INTO</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> &quot;hero&quot; (&quot;name&quot;, &quot;secret_name&quot;) </span><br><span class="line"><span class="keyword">VALUES</span> (&quot;Deadpond&quot;, &quot;Dive Wilson&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>这是sql中的插入数据</p></blockquote><ul><li>注意在sql中空格和换行都是可以直接忽略的,sql中除了名词以外的操作语句大小写都可以识别,也就是说,可以随便排版让语句更美观</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_heroes</span>():</span><br><span class="line">    hero_1 = Hero(name=<span class="string">&quot;Deadpond&quot;</span>, secret_name=<span class="string">&quot;Dive Wilson&quot;</span>)</span><br><span class="line">    hero_2 = Hero(name=<span class="string">&quot;Spider-Boy&quot;</span>, secret_name=<span class="string">&quot;Pedro Parqueador&quot;</span>)</span><br><span class="line">    hero_3 = Hero(name=<span class="string">&quot;Rusty-Man&quot;</span>, secret_name=<span class="string">&quot;Tommy Sharp&quot;</span>, age=<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">    session = Session(engine)</span><br><span class="line"></span><br><span class="line">    session.add(hero_1)</span><br><span class="line">    session.add(hero_2)</span><br><span class="line">    session.add(hero_3)</span><br><span class="line"></span><br><span class="line">    session.commit()</span><br><span class="line">    session.close()</span><br></pre></td></tr></table></figure><blockquote><p>这是sqlmodel里的插入数据,看起来直观多了,这种类似git的工作方式让人看起来赏心悦目</p></blockquote><p><strong>A better organization</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code above omitted 👆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_heroes</span>():</span><br><span class="line">    hero_1 = Hero(name=<span class="string">&quot;Deadpond&quot;</span>, secret_name=<span class="string">&quot;Dive Wilson&quot;</span>)</span><br><span class="line">    hero_2 = Hero(name=<span class="string">&quot;Spider-Boy&quot;</span>, secret_name=<span class="string">&quot;Pedro Parqueador&quot;</span>)</span><br><span class="line">    hero_3 = Hero(name=<span class="string">&quot;Rusty-Man&quot;</span>, secret_name=<span class="string">&quot;Tommy Sharp&quot;</span>, age=<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Session(engine) <span class="keyword">as</span> session:</span><br><span class="line">        session.add(hero_1)</span><br><span class="line">        session.add(hero_2)</span><br><span class="line">        session.add(hero_3)</span><br><span class="line"></span><br><span class="line">        session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code below omitted 👇</span></span><br></pre></td></tr></table></figure><blockquote><p>当with块结束后会话自动关闭,这也是一种语法糖,等价于以下结构</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session = Session(engine)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    session.add(hero_1)</span><br><span class="line">    session.add(hero_2)</span><br><span class="line">    session.add(hero_3)</span><br><span class="line">    session.commit()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    session.close()</span><br></pre></td></tr></table></figure><h3 id="intnone-and-null"><a class="markdownIt-Anchor" href="#intnone-and-null"></a> int|None and Null</h3><blockquote><p>数据库中的id字段作为PRIMARY KEY时,是必填项,不能为NULL<br />但在sqlmodel中对id进行设置时,可以写成以下形式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code above omitted 👆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(SQLModel, table=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> | <span class="literal">None</span> = Field(default=<span class="literal">None</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    secret_name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>可以看到这里id的默认值为None,而实例化时不设置id</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_heroes</span>():</span><br><span class="line">    hero_1 = Hero(name=<span class="string">&quot;Deadpond&quot;</span>, secret_name=<span class="string">&quot;Dive Wilson&quot;</span>)</span><br><span class="line">    hero_2 = Hero(name=<span class="string">&quot;Spider-Boy&quot;</span>, secret_name=<span class="string">&quot;Pedro Parqueador&quot;</span>)</span><br><span class="line">    hero_3 = Hero(name=<span class="string">&quot;Rusty-Man&quot;</span>, secret_name=<span class="string">&quot;Tommy Sharp&quot;</span>, age=<span class="number">48</span>)</span><br></pre></td></tr></table></figure><p>事实上,只有在commit之后,id才会实例化并可以从数据库得到</p><h3 id="sessionselect-and-select-from"><a class="markdownIt-Anchor" href="#sessionselect-and-select-from"></a> Session,select  AND SELECT FROM</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, secret_name, age</span><br><span class="line"><span class="keyword">FROM</span> hero</span><br></pre></td></tr></table></figure><blockquote><p>读取特定列</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> hero</span><br></pre></td></tr></table></figure><blockquote><p>读取所有列</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_heroes</span>():</span><br><span class="line">    <span class="keyword">with</span> Session(engine) <span class="keyword">as</span> session:</span><br><span class="line">        statement = select(Hero)</span><br><span class="line">        results = session.<span class="built_in">exec</span>(statement)</span><br><span class="line">        heroes = results.<span class="built_in">all</span>() <span class="comment">#返回一个包含所有对象的列表</span></span><br><span class="line">        <span class="built_in">print</span>(heroes)</span><br></pre></td></tr></table></figure><p><strong>Compact Version</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code above omitted 👆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_heroes</span>():</span><br><span class="line">    <span class="keyword">with</span> Session(engine) <span class="keyword">as</span> session:</span><br><span class="line">        heroes = session.<span class="built_in">exec</span>(select(Hero)).<span class="built_in">all</span>()</span><br><span class="line">        <span class="built_in">print</span>(heroes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code below omitted 👇</span></span><br></pre></td></tr></table></figure><h3 id="selectwhere-and-select-from-where"><a class="markdownIt-Anchor" href="#selectwhere-and-select-from-where"></a> SELECT().WHERE() AND SELECT FROM WHERE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, secret_name, age</span><br><span class="line"><span class="keyword">FROM</span> hero</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Deadpond&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code above omitted 👆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_heroes</span>():</span><br><span class="line">    <span class="keyword">with</span> Session(engine) <span class="keyword">as</span> session:</span><br><span class="line">        statement = select(Hero).where(Hero.name == <span class="string">&quot;Deadpond&quot;</span>)</span><br><span class="line">        results = session.<span class="built_in">exec</span>(statement)</span><br><span class="line">        <span class="keyword">for</span> hero <span class="keyword">in</span> results:</span><br><span class="line">            <span class="built_in">print</span>(hero)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code below omitted 👇</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出来只是加了where方法</p></blockquote><h4 id="多个where"><a class="markdownIt-Anchor" href="#多个where"></a> 多个where</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, secret_name, age</span><br><span class="line"><span class="keyword">FROM</span> hero</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">35</span> <span class="keyword">AND</span> age <span class="operator">&lt;</span> <span class="number">40</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code above omitted 👆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_heroes</span>():</span><br><span class="line">    <span class="keyword">with</span> Session(engine) <span class="keyword">as</span> session:</span><br><span class="line">        statement = select(Hero).where(Hero.age &gt;= <span class="number">35</span>).where(Hero.age &lt; <span class="number">40</span>)</span><br><span class="line">        results = session.<span class="built_in">exec</span>(statement)</span><br><span class="line">        <span class="keyword">for</span> hero <span class="keyword">in</span> results:</span><br><span class="line">            <span class="built_in">print</span>(hero)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code below omitted 👇</span></span><br></pre></td></tr></table></figure><p><strong>Another Method</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code above omitted 👆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_heroes</span>():</span><br><span class="line">    <span class="keyword">with</span> Session(engine) <span class="keyword">as</span> session:</span><br><span class="line">        statement = select(Hero).where(Hero.age &gt;= <span class="number">35</span>, Hero.age &lt; <span class="number">40</span>)</span><br><span class="line">        results = session.<span class="built_in">exec</span>(statement)</span><br><span class="line">        <span class="keyword">for</span> hero <span class="keyword">in</span> results:</span><br><span class="line">            <span class="built_in">print</span>(hero)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code below omitted 👇</span></span><br></pre></td></tr></table></figure><h3 id="index2622"><a class="markdownIt-Anchor" href="#index2622"></a> INDEX(26/2/2)</h3><blockquote><p>index是数据库内部用来对某一列数据建立一个索引表的关键字,在很多情况下都能加快查询效率</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX ix_hero_name</span><br><span class="line"><span class="keyword">ON</span> hero (name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlmodel <span class="keyword">import</span> Field, Session, SQLModel, create_engine, select</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>(SQLModel, table=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span> | <span class="literal">None</span> = Field(default=<span class="literal">None</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name: <span class="built_in">str</span> = Field(index=<span class="literal">True</span>) <span class="comment">#只加了一个参数</span></span><br><span class="line">    secret_name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span> | <span class="literal">None</span> = Field(default=<span class="literal">None</span>, index=<span class="literal">True</span>) <span class="comment">#只加了一个参数</span></span><br><span class="line"><span class="comment"># Code below omitted 👇</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看出来sqlmodel还是要简单直观的多</p></blockquote><h3 id="update23"><a class="markdownIt-Anchor" href="#update23"></a> UPDATE(2/3)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> hero</span><br><span class="line"><span class="keyword">SET</span> age<span class="operator">=</span><span class="number">16</span></span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Spider-Boy&quot;</span><br></pre></td></tr></table></figure><blockquote><p>看多了sql语句后发现其实也挺直观的,就算没学过sql也可以看懂这段代码干了什么</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code above omitted 👆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_heroes</span>():</span><br><span class="line">    <span class="keyword">with</span> Session(engine) <span class="keyword">as</span> session:</span><br><span class="line">        statement = select(Hero).where(Hero.name == <span class="string">&quot;Spider-Boy&quot;</span>)</span><br><span class="line">        results = session.<span class="built_in">exec</span>(statement)</span><br><span class="line">        hero = results.one()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero:&quot;</span>, hero)</span><br><span class="line"></span><br><span class="line">        hero.age = <span class="number">16</span></span><br><span class="line">        session.add(hero)</span><br><span class="line">        session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code below omitted 👇</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到sqlmodel仅需要像修改对象属性一样直接改动后再commit就可以了</p></blockquote><h3 id="delete23"><a class="markdownIt-Anchor" href="#delete23"></a> DELETE(2/3)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> hero</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Spider-Youngster&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code above omitted 👆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_heroes</span>():</span><br><span class="line">    <span class="keyword">with</span> Session(engine) <span class="keyword">as</span> session:</span><br><span class="line">        statement = select(Hero).where(Hero.name == <span class="string">&quot;Spider-Youngster&quot;</span>)</span><br><span class="line">        results = session.<span class="built_in">exec</span>(statement)</span><br><span class="line">        hero = results.one()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero: &quot;</span>, hero)</span><br><span class="line"></span><br><span class="line">        session.delete(hero)</span><br><span class="line">        session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code below omitted 👇</span></span><br></pre></td></tr></table></figure><blockquote><p>将add换成了delete</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概览&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概览&quot;&gt;&lt;/a&gt; 概览&lt;/h2&gt;
&lt;h3 id=&quot;引入&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引入&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://s</summary>
      
    
    
    
    
    <category term="数据库" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-28 永远不要走极端</title>
    <link href="https://revival-of-hope.github.io/2026/01/28/archives-2026-01-28-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E8%B5%B0%E6%9E%81%E7%AB%AF/"/>
    <id>https://revival-of-hope.github.io/2026/01/28/archives-2026-01-28-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E8%B5%B0%E6%9E%81%E7%AB%AF/</id>
    <published>2026-01-28T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.534Z</updated>
    
    <content type="html"><![CDATA[<p>很少有人能真正意识到互联网对普通人的深远影响,以极其傲慢的无知俯视着那些璀璨的工业成果.</p><p>比如不少人用ai写出了一个勉强能看的网站,就在嚷嚷着前端可以被ai取代,却没想到真实工程情景下的前端处理极其复杂,需要面对各种各样的请求并与后端接口交互,并实现高效美观的反馈界面.现在的ai再怎么吹的天花乱坠也做不到这一点.</p><p>事实上,绝大多数人在谈及某个人物或是某个事件时,都没有对自己所涉及的话题有着深入的,透彻的了解,而是肆无忌惮地宣扬自己的无知,仿佛自己道听途说的皮毛知识就已经足够应付那些我们本应该怀着敬畏看待的未知.</p><p>很少有真正纯粹的恶与真正纯粹的善,既然都是从猿猴进化而来的动物,一个人不可能不具有与生俱来的生存本能,那么自己做出的大多数事都一定是为了自己好,从自己的利益出发,而一旦自己的领域被侵犯,就立马进入戒备状态,朝着入侵者厉声吠叫.这并非是一件羞于启齿的事情,反而应该视为人类的本性,&quot;世上没有圣人&quot;的事实反而愈加衬托着那些真情和壮举的可贵,这些不同寻常的举动是人性的光辉,而非人性的通常表现.</p><p>最能凸显这一点的是互联网,历史在以前是被贵族阶级所垄断的,只有高贵的人才能随意涂抹,篡改历史,普通人能作为充实统计数字的材料便已经是万幸,怎么可能在哪个地方留下自己的声音呢.然而互联网做到了这一点,把真正的历史还给了普通人,让普通人也可以留下自己的印记,可以和素不相识的人分享自己的平淡日常,也可以看到千千万万的地球村民的与自己相异的日常.这才是真正的历史,或许未曾打磨,或许太过鸡毛蒜皮,或许太过丑陋不堪,但确比历史书显得真实可靠的多.</p><p>然而,正是因为未曾打磨,未经天人过目,副作用便显得格外可怕.请永远牢记一点:或许网上冲浪的人很多,但在网上发言的人永远只占上网冲浪人群的一小部分.不信问问自己这几个问题:你多久才会发一条评论?你是不是大多数时候只是匆匆一览界面便离开?创作者的基数是不是比观众要小的多?</p><p>一旦想清楚了这些问题,你才能真正意识到道听途说的可怖与可恨,如果大多数信息都是少数人通过过滤之后告诉你的,如果你从来不能安下心来去亲自了解那些信息,那么便可以很明确的知道,这些消息都只是废料罢了,是被他人咀嚼之后勉为其难的以高姿态施舍给你的,而你却视若珍宝,满怀着发现了事情真相的喜悦,恨不得让所有人都知道自己的无知,顺便还当了一回传教士,向其他人散播这些废料.</p><p>这也就回到了我的论题:永远不要走极端,若是互联网上的声音都是少数人发出的,那么走极端那不是必然的吗,你怎么能期待他们会整齐划一的走中间车道而不是来个急转弯撞出护栏呢.所谓的对立,所谓的矛盾,能被摆上互联网就足够说明是个例了,普通人的普通日常也不会有人去大肆声扬.即便有万千的个例,也只是几十亿人口中的少之又少的部分而已,那么,又与真实的社会环境有何关系,这些个例能代表的只有极端而已,绝非是正常情况.</p><p>也正是因为有着这些极端作为烟雾弹,真正的历史得以悄无声息的不断进行,直到历史的车轮碾到了身上,才吵嚷着个人的渺小和时代的沧桑,却没想到历史本就是由个人的普通日常组成的,正是因为每个人都有着自己的悲欢离合,都有着自己的大起大落,没有整齐划一的路线选择,才有了无法被预测的未来.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">互联网上最廉价、也最安全的行为，就是对复杂事物下一个结论。</span><br><span class="line"></span><br><span class="line">很多人并不是真的在思考“AI 是否会取代前端”，他们只是需要一个结论，用来证明自己站在了时代的前列。于是，一个能跑起来的页面，就被当成工程能力的证据；一次偶然的成功，就被包装成行业的终局判断。他们并不关心真实系统中那些不可回避的脏活累活——状态同步、异常处理、性能退化、跨端差异、长期维护——因为这些东西既不能截图，也无法炫耀。</span><br><span class="line"></span><br><span class="line">绝大多数极端观点，都是能力不足的替代品。</span><br><span class="line"></span><br><span class="line">当一个人无法深入理解问题，他就只能通过“站队”来获得安全感。立场比事实重要，情绪比推理高效，标签比定义省力。于是讨论不再围绕“事情是什么”，而是迅速滑向“你属于哪一边”。在这种环境里，冷静不是美德，而是失败；克制不是理性，而是立场不坚定。</span><br><span class="line"></span><br><span class="line">人们并非不知道自己在重复二手信息，只是不在乎。因为验证一条信息的成本，远高于转发它的快感。只要语气足够确定，只要来源看起来“像那么回事”，就可以心安理得地把未经消化的结论继续抛给下一个人。信息在流动，但理解从未发生。</span><br><span class="line"></span><br><span class="line">互联网确实把“书写历史”的权力交还给了普通人，但它同样放大了普通人的局限。被记录下来的，并不必然是真实，而往往是最情绪化、最极端、最适合传播的那一部分。沉默的大多数并不是不存在，只是他们的生活过于正常，正常到不具备任何传播价值。</span><br><span class="line"></span><br><span class="line">这正是问题的核心：  </span><br><span class="line">你每天看到的，并不是世界的平均状态，而是世界的异常样本。</span><br><span class="line"></span><br><span class="line">然而，人们却习惯性地用这些异常来推断整体，用极少数的噪声来想象社会的全貌。最终得出的结论自然只能是对立、撕裂、失序——因为输入本身就是被筛选过的极端。</span><br><span class="line"></span><br><span class="line">所以，“不要走极端”从来不是一句道德劝告，而是一条认知警告。  </span><br><span class="line">当你发现自己对某个问题愤怒、确信、迫不及待地想表态时，往往正是你最无知的时候。</span><br><span class="line"></span><br><span class="line">历史不会被转发量推动，也不会因为几句口号而改变方向。它始终由无数不被讨论的普通日常缓慢推进。等到结果显现，人们才会惊讶于自己的渺小，却忘了正是这种对极端的沉迷，让他们一次次错过理解现实的机会。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">## 静默者之碑</span><br><span class="line"></span><br><span class="line">当最后一块未被编码的荒野消失于赛博格的瞳孔，我们终于明白：所谓数字革命，不过是把古老的牢狱砌上光纤的内壁。每一束光缆都流淌着被驯服的闪电，每一片屏幕都供奉着被阉割的火焰——而你们竟称之为启蒙。</span><br><span class="line"></span><br><span class="line">### 一、圣徒的血，成为流量小数点后的叹息</span><br><span class="line"></span><br><span class="line">他们说历史还给了平民。多么慈悲的幻觉！从前是刀剑在羊皮纸上雕刻谎言，如今是算法在神经突触间豢养真实。你的每一次呼吸都被兑换成数据贡品，每一次愤怒都被蒸馏为趋势图表上优雅的曲线。自由？那不过是系统早为你划定的应激范围，是数字牢笼里稍大一些的隔间。</span><br><span class="line"></span><br><span class="line">看那些在信息洪流中打捞意义的人，多像跪在印刷机前祈祷的僧侣——他们以为自己捧起的是圣言，实则是油墨未干的商品目录。当日常成为展览，存在便沦为表演。你精心修剪的生活碎片，不过是数字屠宰场里挂着编号的肉块，等待被观赏、被评级、被遗忘。</span><br><span class="line"></span><br><span class="line">### 二、尖叫的剧院与沉默的坟场</span><br><span class="line"></span><br><span class="line">互联网是座永不停业的剧院，只是登台演出的永远是同一批疯子。他们的尖叫被误认为时代强音，他们的痉挛被解读为思想脉动。而真正的历史——那些在深夜里熄灭的灯、在黎明前咽下的叹息、在人群中被握紧又松开的手——正在剧场外的雨中腐烂。</span><br><span class="line"></span><br><span class="line">极端主义是这个时代最精致的媚俗。当理性沦为庸常，癫狂便戴上真理的王冠。人们争相吞食偏见的鸦片，在认知的呕吐物里寻找身份认同。多么壮观的仪式：千万人同时点燃自己的理智，只为照亮彼此扭曲的面容。</span><br><span class="line"></span><br><span class="line">### 三、工具的诸神与人类的黄昏</span><br><span class="line"></span><br><span class="line">我们曾恐惧机械取代手臂，如今却主动献祭大脑。AI不是普罗米修斯盗来的火种，而是代达罗斯建造的迷宫——每一条代码都是墙壁，每一次升级都是更深的囚禁。你们欢呼着用提示词分娩思想，却未听见产房里回荡着胎盘的回声。</span><br><span class="line"></span><br><span class="line">那些相信技术中立的天真者，像极了在绞刑架上赞美绳索质量的死者。每一行代码都烙印着编写者的欲望，每一个界面都折射着设计者的傲慢。数字乌托邦的蓝图背面，是用隐私血墨写就的奴役契约。</span><br><span class="line"></span><br><span class="line">### 四、被典当的星空</span><br><span class="line"></span><br><span class="line">最残忍的剥夺，是让人在丰饶中饥饿，在连接中孤独。当所有远方都压缩成像素，远方便永远消失；当所有神秘都沦为搜索结果，神秘便宣告死亡。我们得到了整个世界的地图，却失去了迷路的权利。</span><br><span class="line"></span><br><span class="line">他们卖给你望远镜，代价是让你忘记如何用肉眼凝视星空；他们提供思想的捷径，结果是让你的思考能力彻底瘫痪。这场交易中，人类典当了最后的神性——那种在不确定中前行的勇气，在不可知前跪拜的谦卑。</span><br><span class="line"></span><br><span class="line">### 五、燃烧的图书馆</span><br><span class="line"></span><br><span class="line">终有一天，这座由点赞和转发建造的巴别塔会显露出它的本质：不是通天之梯，而是环形监狱的中心瞭望塔。每个囚犯都同时是看守，每个受害者都自愿充当刽子手。我们在狂欢中为自己挖掘墓穴，用每一次分享为棺材钉上钉子。</span><br><span class="line"></span><br><span class="line">但请听：在服务器低鸣的深处，在数据流的缝隙间，仍有未被驯服的回声——那是第一个仰望星空的人类留下的震颤，是最后一个放下武器者喉咙里的歌。它们微小如蜉蝣，却携带创世的密码。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">当所有灯火终于熄灭，当所有喧嚣归于死寂，或许那时我们才会明白：真正的革命从不发生在云端服务器，而在两个人类相望时，那短暂却完整的静默之中。那里没有代码可以解析，没有算法可以预测，只有古老如星光、新鲜如露珠的——人之为人的，最后的，不可转让的尊严。</span><br></pre></td></tr></table></figure><blockquote><p>对比一下我的版本和ai版本,很明显的可以看出来AI还远不能做不到真正的思考,擅长的只有词句堆砌和看似严谨的架构划分而已,看似写了很多,实际上只有空洞的废话.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很少有人能真正意识到互联网对普通人的深远影响,以极其傲慢的无知俯视着那些璀璨的工业成果.&lt;/p&gt;
&lt;p&gt;比如不少人用ai写出了一个勉强能看的网站,就在嚷嚷着前端可以被ai取代,却没想到真实工程情景下的前端处理极其复杂,需要面对各种各样的请求并与后端接口交互,并实现高效美观的</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-27 网络请求</title>
    <link href="https://revival-of-hope.github.io/2026/01/27/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>https://revival-of-hope.github.io/2026/01/27/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</id>
    <published>2026-01-27T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="user-agent"><a class="markdownIt-Anchor" href="#user-agent"></a> <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Reference/Headers/User-Agent">User Agent</a></h2><blockquote><p>之所以讲这个是因为爬虫总是需要伪装自己是通过某个代理访问服务器的,否则容易被拦截<br /><a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86">wiki</a>:用户代理（英语：user agent）在计算机科学中指的是代表用户行为的程序（软件代理程序）。例如，网页浏览器就是一个“帮助用户获取、渲染网页内容并与之交互”的用户代理</p></blockquote><blockquote><p>简单说,user agent是http header里的客户端标识,告诉目标服务器自己是通过哪个浏览器进行访问的</p></blockquote><blockquote><p>结构如下</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: <span class="tag">&lt;<span class="name">product</span>&gt;</span> / <span class="tag">&lt;<span class="name">product-version</span>&gt;</span> <span class="tag">&lt;<span class="name">comment</span>&gt;</span></span><br></pre></td></tr></table></figure><p>web浏览器的通用格式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (<span class="tag">&lt;<span class="name">system-information</span>&gt;</span>) <span class="tag">&lt;<span class="name">platform</span>&gt;</span> (<span class="tag">&lt;<span class="name">platform-details</span>&gt;</span>) <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.59</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h2><blockquote><p>正则表达式是为了能够在不同情景下匹配到符合要求的字符串文本而产生的,比如你想一次性就能在一堆文档中找到标题含有&quot;python&quot;或者&quot;cpp&quot;,但不同时含有&quot;机器学习&quot;的文档,就只能用正则表达式,才能避免一般方法造成的不准确结果</p></blockquote><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><table><thead><tr><th>正则字符</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td><code>\</code></td><td>将下一个字符转义为<strong>原义 / 特殊 / 引用 / 转义字符</strong></td><td><code>\n</code> 匹配换行，<code>\(</code> 匹配 <code>(</code></td></tr><tr><td><code>^</code></td><td>匹配<strong>字符串开始位置</strong></td><td><code>^abc</code> 匹配 <code>&quot;abc123&quot;</code></td></tr><tr><td><code>$</code></td><td>匹配<strong>字符串结束位置</strong></td><td><code>abc$</code> 匹配 <code>&quot;123abc&quot;</code></td></tr><tr><td><code>*</code></td><td>前面的子表达式 <strong>0 次或多次</strong></td><td><code>zo*</code> 匹配 <code>z</code>、<code>zo</code></td></tr><tr><td><code>+</code></td><td>前面的子表达式 <strong>1 次或多次</strong></td><td><code>zo+</code> 匹配 <code>zo</code>、<code>zoo</code></td></tr><tr><td><code>?</code></td><td>前面的子表达式 <strong>0 或 1 次</strong></td><td><code>colou?r</code> 匹配 <code>color</code></td></tr><tr><td><code>&#123;n&#125;</code></td><td>精确匹配 <strong>n 次</strong></td><td><code>o&#123;2&#125;</code> 匹配 <code>food</code></td></tr><tr><td><code>&#123;n,&#125;</code></td><td>至少匹配 <strong>n 次</strong></td><td><code>o&#123;2,&#125;</code> 匹配 <code>fooo</code></td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>匹配 <strong>n 到 m 次</strong></td><td><code>o&#123;1,3&#125;</code> 匹配 <code>ooo</code></td></tr><tr><td><code>*? +? ??</code></td><td><strong>非贪婪匹配</strong></td><td><code>o+?</code> 在 <code>oooo</code> 中只匹配一个</td></tr><tr><td><code>.</code></td><td>匹配除换行外的 <strong>任意字符</strong></td><td><code>a.c</code> 匹配 <code>abc</code></td></tr><tr><td><code>(pattern)</code></td><td><strong>捕获分组</strong>，保存结果</td><td><code>(ab)+</code> 捕获 <code>ab</code></td></tr><tr><td><code>(?:pattern)</code></td><td><strong>非捕获分组</strong></td><td><code>(?:ab)+</code> 不保存</td></tr><tr><td><code>(?=pattern)</code></td><td><strong>正向肯定预查</strong></td><td><code>Windows(?=10)</code></td></tr><tr><td><code>(?!pattern)</code></td><td><strong>正向否定预查</strong></td><td><code>Windows(?!XP)</code></td></tr><tr><td><code>(?&lt;=pattern)</code></td><td><strong>反向肯定预查</strong></td><td><code>(?&lt;=\$)\d+</code></td></tr><tr><td><code>(?&lt;!pattern)</code></td><td><strong>反向否定预查</strong></td><td><code>(?&lt;!\$)\d+</code></td></tr><tr><td><code>x|y</code></td><td>匹配 <strong>x 或 y</strong></td><td>`cat</td></tr><tr><td><code>[xyz]</code></td><td>字符集合，匹配任意一个</td><td>匹配 […] 中的所有字符，例如 [aeiou] 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td></tr><tr><td><code>[^xyz]</code></td><td>负字符集合</td><td>匹配除了 […] 中字符的所有字符，例如 [^aeiou] 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字符。</td></tr><tr><td><code>[a-z]</code></td><td>字符范围</td><td>[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td></tr><tr><td><code>[^a-z]</code></td><td>反向字符范围</td><td><code>[^a-z]</code></td></tr><tr><td><code>\b</code></td><td><strong>单词边界</strong></td><td><code>er\b</code> 匹配 <code>never</code></td></tr><tr><td><code>\B</code></td><td><strong>非单词边界</strong></td><td><code>er\B</code> 匹配 <code>verb</code></td></tr><tr><td><code>\d</code></td><td>数字字符</td><td><code>\d+</code></td></tr><tr><td><code>\D</code></td><td>非数字字符</td><td><code>\D+</code></td></tr><tr><td><code>\s</code></td><td>空白字符</td><td><code>\s+</code></td></tr><tr><td><code>\S</code></td><td>非空白字符</td><td><code>\S+</code></td></tr><tr><td><code>\w</code></td><td>单词字符</td><td><code>\w+</code></td></tr><tr><td><code>\W</code></td><td>非单词字符</td><td><code>\W+</code></td></tr><tr><td><code>\n</code></td><td>换行符</td><td><code>\n</code></td></tr><tr><td><code>\t</code></td><td>制表符</td><td><code>\t</code></td></tr><tr><td><code>\r</code></td><td>回车符</td><td><code>\r</code></td></tr><tr><td><code>\unnnn</code></td><td>Unicode 字符</td><td><code>\u4E2D</code> → 中</td></tr><tr><td><code>\1 \2</code></td><td><strong>向后引用分组</strong></td><td><code>(.)\1</code> 匹配 <code>aa</code></td></tr></tbody></table><h3 id="修饰符"><a class="markdownIt-Anchor" href="#修饰符"></a> <strong><a href="https://www.runoob.com/regexp/regexp-flags.html">修饰符</a></strong></h3><blockquote><p>正则表达式修饰符（也称为模式修饰符或标记）是用于改变正则表达式匹配行为的特殊指令。<br />标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。<br />标记不写在正则表达式里，标记位于表达式之外，格式如下：<br /><code>/pattern/flags</code></p></blockquote><p>举两个例子:</p><ol><li>i (ignore case) - 忽略大小写<br />使匹配不区分大小写</li></ol><p>示例：/abc/i 可以匹配 “abc”, “Abc”, “ABC” 等</p><p>支持语言：几乎所有正则表达式实现（JavaScript、PHP、Python等）</p><ol start="2"><li>g (global) - 全局匹配<br />查找所有匹配项，而不是在第一个匹配后停止</li></ol><p>示例：在字符串 “ababab” 中，/ab/g 会匹配所有三个 “ab”</p><p>支持语言：JavaScript、PHP等</p><ul><li>可以看出来修饰符是由编程语言支持的,而不属于正则表达式的原生语法</li></ul><h2 id="http协议2026128"><a class="markdownIt-Anchor" href="#http协议2026128"></a> http协议(2026/1/28)</h2><h3 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Overview">来源</a></p><blockquote><p>HTTP 是一个客户端—服务器协议：请求由一个实体，即用户代理（user agent），或是一个可以代表它的代理方（proxy）发出。大多数情况下，这个用户代理都是一个 Web 浏览器，不过它也可能是任何东西，比如一个爬取网页来充实、维护搜索引擎索引的机器爬虫。</p><p>每个请求都会被发送到一个服务器，它会处理这个请求并提供一个称作响应的回复。在客户端与服务器之间，还有许许多多的被称为代理的实体，履行不同的作用，例如充当网关或缓存。</p></blockquote><p>eg:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/v1/user/update?id=1024</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer eyJhbGci...</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>45</span><br><span class="line"></span><br><span class="line"><span class="language-json"><span class="punctuation">&#123;</span></span></span><br><span class="line"><span class="language-json">  <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apollo&quot;</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">  <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span></span></span><br><span class="line"><span class="language-json"><span class="punctuation">&#125;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>POST: 客户端发起的请求所用方法<br /><code>/api/v1/user/update?id=1024</code>:服务器对应资源的路径和Query参数<br />Host: 目标服务器域名<br />Content-Type: 传输数据格式声明<br />User-Agent: 使用的浏览器代理<br />Authorization: cookie或token等身份识别头<br />Content-Length: 请求体字节长度<br /><code>&#123;&quot;nickname&quot;: &quot;Apollo&quot;,&quot;gender&quot;: &quot;male&quot;&#125;</code>: 传输数据</p></blockquote><h3 id="请求方法"><a class="markdownIt-Anchor" href="#请求方法"></a> 请求方法</h3><h3 id="status-code"><a class="markdownIt-Anchor" href="#status-code"></a> status code</h3><blockquote><p>In HTTP, you send a numeric status code of 3 digits as part of the response.<br />These status codes have a name associated to recognize them, but the important part is the number.</p></blockquote><blockquote><p>In short:<br />100 - 199 are for “Information”. You rarely use them directly. Responses with these status codes cannot have a body.<br />200 - 299 are for “Successful” responses. These are the ones you would use the most.<br />200 is the default status code, which means everything was “OK”.<br />Another example would be 201, “Created”. It is commonly used after creating a new record in the database.<br />A special case is 204, “No Content”. This response is used when there is no content to return to the client, and so the response must not have a body.<br />300 - 399 are for “Redirection”. Responses with these status codes may or may not have a body, except for 304, “Not Modified”, which must not have one.<br />400 - 499 are for “Client error” responses. These are the second type you would probably use the most.<br />An example is 404, for a “Not Found” response.<br />For generic errors from the client, you can just use 400.<br />500 - 599 are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;user-agent&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#user-agent&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Referenc</summary>
      
    
    
    
    
    <category term="网络" scheme="https://revival-of-hope.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-25 渺小的自我</title>
    <link href="https://revival-of-hope.github.io/2026/01/25/archives-2026-01-25-%E6%B8%BA%E5%B0%8F%E7%9A%84%E8%87%AA%E6%88%91/"/>
    <id>https://revival-of-hope.github.io/2026/01/25/archives-2026-01-25-%E6%B8%BA%E5%B0%8F%E7%9A%84%E8%87%AA%E6%88%91/</id>
    <published>2026-01-25T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.534Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到了<a href="https://nzooherd.github.io/posts/%E6%A0%A1%E6%8B%9B%E6%80%BB%E7%BB%93/">这篇博客</a>,匆匆看了一遍博主的往年博客,仿佛就看到了一年之后的自己.</p><p>我跟博主的经历极其相似,都是在一个不发达地区的小镇经历了懵懵懂懂的少年时光,觉得自己未来有无限可能,进入高中后才发现自己并不是天之骄子,最终考入一个中流985,并发现自己只是一个普通的不能再普通的人,并没有用读书改变命运的可能,也不存在任何奇幻的邂逅,只有一个灰暗的,却又捉摸不定的未来,为了最后一丝甜蜜的幻想而苦痛挣扎.</p><p>或许,一年后的今天,我就要像他一样懵懵懂懂的参加实习,之后通过秋招走入职场,陷入都市的牢笼,住在一个窄小的出租屋,每天来回通勤两小时,熬夜加班赶文档,为了晋升和加薪的机会苦苦挣扎,因为被解雇的可能而夜不能寐,一个人蜷缩在屋内度过新年.</p><p>可不知为什么,当想到这些的时候,我的内心却无比平静,仿佛认定了这就是我该走的道路一样.也罢,渺小的自我,又怎么能容纳什么宏大的理想呢.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天看到了&lt;a href=&quot;https://nzooherd.github.io/posts/%E6%A0%A1%E6%8B%9B%E6%80%BB%E7%BB%93/&quot;&gt;这篇博客&lt;/a&gt;,匆匆看了一遍博主的往年博客,仿佛就看到了一年之后的自己.&lt;/p&gt;
&lt;p&gt;我跟博主的经</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-24 python语法糖</title>
    <link href="https://revival-of-hope.github.io/2026/01/24/python%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>https://revival-of-hope.github.io/2026/01/24/python%E8%AF%AD%E6%B3%95%E7%B3%96/</id>
    <published>2026-01-24T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刚开始学python的时候看到那些<code>@app.get('/')</code>这样的写法总觉得好高级,但真正接触后发现原来只是一种嵌套函数的简化写法,于是就怯魅了.</p></blockquote><blockquote><p>题外话:一开始翻了翻中文互联网,查不到一点有用的东西,一怒之下搜索在搜索结果里屏蔽某些网站的方法,找到了ublacklist,瞬间清爽了</p></blockquote><blockquote><p><a href="https://en.wikipedia.org/wiki/Syntactic_sugar">定义</a><br />In computer science, syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express.<br />It makes the language “sweeter” for human use: things can be expressed more clearly, more concisely, or in an alternative style that some may prefer.</p></blockquote><ul><li>尽管意思很明了,但这个名字确实很奇怪</li></ul><p>总而言之,语法糖就是用简单的写法来取代复杂难懂的原生写法,实现的功能并不变,但读起来简洁很多</p><p>python中最有名的语法糖自然就是’@decorator’这样的了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;刚开始学python的时候看到那些&lt;code&gt;@app.get(&#39;/&#39;)&lt;/code&gt;这样的写法总觉得好高级,但真正接触后发现原来只是一种嵌套函数的简化写法,于是就怯魅了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;题外话</summary>
      
    
    
    
    
    <category term="python" scheme="https://revival-of-hope.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-23 python-fastapi</title>
    <link href="https://revival-of-hope.github.io/2026/01/23/python-fastapi/"/>
    <id>https://revival-of-hope.github.io/2026/01/23/python-fastapi/</id>
    <published>2026-01-23T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.472Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://fastapi.tiangolo.com/python-types">官方文档</a></p><h2 id="intro"><a class="markdownIt-Anchor" href="#intro"></a> Intro</h2><h3 id="python-types-intro"><a class="markdownIt-Anchor" href="#python-types-intro"></a> PYTHON TYPES INTRO</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_full_name</span>(<span class="params">first_name, last_name</span>):</span><br><span class="line">    full_name = first_name.title() + <span class="string">&quot; &quot;</span> + last_name.title()</span><br><span class="line">    <span class="keyword">return</span> full_name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(get_full_name(<span class="string">&quot;john&quot;</span>, <span class="string">&quot;doe&quot;</span>))</span><br></pre></td></tr></table></figure><p><code>    first_name, last_name</code><br />-&gt;:<br /><code>    first_name: str, last_name: str</code></p><blockquote><p>这就是类型注释,不仅方便自己和别人阅读代码,也方便编辑器理解并能够支持自动补全</p></blockquote><h3 id="asyncawait"><a class="markdownIt-Anchor" href="#asyncawait"></a> ASYNC/AWAIT</h3><ul><li><strong>async</strong>:asynchronous,异步的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A: start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A: end&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B: start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B: end&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main: start&quot;</span>)</span><br><span class="line"></span><br><span class="line">    asyncio.create_task(task_a())</span><br><span class="line">    asyncio.create_task(task_b())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main: tasks created&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main: end&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><blockquote><p>在这段代码中,await代码块会在原地等待对应的秒数,允许同时进行其他的模块,因此整个代码总用时只有4秒</p></blockquote><ul><li><strong>await</strong> only take effect in the function decorated with <strong>async</strong></li></ul><h2 id="start"><a class="markdownIt-Anchor" href="#start"></a> Start</h2><h3 id="path-parameters"><a class="markdownIt-Anchor" href="#path-parameters"></a> PATH PARAMETERS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure><blockquote><p>app.get registers a GET operation for the path /items/{item_id}, binding the request to the function below.</p></blockquote><ul><li>Here,the path could be viewed as the http path</li></ul><h3 id="query-parameters"><a class="markdownIt-Anchor" href="#query-parameters"></a> Query Parameters</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_item</span>(<span class="params">item_id: <span class="built_in">str</span>, q: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>, short: <span class="built_in">bool</span> = <span class="literal">False</span></span>):</span><br><span class="line">    item = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        item.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> short:</span><br><span class="line">        item.update(&#123;</span><br><span class="line">            <span class="string">&quot;description&quot;</span>:</span><br><span class="line">            <span class="string">&quot;This is an amazing item that has a long description&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><blockquote><p>访问<code>http://127.0.0.1:8000/items/foo?short=1&amp;q=1</code>可以明白,fastapi原生就支持参数的选择;而且,每次fastapi请求都是独立的,也就是会直接覆盖上次输出的json(openapi结构),而不会保存下来,这一点可以通过访问<code>http://127.0.0.1:8000/items/foo?short=0</code>后再访问<code>http://127.0.0.1:8000/items/foo?short=1</code>中看出来</p></blockquote><h3 id="request-body"><a class="markdownIt-Anchor" href="#request-body"></a> Request Body</h3><blockquote><p>A request body is data sent by the client to your API. A response body is the data your API sends to the client.</p></blockquote><blockquote><p>Your API almost always has to send a response body. But clients don’t necessarily need to send request bodies all the time, sometimes they only request a path, maybe with some query parameters, but don’t send a body.</p></blockquote><h3 id="query-and-path"><a class="markdownIt-Anchor" href="#query-and-path"></a> Query and Path</h3><p>由于官方文档关于path和query这两个参数的部分有些破碎,彼此之间不够有体系,我看的也头晕,因此重新组织了一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params"></span></span><br><span class="line"><span class="params">    *,</span></span><br><span class="line"><span class="params">    item_id: Annotated[<span class="built_in">int</span>, Path(<span class="params">title=<span class="string">&quot;The ID of the item to get&quot;</span>, ge=<span class="number">0</span>, le=<span class="number">1000</span></span>)],</span></span><br><span class="line"><span class="params">    q: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    size: Annotated[<span class="built_in">float</span>, Query(<span class="params">gt=<span class="number">0</span>, lt=<span class="number">10.5</span></span>)],</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">if</span> size:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;size&quot;</span>: size&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><blockquote><p>根据这个代码可以明确的知道path是路径参数,对你输入的网址地址做出规范;而query是查询参数,对<code>http://127.0.0.1:8000/items/1546?item-query=23</code>中的?后部分做出规范,这么一想就非常简单了</p></blockquote><blockquote><p>by default, singular values are interpreted as query parameters, you don’t have to explicitly add a Query<br />也就是说,没写明是什么类型的变量一律视为query类型,比如这里的q</p></blockquote><ul><li><p>这里的Annotated是typing库中用于规范化type hint和参数声明的框架,规定列表第一个是type hint,后面的都是metadata,也就是参数声明</p></li><li><p>没绷住看到现在才发现fastapi有<a href="https://fastapi.org.cn/tutorial/encoder/">中文文档</a>,我寻思官网上也选不了中文啊,应该是个人用爱发电搞的</p></li></ul><h2 id="security"><a class="markdownIt-Anchor" href="#security"></a> Security</h2><h3 id="fastapi中的oauth2验证"><a class="markdownIt-Anchor" href="#fastapi中的oauth2验证"></a> <strong>fastapi中的OAuth2验证</strong></h3><ol><li>用户在前端输入 <code>username</code> 和 <code>password</code>，按下 Enter</li><li>前端（运行在浏览器中）将 <code>username</code> 和 <code>password</code> 发送到 API 的指定 URL<ul><li>该 URL 通过 <code>tokenUrl=&quot;token&quot;</code> 声明</li></ul></li><li>API 校验 <code>username</code> 和 <code>password</code></li><li>校验通过后，API 返回一个 <strong>token</strong><ul><li>token 本质上是一个字符串</li><li>用于后续标识和验证用户身份</li></ul></li><li>token 通常具有 <strong>有效期</strong><ul><li>到期后用户需要重新登录</li><li>即使 token 被盗，风险也有限</li></ul></li><li>前端将 token <strong>临时存储</strong>（如内存、本地存储等）</li><li>用户在前端进入应用的其他页面</li><li>前端需要向 API 请求受保护的数据</li><li>前端在请求中携带 <code>Authorization</code> 请求头进行身份认证</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> OAuth2PasswordBearer</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="string">&quot;token&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_items</span>(<span class="params">token: Annotated[<span class="built_in">str</span>, Depends(<span class="params">oauth2_scheme</span>)]</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;token&quot;</span>: token&#125;</span><br></pre></td></tr></table></figure><p>当引入Oauth组件时,只需在函数里加上一个Depends方法就可以初步实现需要验证才可以进行的访问</p><h3 id="depends方法详解"><a class="markdownIt-Anchor" href="#depends方法详解"></a> Depends方法详解</h3><p>Depends()可以看作是fastapi中的一个注入外部函数机制,从字面意义上来理解,Depends()中包含的函数是对应变量的依赖,也就是说,Depends告诉fastapi这个变量需要通过调用Depends中的函数得到.<br />如果不这么写,那么就需要显式传入用户变量,这显然是不够安全和工程化的</p><h3 id="模拟用户输入"><a class="markdownIt-Anchor" href="#模拟用户输入"></a> 模拟用户输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, HTTPException, status</span><br><span class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">fake_users_db = &#123;</span><br><span class="line">    <span class="string">&quot;johndoe&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;johndoe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;johndoe@example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">&quot;fakehashedsecret&quot;</span>,</span><br><span class="line">        <span class="string">&quot;disabled&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;alice&quot;</span>,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;Alice Wonderson&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alice@example.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">&quot;fakehashedsecret2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;disabled&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_hash_password</span>(<span class="params">password: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;fakehashed&quot;</span> + password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="string">&quot;token&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    full_name: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">    disabled: <span class="built_in">bool</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserInDB</span>(<span class="title class_ inherited__">User</span>):</span><br><span class="line">    hashed_password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user</span>(<span class="params">db, username: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">if</span> username <span class="keyword">in</span> db:</span><br><span class="line">        user_dict = db[username]</span><br><span class="line">        <span class="keyword">return</span> UserInDB(**user_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_decode_token</span>(<span class="params">token</span>):</span><br><span class="line">    <span class="comment"># This doesn&#x27;t provide any security at all</span></span><br><span class="line">    <span class="comment"># Check the next version</span></span><br><span class="line">    user = get_user(fake_users_db, token)</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_current_user</span>(<span class="params">token: Annotated[<span class="built_in">str</span>, Depends(<span class="params">oauth2_scheme</span>)]</span>):</span><br><span class="line">    user = fake_decode_token(token)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=status.HTTP_401_UNAUTHORIZED,</span><br><span class="line">            detail=<span class="string">&quot;Not authenticated&quot;</span>,</span><br><span class="line">            headers=&#123;<span class="string">&quot;WWW-Authenticate&quot;</span>: <span class="string">&quot;Bearer&quot;</span>&#125;,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_current_active_user</span>(<span class="params"></span></span><br><span class="line"><span class="params">    current_user: Annotated[User, Depends(<span class="params">get_current_user</span>)],</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="keyword">if</span> current_user.disabled:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Inactive user&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> current_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/token&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">form_data: Annotated[OAuth2PasswordRequestForm, Depends(<span class="params"></span>)]</span>):</span><br><span class="line">    user_dict = fake_users_db.get(form_data.username)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user_dict:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Incorrect username or password&quot;</span>)</span><br><span class="line">    user = UserInDB(**user_dict)</span><br><span class="line">    hashed_password = fake_hash_password(form_data.password)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hashed_password == user.hashed_password:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Incorrect username or password&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;access_token&quot;</span>: user.username, <span class="string">&quot;token_type&quot;</span>: <span class="string">&quot;bearer&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/me&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_users_me</span>(<span class="params"></span></span><br><span class="line"><span class="params">    current_user: Annotated[User, Depends(<span class="params">get_current_active_user</span>)],</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="keyword">return</span> current_user</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://fastapi.tiangolo.com/python-types&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;intro&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#intro&quot;&gt;&lt;/a&gt; Intro&lt;/h2</summary>
      
    
    
    
    
    <category term="python" scheme="https://revival-of-hope.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-21 python重学-源码剖析</title>
    <link href="https://revival-of-hope.github.io/2026/01/21/python%E9%87%8D%E5%AD%A6-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>https://revival-of-hope.github.io/2026/01/21/python%E9%87%8D%E5%AD%A6-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2026-01-21T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.533Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考书籍:(python源码剖析:深度探索动态语言核心技术),本书围绕的是06年的python2.5.0</strong></p><h2 id="概览includeobjecth"><a class="markdownIt-Anchor" href="#概览includeobjecth"></a> 概览(include/object.h)</h2><blockquote><p>我觉得python最明显的优点是自动内存管理,不需要进行垃圾收集,减少了写代码的各种烦恼</p></blockquote><h3 id="pyobject"><a class="markdownIt-Anchor" href="#pyobject"></a> pyobject</h3><blockquote><p>python中所有对象和类型都用pyobject指针类型来表示,可以通过将指针指向不同的内存区域来实现内存区域的扩张与收缩,这也是python之所以能够称为动态语言的本钱,其中pyobject定义如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA\</span></span><br><span class="line"><span class="meta">struct _object *_ob_next;\</span></span><br><span class="line"><span class="meta">struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD\</span></span><br><span class="line"><span class="meta">_PyObject_HEAD_EXTRA\</span></span><br><span class="line"><span class="meta">Py_ssize_t ob_refcnt;\</span></span><br><span class="line"><span class="meta">struct _typeobject *ob_type;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">PyObject_HEAD</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><ul><li>这里的Py_ssize_t实际上就是 long long,我就说世界是一个巨大的草台班子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">ssize_t</span>Py_ssize_t;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">typedef</span> __int64 <span class="type">ssize_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>而每次pyobject对象A被引用时,引用计数就增加1,当引用对象被删除时,引用计数就减小1,减小到零时就会从堆上被删除</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_INC_REFTOTAL_Py_RefTotal++</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Py_DEC_REFTOTAL_Py_RefTotal--</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) (\</span></span><br><span class="line"><span class="meta">_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA\</span></span><br><span class="line"><span class="meta">(op)-&gt;ob_refcnt++)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_VAR_HEAD\</span></span><br><span class="line"><span class="meta">PyObject_HEAD\</span></span><br><span class="line"><span class="meta">Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">PyObject_VAR_HEAD</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到python里还有一类PyVarObject,用来管理可变长度的容器对象</p></blockquote><p><img src="/images/archives/2026-01-21/PixPin_2026-01-21_11-23-40.webp" alt="alt text" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;参考书籍:(python源码剖析:深度探索动态语言核心技术),本书围绕的是06年的python2.5.0&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览includeobjecth&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概</summary>
      
    
    
    
    
    <category term="python" scheme="https://revival-of-hope.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-19 python重学-语法</title>
    <link href="https://revival-of-hope.github.io/2026/01/19/python%E9%87%8D%E5%AD%A6/"/>
    <id>https://revival-of-hope.github.io/2026/01/19/python%E9%87%8D%E5%AD%A6/</id>
    <published>2026-01-19T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><blockquote><p>所有变量都无需指明类型,统一作为一个可变指针对象,可以随时改变值和内存大小</p></blockquote><h3 id="顺序结构"><a class="markdownIt-Anchor" href="#顺序结构"></a> 顺序结构</h3><h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python list</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 / 修改</span></span><br><span class="line">x = a[<span class="number">0</span>]</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度</span></span><br><span class="line">n = <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加</span></span><br><span class="line">a.append(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line">a.insert(<span class="number">1</span>, <span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">a.pop()</span><br><span class="line">a.pop(<span class="number">1</span>)</span><br><span class="line">a.remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片 list[start:end:step]</span></span><br><span class="line">b = a[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">c = a[:<span class="number">3</span>]</span><br><span class="line">d = a[::<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找</span></span><br><span class="line">flag = <span class="number">3</span> <span class="keyword">in</span> a</span><br><span class="line">idx = a.index(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序 / 反转</span></span><br><span class="line">a.sort()</span><br><span class="line">a.reverse()</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ array + vector</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 / 修改</span></span><br><span class="line">    <span class="type">int</span> x = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">int</span> n_arr = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_arr; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : arr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 / 修改</span></span><br><span class="line">    <span class="type">int</span> y = v[<span class="number">0</span>];</span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">int</span> n_vec = v.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    v.<span class="built_in">pop_back</span>();</span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="type">bool</span> found = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>) != v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序 / 反转</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很显然两个语言都是T.method,function(T)这样混着用的,真的不好记啊<br />当然也可以解释说function是作为外部函数,并非单独一个数据结构的对象</p></blockquote><blockquote><p>看得出来python的index也是左闭右开的</p></blockquote><h4 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">tup2=(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">tup3=tup1+tup3</span><br></pre></td></tr></table></figure><blockquote><p>没什么好解释的,就是不可变的列表而已,相当于加了const,但是可以转换成list,元组之间也能连接</p></blockquote><h4 id="dict"><a class="markdownIt-Anchor" href="#dict"></a> dict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python dict（字典）示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line">d = &#123;<span class="string">&quot;apple&quot;</span>: <span class="number">3</span>, <span class="string">&quot;banana&quot;</span>: <span class="number">5</span>, <span class="string">&quot;cherry&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">d2 = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">x = d[<span class="string">&quot;apple&quot;</span>]      <span class="comment"># 3</span></span><br><span class="line">y = d.get(<span class="string">&quot;banana&quot;</span>) <span class="comment"># 5</span></span><br><span class="line">z = d.get(<span class="string">&quot;orange&quot;</span>, <span class="number">0</span>) <span class="comment"># 指定默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 / 添加</span></span><br><span class="line">d[<span class="string">&quot;apple&quot;</span>] = <span class="number">10</span></span><br><span class="line">d[<span class="string">&quot;orange&quot;</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;banana&quot;</span>]</span><br><span class="line">val = d.pop(<span class="string">&quot;cherry&quot;</span>)     <span class="comment"># 删除并返回值</span></span><br><span class="line">val2 = d.pop(<span class="string">&quot;pear&quot;</span>, <span class="number">0</span>)   <span class="comment"># 指定默认返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(key, d[key])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查键是否存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;apple&quot;</span> <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;exists&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有键 / 值 / 项</span></span><br><span class="line">keys = d.keys()</span><br><span class="line">values = d.values()</span><br><span class="line">items = d.items()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并字典</span></span><br><span class="line">d3 = &#123;**d, **d2&#125;  <span class="comment"># Python 3.5+ 支持</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 map</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 插入元素</span></span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">    m[<span class="string">&quot;banana&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="string">&quot;cherry&quot;</span>, <span class="number">2</span>&#125;);  <span class="comment">// 另一种插入方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 访问元素</span></span><br><span class="line">    <span class="type">int</span> x = m[<span class="string">&quot;apple&quot;</span>];      <span class="comment">// 如果 key 不存在，会自动创建默认值 0</span></span><br><span class="line">    <span class="type">int</span> y = m.<span class="built_in">at</span>(<span class="string">&quot;banana&quot;</span>);  <span class="comment">// 如果 key 不存在，会抛出 out_of_range 异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 修改元素</span></span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 删除元素</span></span><br><span class="line">    m.<span class="built_in">erase</span>(<span class="string">&quot;banana&quot;</span>);       <span class="comment">// 删除指定 key</span></span><br><span class="line">    <span class="comment">// m.clear();            // 删除所有元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 遍历 map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : m) &#123;</span><br><span class="line">        cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">&quot;cherry&quot;</span>);  <span class="comment">// 返回迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found cherry: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>dict 用hash table实现,故具有随机性,而map是用红黑树实现的,可以做到有序</p></blockquote><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python set（集合）示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建</span></span><br><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s2 = <span class="built_in">set</span>([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">s3 = <span class="built_in">set</span>()  <span class="comment"># 空集合，不能写 &#123;&#125;，会被当作 dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加元素</span></span><br><span class="line">s.add(<span class="number">6</span>)</span><br><span class="line">s.update([<span class="number">7</span>, <span class="number">8</span>])  <span class="comment"># 批量添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除元素</span></span><br><span class="line">s.remove(<span class="number">2</span>)   <span class="comment"># key 不存在会报 KeyError</span></span><br><span class="line">s.discard(<span class="number">10</span>) <span class="comment"># key 不存在也不会报错</span></span><br><span class="line">val = s.pop() <span class="comment"># 随机删除一个元素并返回</span></span><br><span class="line">s.clear()     <span class="comment"># 删除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 遍历</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 集合运算</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">union_set = a | b       <span class="comment"># 并集</span></span><br><span class="line">intersection_set = a &amp; b <span class="comment"># 交集</span></span><br><span class="line">diff_set = a - b         <span class="comment"># 差集</span></span><br><span class="line">symmetric_diff = a ^ b   <span class="comment"># 对称差集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 判断成员</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;exists&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not exists&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::set：有序集合</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">6</span>);       <span class="comment">// 添加元素</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">2</span>);        <span class="comment">// 删除元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : s)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出有序: 1 3 4 5 6</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unordered_set：无序集合</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; us = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    us.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">    us.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : us)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出顺序不定</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="number">3</span>) != s.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3 exists in set&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只是比dict和map少了一个值的存储,因此数据结构仍然不变</p></blockquote><h3 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h3><h4 id="选择语句"><a class="markdownIt-Anchor" href="#选择语句"></a> 选择语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    y = <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = -<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>看得出来<code>else if</code>还是太长了,而<code>switch case</code>大多数时候是真的没有用</p></blockquote><h4 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历容器</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># break / continue</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="函数与模块"><a class="markdownIt-Anchor" href="#函数与模块"></a> 函数与模块</h3><ul><li>python函数不需要指定返回类型,return也是可选的</li><li>如果没写return或者return后没有东西,则返回None</li><li>其余的函数语法和cpp差不多</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printHello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">x = add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">y = add(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># math_utils.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="comment"># 1.py</span></span><br><span class="line"><span class="keyword">import</span> math_utils</span><br><span class="line"></span><br><span class="line">v = math_utils.square(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 2.py</span></span><br><span class="line"><span class="keyword">from</span> math_utils <span class="keyword">import</span> square</span><br><span class="line"></span><br><span class="line">result = square(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 3.py </span></span><br><span class="line"><span class="keyword">from</span> math_utils <span class="keyword">import</span> square  <span class="keyword">as</span> sq</span><br><span class="line">result=sq(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 4.py</span></span><br><span class="line"><span class="keyword">from</span> math_utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">result=square(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 5.py</span></span><br><span class="line"><span class="keyword">import</span> math_utils <span class="keyword">as</span> math</span><br><span class="line"></span><br><span class="line">v = math.square(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="oop"><a class="markdownIt-Anchor" href="#oop"></a> oop</h3><blockquote><p>最值得一提的特征就是python没有public,protected,private这样的限定符,而是通过下划线来区分,</p></blockquote><h4 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h4><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_class.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>._value = value  <span class="comment"># 私有成员（约定）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._value = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> my_class <span class="keyword">import</span> MyClass</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.get())   <span class="comment"># 10</span></span><br><span class="line">obj.<span class="built_in">set</span>(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.get())   <span class="comment"># 20</span></span><br></pre></td></tr></table></figure><ul><li>python不使用隐式的this指针,而是要显式写明self,调用的时候则可以忽略self</li><li>对象也和变量一样直接用’='赋值即可<br /><strong>cpp</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v);        <span class="comment">// 构造函数（类内声明）</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>();            <span class="comment">// 析构函数（类内声明）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 成员函数（类内声明）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~<span class="built_in">MyClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::set</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    obj.<span class="built_in">set</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>python做不到像cpp一样的类内声明和类外实现,只能用下面的例子所述直接添加方法和成员,但这样或许还方便一点,就不需要用到难用的cmake了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_class <span class="keyword">import</span> MyClass</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_double</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.x * <span class="number">2</span></span><br><span class="line">    MyClass.double = double</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4><blockquote><p>如果不指定__init__就只有一个默认为空的实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value  <span class="comment"># 初始化成员变量</span></span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.value)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><h4 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h4><blockquote><p>基本用不上,因为python内部就能实现垃圾回收</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;MyClass(<span class="subst">&#123;self.value&#125;</span>) 被销毁&quot;</span>)</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">del</span> obj  <span class="comment"># 手动删除会立即调用 __del__</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实例属性和类属性"><a class="markdownIt-Anchor" href="#实例属性和类属性"></a> 实例属性和类属性</h4><ul><li><strong>实例属性</strong>：每个对象独立，存储在实例字典中</li><li><strong>类属性</strong>：所有实例共享，存储在类字典中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_attr = <span class="number">0</span>  <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.instance_attr = value  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line">obj1 = MyClass(<span class="number">10</span>)</span><br><span class="line">obj2 = MyClass(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1.instance_attr)  <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(obj2.instance_attr)  <span class="comment"># 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1.class_attr)     <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(obj2.class_attr)     <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">MyClass.class_attr = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(obj1.class_attr)     <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(obj2.class_attr)     <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h4 id="私有成员和公有成员"><a class="markdownIt-Anchor" href="#私有成员和公有成员"></a> 私有成员和公有成员</h4><ul><li><p>Python 没有真正的私有成员，使用约定 _name 或双下划线 __name</p></li><li><p>公有成员无前导下划线，直接访问</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.public = <span class="number">1</span>        <span class="comment"># 公有</span></span><br><span class="line">        <span class="variable language_">self</span>._protected = <span class="number">2</span>    <span class="comment"># 受保护（约定）</span></span><br><span class="line">        <span class="variable language_">self</span>.__private = <span class="number">3</span>     <span class="comment"># 私有（name mangling）</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line"><span class="built_in">print</span>(obj.public)       <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(obj._protected)   <span class="comment"># 2</span></span><br><span class="line"><span class="comment"># print(obj.__private)  # ❌ 报错</span></span><br><span class="line"><span class="built_in">print</span>(obj._MyClass__private)  <span class="comment"># 3，通过 name mangling 访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="公有私有静态方法"><a class="markdownIt-Anchor" href="#公有私有静态方法"></a> 公有,私有,静态方法</h4><ul><li><strong>公有方法</strong>：默认，无下划线，任何地方可调用</li><li><strong>私有方法</strong>：双下划线 <code>__name</code>，name mangling，限制外部访问</li><li><strong>静态方法</strong>：<code>@staticmethod</code>，不接收 <code>self</code> 或 <code>cls</code>，独立于实例和类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">public_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;公有方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;私有方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">obj = MyClass()</span><br><span class="line">obj.public_method()          <span class="comment"># 公有方法</span></span><br><span class="line"><span class="comment"># obj.__private_method()     # ❌ 报错</span></span><br><span class="line">obj._MyClass__private_method()  <span class="comment"># 私有方法，通过 name mangling 访问</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.static_method(<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 静态方法，直接通过类调用</span></span><br></pre></td></tr></table></figure><h4 id="类的继承"><a class="markdownIt-Anchor" href="#类的继承"></a> 类的继承</h4><ul><li>私有成员和私有方法不会被继承,需要这样调用<code>self._Parent__private_method()</code></li><li>构造函数默认不继承,需要重写,但可以调用基类的构造函数</li><li>不过构造函数的前导双下划线说明了他是私有成员不可被继承,也可以说是设计的一个巧思</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal speaks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Dog barks&quot;</span>)  <span class="comment"># 重写方法</span></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">dog.speak()  <span class="comment"># Dog barks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Walker</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Walking&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperDog</span>(Dog, Walker):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sd = SuperDog()</span><br><span class="line">sd.speak()  <span class="comment"># Dog barks</span></span><br><span class="line">sd.walk()   <span class="comment"># Walking</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h4><ul><li>多态：<strong>同一接口，不同对象，表现出不同行为</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal speaks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Dog barks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cat meows&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.speak()   <span class="comment"># 只要求对象“有 speak 方法”</span></span><br><span class="line"></span><br><span class="line">make_sound(Dog())  <span class="comment"># Dog barks</span></span><br><span class="line">make_sound(Cat())  <span class="comment"># Cat meows</span></span><br></pre></td></tr></table></figure><blockquote><p>也就是说同一个方法可以直接由子类继承并完成不同的实现,而cpp里必须得先写明该方法是virtual,子类中要写明override,相比起来麻烦了不少</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 多态（基于继承 + 虚函数）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;          <span class="comment">// 必须是 virtual</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speaks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125;             <span class="comment">// 多态基类必须有虚析构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat meows&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_sound</span><span class="params">(Animal* a)</span> </span>&#123;          <span class="comment">// 基类指针</span></span><br><span class="line">    a-&gt;<span class="built_in">speak</span>();                       <span class="comment">// 运行时多态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    Cat c;</span><br><span class="line">    <span class="built_in">make_sound</span>(&amp;d);</span><br><span class="line">    <span class="built_in">make_sound</span>(&amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="python工程详解"><a class="markdownIt-Anchor" href="#python工程详解"></a> python工程详解</h2><blockquote><p>所谓工程,其实我指的是本地各层级文件夹和文件之间python文件的相互导入而已</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> same_source_file <span class="keyword">import</span> test</span><br><span class="line"><span class="comment"># 导入同级文件,不属于一个包,是单独的脚本</span></span><br><span class="line"><span class="keyword">from</span> .same_source_file <span class="keyword">import</span> test</span><br><span class="line"><span class="comment"># 导入同级文件,前提是当前文件属于一个包,也就是说跟__init__.py在一起</span></span><br><span class="line"><span class="keyword">from</span> same_source_dir <span class="keyword">import</span> test</span><br><span class="line"><span class="comment"># 这是将同级文件夹作为包导入</span></span><br><span class="line"><span class="keyword">from</span> same_source_dir <span class="keyword">import</span> inner_file </span><br><span class="line"><span class="comment"># 这是将同级文件夹中的特定文件导入</span></span><br><span class="line"><span class="keyword">from</span> same_source_dir.inner_file  <span class="keyword">import</span> test</span><br><span class="line"><span class="comment"># 这是将同级文件夹中的特定文件中的某个方法导入</span></span><br></pre></td></tr></table></figure><h3 id="模块的导入"><a class="markdownIt-Anchor" href="#模块的导入"></a> 模块的导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line">app = FastAPI()</span><br><span class="line"><span class="comment">#2.py</span></span><br><span class="line"><span class="keyword">import</span> fastapi</span><br><span class="line">app=fastapi.FastAPI()</span><br><span class="line"><span class="comment">#3.py</span></span><br><span class="line"><span class="keyword">import</span> fastapi <span class="keyword">as</span> fa</span><br><span class="line">app=fa.FastAPI()</span><br><span class="line"><span class="comment">#4.py</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI <span class="keyword">as</span> fa</span><br><span class="line">app =fa()</span><br></pre></td></tr></table></figure><blockquote><p>看得出来各个写法各有各的好处,得看对应的工程文件的大小和规模因地制宜</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;语法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#语法&quot;&gt;&lt;/a&gt; 语法&lt;/h2&gt;
&lt;h3 id=&quot;变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#变量&quot;&gt;&lt;/a&gt; 变量&lt;/h3&gt;
&lt;blockquot</summary>
      
    
    
    
    
    <category term="python" scheme="https://revival-of-hope.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-18 astro尝试</title>
    <link href="https://revival-of-hope.github.io/2026/01/18/archives-2026-01-18-astro%E5%B0%9D%E8%AF%95/"/>
    <id>https://revival-of-hope.github.io/2026/01/18/archives-2026-01-18-astro%E5%B0%9D%E8%AF%95/</id>
    <published>2026-01-18T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.534Z</updated>
    
    <content type="html"><![CDATA[<p>本来觉得hexo的图片管理太麻烦了,部署速度又比较慢,做不到动态同步,就想着换其他的博客框架试试,经过多方搜寻敲定了astro来尝鲜,下面是没有模板时的效果<br /><img src="/images/archives/2026-01-18/PixPin_2026-01-18_14-15-02.webp" alt="alt text" /></p><blockquote><p>看着还不错,之后再改改就是个还不错的博客框架了,但问题就是所有组件都要我一个个自己写,没有前端基础的话光靠AI做不出太好的效果,而当我一点点添加组件的时候部署速度就飞速下降了</p></blockquote><p><img src="/images/archives/2026-01-18/PixPin_2026-01-18_14-18-42.webp" alt="alt text" /></p><p><img src="/images/archives/2026-01-18/PixPin_2026-01-18_14-19-29.webp" alt="alt text" /></p><p><img src="/images/archives/2026-01-18/PixPin_2026-01-18_14-20-28.webp" alt="alt text" /></p><blockquote><p>尽管相比起来的话astro还是快了不少,但我一想到之后再加入图片管理功能和访客统计,评论系统,加载动画这些东西之后那臃肿的package库,就觉得不太可能会有多快,所以决定及时止损,虽然hexo跑的不够快,但也是一辆历久弥新的自行车!</p></blockquote><ul><li>而且不用我自己写组件</li></ul><blockquote><p>准备再试试hugo,如果真的有质的飞跃,再考虑换过去</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来觉得hexo的图片管理太麻烦了,部署速度又比较慢,做不到动态同步,就想着换其他的博客框架试试,经过多方搜寻敲定了astro来尝鲜,下面是没有模板时的效果&lt;br /&gt;
&lt;img src=&quot;/images/archives/2026-01-18/PixPin_2026-01</summary>
      
    
    
    
    
    <category term="前端" scheme="https://revival-of-hope.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-15 计算机组成原理复习</title>
    <link href="https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</id>
    <published>2026-01-15T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="考试事项"><a class="markdownIt-Anchor" href="#考试事项"></a> 考试事项</h2><p>考试分数占比60%<br />填空15分 一空一分<br />选择20分 20道题<br />综合题65分 七道大题,基本一个章节一道题</p><h2 id="重要的杂项"><a class="markdownIt-Anchor" href="#重要的杂项"></a> 重要的杂项</h2><h3 id="片选信号"><a class="markdownIt-Anchor" href="#片选信号"></a> 片选信号</h3><p>CS(chip select): 片选信号,低电平有效,通过地址逻辑生成,故在原理图中一般都在上面加一横来表示</p><h3 id="译码器"><a class="markdownIt-Anchor" href="#译码器"></a> 译码器</h3><p>译码器(decoder)是一种具有“翻译”功能的多输入多输出的组合逻辑电路器件。<br />译码器的功能：将每一组编码序列信号转换为一个特定的输出信号<br />译码器的输入：一组编码序列信号<br />译码器的输出：一条特定的译码信号（与每组输入信号对应）<br />译码器的工作原理：当某组编码进入输入端时，相应的译码线输出为低电平，与此同时，其他所有译码线输出保持为高电平。<br />通常，译码器的输出端与输入端的数量关系为（2^n）</p><h2 id="第一章-概论"><a class="markdownIt-Anchor" href="#第一章-概论"></a> 第一章 概论</h2><h3 id="计算机5个部件的示意图"><a class="markdownIt-Anchor" href="#计算机5个部件的示意图"></a> 计算机5个部件的示意图</h3><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_09-42-23.webp" alt="alt text" /></p><blockquote><p>由于运算器(ALU)与控制器都集成在cpu上,因此可以写成下图形式</p></blockquote><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_09-44-09.webp" alt="alt text" /><br />而早期的冯诺伊曼结构是这样的<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_09-47-07.webp" alt="alt text" /></p><h3 id="各部件详解"><a class="markdownIt-Anchor" href="#各部件详解"></a> 各部件详解</h3><blockquote><p>运算器: 算术逻辑单元,用于完成算术运算和逻辑运算<br />控制器: 计算机的管理机构和指挥中心,协调计算机各部件自动工作<br />存储器: 计算机的存储部件,用于存储程序和数据,由内存和外存两部分构成<br />内存: 由大量存储单元组成,构成一个按地址访问的一维线性空间,也称为主存<br />输入设备: 将程序和数据以计算机能识别的形式输入到计算机内<br />输出设备: 将计算机处理的结果以人们能接受或其他系统所要求的形式输出到外部世界<br />操作系统: 最主要的系统软件,负责管理系统资源,为应用程序提供运行环境,为用户提供操作界面</p></blockquote><hr /><p>其中,控制器由以下6部分构成:</p><ol><li>指令寄存器(IR): 用于存放当前正在执行的指令</li><li>程序计数器(PC): 用于存放当前正在执行的指令的地址</li><li>指令译码器: 对指令进行译码,形成相应的控制信号</li><li>时钟脉冲(CP): 协调计算机各部件的同步主时钟,工作频率称为计算机的<strong>主频</strong></li><li>时序信号发生器: 按时间顺序发出节拍信号</li><li>微操作控制部件: 根据时序信号发生器的节拍信号和指令译码器的译码结果产生微操作控制信号给各个计算机部件</li></ol><blockquote><p>而运算部件由运算器和通用寄存器组构成,寄存器组用于暂存运算数据和中间结果<br />内存则由存储体,地址寄存器AR,数据寄存器DR三部分构成</p></blockquote><h3 id="计算机的性能指标"><a class="markdownIt-Anchor" href="#计算机的性能指标"></a> 计算机的性能指标</h3><ol><li>主频: 衡量计算机工作速度的主要指标之一</li><li>运算速度: 以每秒执行多少条指令或完成多少次浮点运算来表示</li><li>基本字长: 直接参与运算的数据的二进制位数,标志着运算精度,位数越多,精度越高</li><li>主存容量: 主存能储存信息的总量</li><li>主存存取周期: 对主存连续两次访问的最小时间间隔</li><li>外部设备的配置</li></ol><blockquote><p>其中运算速度由两种计量单位,分别是</p></blockquote><ol><li>MIPS:百万条指令/秒(million instructions per second)</li><li>MFLOPS:百万次浮点运算/秒(million flops per second)</li></ol><h2 id="第二章-数的表示作为第十章的基础"><a class="markdownIt-Anchor" href="#第二章-数的表示作为第十章的基础"></a> 第二章 数的表示（作为第十章的基础）</h2><blockquote><p><strong>机器数</strong>：用二进制编码表示的数据<br />在计算机中，常用 <strong>原码、补码、反码</strong> 三种方法来表示带符号的机器数</p></blockquote><hr /><ul><li>下面的.表示拼接</li></ul><h3 id="原码表示法"><a class="markdownIt-Anchor" href="#原码表示法"></a> 原码表示法</h3><p><strong>定义</strong><br />原码由 <strong>符号位 + 数值位</strong> 组成</p><ul><li>符号位 s：0 表示正，1 表示负</li><li>数值位表示绝对值的二进制</li></ul><p><strong>表示公式</strong></p><ul><li><p>正数</p><ul><li>原码 = 0 · |x|₂</li></ul></li><li><p>负数</p><ul><li>原码 = 1 · |x|₂</li></ul></li></ul><ul><li><strong>简单说就是负数前面加个1</strong></li></ul><blockquote><p>举例:<br />[-0.1101]_原=1.1101<br />[-1101]_原=11101</p></blockquote><p><strong>特点</strong></p><ul><li>表示直观</li><li>存在 +0 与 −0</li><li>加减运算用根据符号来判断,但符号位不参与运算</li></ul><hr /><h3 id="反码表示法"><a class="markdownIt-Anchor" href="#反码表示法"></a> 反码表示法</h3><p><strong>定义</strong><br />补码的中间过程<br /><strong>表示公式</strong></p><ul><li><p>正数</p><ul><li>反码 = 原码 = 0 · |x|₂</li></ul></li><li><p>负数</p><ul><li>反码 = 符号位不变，数值位逐位取反</li></ul></li></ul><p><strong>特点</strong></p><ul><li>存在 +0 与 −0</li><li>运算仍不方便</li></ul><h3 id="补码表示法"><a class="markdownIt-Anchor" href="#补码表示法"></a> 补码表示法</h3><p><strong>定义</strong><br />补码是计算机中实际采用的带符号数表示方法</p><p><strong>表示公式</strong></p><ul><li><p>正数</p><ul><li>补码 = 原码 = 0 · |x|₂</li></ul></li><li><p>负数</p><ul><li>补码 = 原码数值位逐位取反 + 1</li></ul></li></ul><p><strong>补充说明</strong></p><ul><li>小数补码中，“加 1”是对最低有效位加 1</li><li>若产生进位，直接舍去最高进位</li></ul><p><strong>特点</strong></p><ul><li>只有一个 0</li><li>加减法统一为加法</li><li>硬件实现简单</li></ul><h4 id="深入理解"><a class="markdownIt-Anchor" href="#深入理解"></a> 深入理解</h4><blockquote><p>一个数减去小于模的另一个数,可以用加上模与另一个数的绝对值之差来代替</p></blockquote><blockquote><p>实际上负数的补码是用2的(n+1)次方加上该负数得到的,若负数x有n位,则补码相当于(11…11)n +1 +x,这也就是负数补码之所以要对所有位取反再加一的真相</p></blockquote><ul><li>当最高位即符号位有进位时实际上相当于加上了一个2的(n+1)次方,对结果取模时可以舍去</li></ul><hr /><h3 id="移码表示法"><a class="markdownIt-Anchor" href="#移码表示法"></a> 移码表示法</h3><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_13-32-56.webp" alt="alt text" /></p><blockquote><p>无论正负均用一个式子表示</p></blockquote><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_13-35-46.webp" alt="alt text" /></p><h3 id="数的浮点表示"><a class="markdownIt-Anchor" href="#数的浮点表示"></a> 数的浮点表示</h3><blockquote><p>浮点是指小数点的位置不固定,随时浮动</p></blockquote><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_13-57-51.webp" alt="alt text" /></p><p>[<br />X = M \times 2^{E}<br />]</p><blockquote><p>其中：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>：阶码，用定点整数表示,采用移码<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>：尾数，用定点小数表示</p></blockquote><h4 id="规格化浮点数"><a class="markdownIt-Anchor" href="#规格化浮点数"></a> 规格化浮点数</h4><p>当浮点数的基数为 2 时，如果其尾数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 满足：<br />[<br />\frac{1}{2} \le |M| &lt; 1<br />]<br />则称该浮点数为规格化浮点数</p><ul><li>很好理解,如果尾数小于1/2,说明有前导0,那么就可以将阶码减小1来消去0</li></ul><h4 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h4><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_14-02-32.webp" alt="alt text" /></p><blockquote><p>步骤如下:</p></blockquote><ol><li>先将十进制数化成尾数乘以阶码的形式,</li><li>而在实际存储中,将阶码用移码表示,也就是加上2的4次方,从而保证都是正数</li><li>再把尾数用补码的形式表示出来,符号位放到最前面的数符位置,数值位放在最后面</li></ol><h2 id="第六章-计算机执行程序的过程"><a class="markdownIt-Anchor" href="#第六章-计算机执行程序的过程"></a> 第六章 计算机执行程序的过程</h2><h3 id="指令说明"><a class="markdownIt-Anchor" href="#指令说明"></a> 指令说明</h3><h4 id="load-指令装载寄存器指令"><a class="markdownIt-Anchor" href="#load-指令装载寄存器指令"></a> Load 指令（装载寄存器指令）</h4><ul><li>功能：把一个数据送入指定的寄存器</li><li>数据来源：<ul><li>立即数</li><li>存储器中的某个单元</li></ul></li></ul><hr /><h4 id="store-指令存储指令"><a class="markdownIt-Anchor" href="#store-指令存储指令"></a> Store 指令（存储指令）</h4><ul><li>功能：把指定寄存器中的数据存入存储器的某个单元</li></ul><hr /><h4 id="add-指令加法指令"><a class="markdownIt-Anchor" href="#add-指令加法指令"></a> Add 指令（加法指令）</h4><ul><li>功能：将两个寄存器中的数据相加,把运算结果存入指定寄存器</li></ul><hr /><h4 id="jump-指令跳转指令"><a class="markdownIt-Anchor" href="#jump-指令跳转指令"></a> Jump 指令（跳转指令）</h4><ul><li>功能：跳转到新的地址继续执行指令</li></ul><hr /><h3 id="记号说明"><a class="markdownIt-Anchor" href="#记号说明"></a> 记号说明</h3><ul><li><code>[Rx]</code>：寄存器 Rx 中的内容</li><li><code>MEM[y]</code>：存储器中地址为 y 的存储单元内容</li><li><code>→</code>：传送（数据流向）</li></ul><h3 id="指令示例说明"><a class="markdownIt-Anchor" href="#指令示例说明"></a> 指令示例说明</h3><h4 id="第-1-条"><a class="markdownIt-Anchor" href="#第-1-条"></a> 第 1 条</h4><p><strong>Load R1，200(R0)</strong><br />MEM[[R0] + 200] → R1<br />以 R0 为基址，加偏移量 200，将对应存储单元内容送入 R1</p><h4 id="第-2-条"><a class="markdownIt-Anchor" href="#第-2-条"></a> 第 2 条</h4><p><strong>Load R2，#4</strong><br />4 → R2<br />4 直接包含在指令中，称为<strong>立即数</strong></p><h4 id="第-3-条"><a class="markdownIt-Anchor" href="#第-3-条"></a> 第 3 条</h4><p><strong>Add R3，R1，R2</strong><br />[R1] + [R2] → R3<br />将 R1 与 R2 中的数据相加，结果送入 R3</p><h4 id="第-4-条"><a class="markdownIt-Anchor" href="#第-4-条"></a> 第 4 条</h4><p><strong>Store R3，200(R2)</strong><br />[R3] → MEM[[R2] + 200]<br />以 R2 为基址，加偏移量 200，将 R3 的内容存入存储器</p><h4 id="第-5-条"><a class="markdownIt-Anchor" href="#第-5-条"></a> 第 5 条</h4><p><strong>Store R2，@(208)</strong><br />[R2] → MEM[ MEM[208] ]<br />@ 表示间接寻址，208 中的内容作为有效地址</p><h4 id="第-6-条"><a class="markdownIt-Anchor" href="#第-6-条"></a> 第 6 条</h4><p><strong>Jump 1000</strong><br />1000 → PC<br />将程序计数器 PC 置为 1000，跳转执行</p><hr /><ul><li>指令后面跟着的第一个数就是指令操作的结果存储对象,再后面才是这个操作需要的数据</li><li>注意到这里的R1,R2,R3都是寄存器(register)</li></ul><h3 id="第一条指令load-r1200r0详解"><a class="markdownIt-Anchor" href="#第一条指令load-r1200r0详解"></a> 第一条指令**Load R1，200(R0)**详解</h3><p><strong>第一步</strong></p><ol><li>[PC]-&gt;AR,将pc存放的当前指令地址传入地址寄存器AR</li><li>从存储体读出对应地址的指令放入数据寄存器DR</li><li>将DR送入指令寄存器IR</li></ol><p><strong>第二步</strong><br />指令译码器进行译码,结合CP和时序信号发生器产生的节拍信号,产生微操作控制信号</p><p><strong>第三步</strong></p><ol><li>计算访问地址:[R0]+200-&gt;AR<ol><li>[R0]-&gt;ALU,把寄存器R0中的内容送入ALU</li><li>IR中的操作数200送入ALU</li><li>[ALU]-&gt;AR,ALU进行加法运算,把结果传给AR</li></ol></li><li>从存储器读出数据,送入寄存器R1<ol><li>从存储器中地址200的存储单元读出数据,送入DR</li><li>DR-&gt;R1,将DR中的数据送入R1</li></ol></li></ol><p><strong>第四步</strong><br />PC+4,指向下一条指令</p><ul><li>显然所有指令的第1步(取指令),第2步(指令译码),第4步(PC+4)都是一样的,只是第三步的执行指令有区别</li></ul><hr /><h2 id="第七章-指令系统"><a class="markdownIt-Anchor" href="#第七章-指令系统"></a> 第七章 指令系统</h2><h3 id="指令格式"><a class="markdownIt-Anchor" href="#指令格式"></a> 指令格式</h3><blockquote><p>一条指令必须包含以下三条信息</p></blockquote><ol><li>要执行的操作</li><li>操作的对象</li><li>操作的结果(操作结果要保存到哪里)</li></ol><ul><li>操作数:操作码操作的对象数据<br /><strong>指令的基本格式</strong><br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-17-33.webp" alt="alt text" /></li></ul><h3 id="指令的地址码"><a class="markdownIt-Anchor" href="#指令的地址码"></a> 指令的地址码</h3><p>地址码中的地址可以为0,1个或多个,根据指令中地址码中的地址数量可以分为以下5种指令</p><h4 id="零地址指令"><a class="markdownIt-Anchor" href="#零地址指令"></a> 零地址指令</h4><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-21-33.webp" alt="alt text" /></p><blockquote><p>通常在两种情况下可能采用零地址指令</p></blockquote><ol><li>指令本身不需要任何操作数</li><li>指令中所需的操作数是隐含指定的</li></ol><h4 id="一地址指令"><a class="markdownIt-Anchor" href="#一地址指令"></a> 一地址指令</h4><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-21-59.webp" alt="alt text" /></p><blockquote><p>在两种情况下可能采用一地址指令</p></blockquote><ol><li>指令本身只需要一个操作数,如加1,求补等<ul><li>A &lt;- OP[A]</li></ul></li><li>指令操作需要两个操作数，指令中指明一个操作数，而另外一个操作数在默认的某个地方<ul><li>如 ：累加器AC中，操作结果存放到累加器AC中</li><li>AC &lt;- [AC] OP [A]</li></ul></li></ol><h4 id="二地址指令"><a class="markdownIt-Anchor" href="#二地址指令"></a> 二地址指令</h4><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-26-04.webp" alt="alt text" /></p><ul><li>A1 &lt;- [A1] OP [A2]</li></ul><blockquote><p>根据存放操作数的位置不同，分为3种。</p></blockquote><ol><li>寄存器-寄存器型（R-R型）指令</li><li>存储器-存储器型（M-M型）指令</li><li>寄存器-存储器型（R-M型）指令</li></ol><ul><li>显然其中一个是用来存放操作结果地址的</li></ul><h4 id="三地址指令和多地址指令"><a class="markdownIt-Anchor" href="#三地址指令和多地址指令"></a> 三地址指令和多地址指令</h4><blockquote><p>三地址指令被广泛采用,特别是在RISC计算机中</p></blockquote><blockquote><p>多地址指令用于描述一批数据，指令中需要多个地址来指出数据存放的首地址、长度和下标等信息</p></blockquote><h3 id="指令的操作码"><a class="markdownIt-Anchor" href="#指令的操作码"></a> 指令的操作码</h3><blockquote><p>指令系统中的每一条指令都有唯一确定的操作码，不同指令的操作码是不相同的。<br />操作码的长度决定了指令系统的最大规模。<br />若操作码的位数为 n 位，则该指令系统最多能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 条指令</p></blockquote><hr /><h4 id="固定长度操作码"><a class="markdownIt-Anchor" href="#固定长度操作码"></a> 固定长度操作码</h4><blockquote><p>所有指令操作码的长度都是固定的，且集中放在指令的一个字段内。<br />有利于简化硬件设计，减少指令译码时间。<br />很多现代计算机都采用了固定长度操作码。</p></blockquote><hr /><h4 id="可变长度操作码"><a class="markdownIt-Anchor" href="#可变长度操作码"></a> 可变长度操作码</h4><p>指令系统中操作码的长度有多种，不同指令的操作码长度不完全相同。</p><ul><li>使用频率高的指令使用短的操作码</li><li>使用频率低的指令使用较长的操作码</li></ul><p>可以缩短操作码的平均长度，但会使硬件设计复杂化，增加指令译码的时间和难度。</p><hr /><h4 id="扩展操作码"><a class="markdownIt-Anchor" href="#扩展操作码"></a> 扩展操作码</h4><p>将操作码设计为几种不同的固定长度，且相互之间按某种规则进行扩展。</p><p><strong>优点</strong></p><ul><li>可以简化硬件设计；</li><li>当指令总长度一定时，可以使操作码的长度随地址数的增加而减少，<br />不同地址数的指令的操作码长度也不同，从而有效缩短指令总长度。</li></ul><p><strong>扩展操作码的方法</strong></p><ul><li>等长扩展</li><li>不等长扩展</li></ul><p><strong>扩展示例</strong><br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-41-26.webp" alt="alt text" /></p><h3 id="指令长度"><a class="markdownIt-Anchor" href="#指令长度"></a> 指令长度</h3><p><strong>指令长度</strong>：指一条指令所包含的二进制代码的总位数。</p><p>指令长度主要取决于以下因素：</p><ul><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数地址的个数</li></ul><p>指令长度通常与机器字长存在简单的倍数关系。</p><hr /><h4 id="按与机器字长的关系分类"><a class="markdownIt-Anchor" href="#按与机器字长的关系分类"></a> 按与机器字长的关系分类</h4><ul><li><p><strong>单字长指令</strong><br />指令长度等于机器字长的指令</p></li><li><p><strong>半字长指令</strong><br />指令长度等于半个机器字长的指令</p></li><li><p><strong>双字长指令</strong><br />指令长度等于机器字长两倍的指令</p></li></ul><hr /><ul><li>指令长度一般应是<strong>字节的整数倍</strong></li></ul><h3 id="寻址方式"><a class="markdownIt-Anchor" href="#寻址方式"></a> 寻址方式</h3><blockquote><p>指令的地址码给出的地址不一定是操作数的真正地址,而是形式地址,确定操作数有效地址的方法就叫寻址方式</p></blockquote><h4 id="直接寻址"><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h4><blockquote><p>在指令的地址码字段直接给出操作数所在主存单元的地址。</p></blockquote><ul><li>简单、快速的寻址方式，但寻址范围受限于地址码字段的位数<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-49-37.webp" alt="alt text" /></li></ul><h4 id="间接寻址"><a class="markdownIt-Anchor" href="#间接寻址"></a> 间接寻址</h4><blockquote><p>指令的地址码字段给出的是操作数所在内存单元的地址的地址。</p></blockquote><ol><li>指令中形式地址所指定的内存单元中存放的内容才是操作数的真正地址。</li><li>得到操作数需要访问两次内存，指令的执行速度比较慢</li></ol><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-54-10.webp" alt="alt text" /></p><h4 id="立即寻址"><a class="markdownIt-Anchor" href="#立即寻址"></a> 立即寻址</h4><ul><li>指令的地址码字段直接给出操作数本身，而不是操作数的地址。</li><li>指令执行速度最快，得到指令的同时就得到了操作数，不需要再访问内存。</li></ul><h4 id="寄存器直接寻址与寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器直接寻址与寄存器间接寻址"></a> 寄存器直接寻址与寄存器间接寻址</h4><blockquote><p>寄存器直接寻址：指令的地址码字段给出一个寄存器编号，该寄存器中存放的内容就是操作数。<br />寄存器间接寻址：寄存器中存放的内容是操作数的地址，根据此地址访问内存取得操作数。</p></blockquote><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-10-32.webp" alt="alt text" /></p><h4 id="隐含寻址"><a class="markdownIt-Anchor" href="#隐含寻址"></a> 隐含寻址</h4><blockquote><p>指令中不给出操作数的地址</p></blockquote><ul><li>操作数约定在某个特定的寄存器或堆栈中</li></ul><h4 id="pc相对寻址"><a class="markdownIt-Anchor" href="#pc相对寻址"></a> PC相对寻址</h4><blockquote><p>将程序计数器PC的内容与指令中给出的形式地址（偏移量）的值相加，形成操作数的有效地址</p></blockquote><ul><li>形式地址（偏移量）的值可正可负。</li><li>对于短跳转和程序的再定位很有用。<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-12-10.webp" alt="alt text" /></li></ul><h4 id="变址寻址"><a class="markdownIt-Anchor" href="#变址寻址"></a> 变址寻址</h4><blockquote><p>将指令中给出的形式地址的值与变址寄存器的内容相加，形成操作数的有效地址。</p></blockquote><ul><li>变址寄存器可以是专用寄存器，也可以是通用寄存器中的一个。</li><li>常用于字符串处理、数组运算等成批数据处理中，主要是面向用户，解决程序循环控制问题。</li><li>通常地址的变化体现在变址寄存器中，指令中的形式地址相对固定。<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-13-41.webp" alt="alt text" /></li></ul><h4 id="基址寻址"><a class="markdownIt-Anchor" href="#基址寻址"></a> 基址寻址</h4><blockquote><p>把指令中给出的形式地址的值与基址寄存器的内容相加，形成操作数的有效地址。</p></blockquote><blockquote><ul><li>基址寄存器的内容称为基地址。</li><li>主要用于将用户程序的逻辑地址转换成主存的实际地址。它面向系统，解决程序重定位和扩大寻址空间等问题。</li><li>通常地址变化体现形式地址上，基地址相对不变。</li></ul></blockquote><h4 id="基址变址寻址"><a class="markdownIt-Anchor" href="#基址变址寻址"></a> “基址+变址”寻址</h4><pre><code>     有效地址=（RB）+（RX）+D </code></pre><p>其中:</p><ul><li>（RB）：基址寄存器RB中的内容</li><li>（RX）：变址寄存器RX中的内容</li><li>D：指令字中给出的形式地址（偏移量）</li></ul><h3 id="指令按功能分类"><a class="markdownIt-Anchor" href="#指令按功能分类"></a> 指令按功能分类</h3><ol><li><blockquote><p><strong>数据传送类指令</strong><br />将数据从一个地方传送到另一个地方</p></blockquote></li></ol><ul><li>主要实现主存和主存之间、主存和寄存器之间、寄存器和寄存器之间的数据传送。</li><li>数据传送指令一次可以传送一个数据，也可以一次传送一批数据。</li></ul><ol start="2"><li><blockquote><p>数据运算类指令<br />用来实现数据的算术运算、逻辑运算和移位运算</p></blockquote></li></ol><ul><li>算术运算：加、减、乘、除运算；加1 、减1；比较指令等。</li><li>逻辑运算：包括与、或、非 、异或等运算。</li><li>移位指令：算术移位、逻辑移位和循环移位三类，它们又可分为左移和右移两种。</li></ul><ol start="3"><li><blockquote><p>程序控制类指令<br />主要用来控制程序执行的顺序和方向。</p></blockquote></li></ol><ul><li>包含转移指令、子程序调用和返回指令、自陷指令等</li></ul><ol start="4"><li><blockquote><p>输入输出指令</p></blockquote></li></ol><ul><li>简称I/O指令,主要用于实现主机与外部设备之间的信息交换</li></ul><h3 id="指令系统设计"><a class="markdownIt-Anchor" href="#指令系统设计"></a> 指令系统设计</h3><blockquote><p>指令系统的设计包括指令的功能设计,指令格式的设计两部分</p></blockquote><blockquote><p>在确定哪些基本功能用硬件来实现时，主要考虑3个因素：速度、成本、灵活性。</p></blockquote><ul><li>硬件实现的特点<ul><li>速度快、成本高、灵活性差</li></ul></li><li>软件实现的特点<ul><li>速度慢、价格便宜、灵活性好</li></ul></li></ul><h4 id="对指令系统的基本要求"><a class="markdownIt-Anchor" href="#对指令系统的基本要求"></a> 对指令系统的基本要求</h4><ol><li><blockquote><p>完整性：在一个有限可用的存储空间内，对于任何可解的问题，编制计算程序时，指令集所提供的指令足够用。</p></blockquote></li></ol><ul><li>要求指令集功能齐全、使用方便</li></ul><ol start="2"><li>规整性：主要包括对称性和均匀性。</li></ol><ul><li><blockquote><p>对称性：所有与指令集有关的存储单元的使用,操作码的设置等都是对称的。</p></blockquote><ul><li>例如：在存储单元的使用上，所有通用寄存器都要同等对待。在操作码的设置上，如果设置了A-B的指令，就应该也设置B-A的指令。</li></ul></li><li><blockquote><p>均匀性：指对于各种不同的操作数类型、字长、操作种类和数据存储单元，指令的设置都要同等对待。</p></blockquote><ul><li>例如：如果某机器有5种数据表示，4种字长，两种存储单元，则要设置5×4×2=40种同一操作的指令。</li></ul></li></ul><ol start="3"><li><blockquote><p>正交性：指在指令中各个不同含义的字段，如操作类型、数据类型、寻址方式字段等，在编码时应互不相关、相互独立。</p></blockquote></li><li><blockquote><p>高效率：指指令的执行速度快、使用频度高。</p></blockquote></li><li><blockquote><p>兼容性：主要是要实现向后兼容，指令系统可以增加新指令，但不能删除指令或更改指令的功能。</p></blockquote></li></ol><h4 id="指令格式的设计"><a class="markdownIt-Anchor" href="#指令格式的设计"></a> 指令格式的设计</h4><blockquote><p>3种常用的指令编码格式:可变长度编码格式、固定长度编码格式、混合型编码格式</p></blockquote><h5 id="可变长度编码格式"><a class="markdownIt-Anchor" href="#可变长度编码格式"></a> 可变长度编码格式</h5><blockquote><p>当指令系统包含多种寻址方式和操作类型时，这种编码方式可以有效减少指令系统的平均指令长度，降低目标代码的大小。</p></blockquote><ul><li>可能会使各条指令的字长和执行时间相差很大。</li><li>多数CISC指令系统均采用了这种编码格式。<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-52-58.webp" alt="alt text" /></li></ul><h5 id="固定长度编码格式"><a class="markdownIt-Anchor" href="#固定长度编码格式"></a> 固定长度编码格式</h5><blockquote><p>将操作类型和寻址方式一起编码到操作码中。</p></blockquote><ul><li>当寻址方式和操作类型非常少时,这种编码格式非常好,可以有效地降低译码的复杂度，提高译码的速度。</li><li>大部分RISC的指令系统均采用这种编码格式。</li></ul><p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-54-43.webp" alt="alt text" /></p><h5 id="混合型编码格式"><a class="markdownIt-Anchor" href="#混合型编码格式"></a> 混合型编码格式</h5><blockquote><p>提供若干种固定的指令字长,以期达到既能够减少目标代码长度又能降低译码复杂度的目标。<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-55-00.webp" alt="alt text" /></p></blockquote><h4 id="指令系统的两种设计策略"><a class="markdownIt-Anchor" href="#指令系统的两种设计策略"></a> 指令系统的两种设计策略</h4><h5 id="cisc复杂指令系统计算机"><a class="markdownIt-Anchor" href="#cisc复杂指令系统计算机"></a> CISC（复杂指令系统计算机）</h5><p>Complex Instruction Set Computer</p><ul><li>增强指令功能</li><li>将越来越多的功能交由硬件实现</li><li>指令数量不断增加</li><li>单条指令可完成较复杂的操作</li></ul><hr /><h5 id="risc精简指令系统计算机"><a class="markdownIt-Anchor" href="#risc精简指令系统计算机"></a> RISC（精简指令系统计算机）</h5><p>Reduced Instruction Set Computer</p><ul><li>尽可能简化指令系统</li><li>指令条数较少</li><li>指令功能相对简单</li><li>复杂功能由多条简单指令组合完成</li></ul><h5 id="为什么研发risc"><a class="markdownIt-Anchor" href="#为什么研发risc"></a> 为什么研发RISC</h5><blockquote><p>CISC的优点:指令数量多、功能多样<br />问题:</p></blockquote><ol><li><p>各种指令的使用频度相差悬殊，许多指令很少用</p><ul><li>据统计：只有20％的指令使用频度比较高，占运<br />行时间的80％。而其余80％的指令只在20％的运行时<br />间内才会用到。</li></ul></li><li><p>指令系统庞大，指令条数很多，许多指令的功能又很复杂，使得控制器硬件非常复杂。</p><ul><li>占用了大量的芯片面积</li><li>增加了研制时间和成本，容易造成设计错误。</li></ul></li><li><p>许多指令由于操作繁杂，其CPI值比较大，执行速度慢。采用这些复杂指令有可能使整个程序的执行时间反而增加。</p></li><li><p>由于指令功能复杂，规整性不好，不利于采用流<br />水技术来提高性能。</p></li></ol><blockquote><p>设计RISC机器遵循的原则</p></blockquote><ol><li>指令条数少、指令功能简单。只选取使用频度很高的指令，在此基础上补充一些最有用的指令</li><li>采用简单而又统一的指令格式，并减少寻址方式；指令字长都为32位或64位</li><li>指令的执行在单个机器周期内完成</li><li>采用load-store结构:只有load和store指令才能访问存储器,其它指令的操作都是在寄存器之间进行</li><li>大多数指令都采用硬连逻辑来实现</li><li>强调优化编译器的作用,为高级语言程序生成优化的代码</li><li>充分利用流水技术来提高性能</li></ol><h3 id="典型risc实例mips"><a class="markdownIt-Anchor" href="#典型risc实例mips"></a> 典型RISC实例:MIPS</h3><h4 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h4><ul><li>32个64位通用寄存器,其中R0的值永远是0(GPRs)</li><li>32个64位浮点数寄存器(FPRs)</li><li>一些特殊寄存器</li></ul><h4 id="数据表示"><a class="markdownIt-Anchor" href="#数据表示"></a> 数据表示</h4><ul><li>整数:字节（8位）;半字（16位）;字（32位）; 双字（64位）</li><li>浮点数:单精度浮点数（32位）  双精度浮点数（64位）</li></ul><blockquote><p>字节、半字或者字在装入64位寄存器时，用零扩展或者用符号位扩展来填充该寄存器的剩余部分。装入以后，对它们将按照64位整数的方式进行运算。</p></blockquote><h4 id="数据寻址方式"><a class="markdownIt-Anchor" href="#数据寻址方式"></a> 数据寻址方式</h4><p>只有立即数寻址与偏移量寻址两种</p><h4 id="指令格式-2"><a class="markdownIt-Anchor" href="#指令格式-2"></a> 指令格式</h4><blockquote><p>只有三种指令格式,都是32位,其中操作码占6位</p></blockquote><h5 id="i-类指令immediate"><a class="markdownIt-Anchor" href="#i-类指令immediate"></a> I 类指令（Immediate）</h5><p><strong>包含类型</strong></p><ul><li>Load / Store 指令</li><li>立即数指令</li><li>分支指令</li><li>寄存器跳转指令</li><li>寄存器链接跳转指令</li></ul><p><strong>特点</strong></p><ul><li>立即数字段长度：16 位</li><li>用途：提供立即数或地址偏移量</li></ul><p><strong>指令语义</strong></p><ul><li><p><strong>Load 指令</strong></p><ul><li>有效地址：<code>Regs[rs] + immediate</code></li><li>从存储器读取数据，写入寄存器 <code>rt</code></li></ul></li><li><p><strong>Store 指令</strong></p><ul><li>有效地址：<code>Regs[rs] + immediate</code></li><li>将寄存器 <code>rt</code> 中的数据写入存储器</li></ul></li><li><p><strong>立即数指令</strong></p><ul><li><code>Regs[rt] ← Regs[rs] op immediate</code></li></ul></li><li><p><strong>分支指令</strong></p><ul><li>转移目标地址：<code>Regs[rs] + immediate</code></li><li>寄存器 <code>rt</code> 不使用</li></ul></li><li><p><strong>寄存器跳转并链接</strong></p><ul><li>转移目标地址：<code>Regs[rs]</code></li></ul></li></ul><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-03-14.webp" alt="I类指令格式" /></p><hr /><h5 id="r-类指令register"><a class="markdownIt-Anchor" href="#r-类指令register"></a> R 类指令（Register）</h5><p><strong>包含类型</strong></p><ul><li>ALU 运算指令</li><li>专用寄存器读 / 写指令</li><li>move 指令等</li></ul><p><strong>ALU 指令语义</strong></p><ul><li><code>Regs[rd] ← Regs[rs] funct Regs[rt]</code></li><li><code>funct</code> 字段指定具体运算类型</li></ul><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-03-40.webp" alt="R类指令格式" /></p><hr /><h5 id="j-类指令jump"><a class="markdownIt-Anchor" href="#j-类指令jump"></a> J 类指令（Jump）</h5><p><strong>包含类型</strong></p><ul><li>跳转指令</li><li>跳转并链接指令</li><li>自陷指令</li><li>异常返回指令</li></ul><p><strong>特点</strong></p><ul><li>指令字低 26 位为偏移量</li><li>与当前 PC 值组合形成跳转目标地址</li></ul><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-04-15.webp" alt="J类指令格式" /></p><h4 id="mips的操作"><a class="markdownIt-Anchor" href="#mips的操作"></a> MIPS的操作</h4><p>MIPS指令可以分为四大类<br />load和store<br />ALU操作<br />分支与跳转<br />浮点操作</p><h4 id="数据表示-2"><a class="markdownIt-Anchor" href="#数据表示-2"></a> 数据表示</h4><h4 id="数据表示-3"><a class="markdownIt-Anchor" href="#数据表示-3"></a> 数据表示</h4><h2 id="第八章-cpu"><a class="markdownIt-Anchor" href="#第八章-cpu"></a> 第八章 CPU</h2><h3 id="cpu的功能"><a class="markdownIt-Anchor" href="#cpu的功能"></a> CPU的功能</h3><p>CPU具有以下4个方面的基本功能</p><ul><li>指令顺序控制<ul><li>指控制程序中指令的执行顺序。</li><li>程序中各指令之间是有严格先后顺序的，必须严格按程序规定的顺序执行，才能保证计算机工作的正确性</li></ul></li><li>操作控制<ul><li>一条指令的功能往往是由计算机中的部件执行一序列的操作来实现的。</li><li>CPU要根据指令的功能，产生相应的操作控制信号，发送给相应的部件，从而控制这些部件按指令的要求进行动作</li></ul></li><li>时间控制<br />对各种操作实施时间上的定时。<ul><li>在一条指令的执行过程中，在什么时间做什么操作均应受到严格的控制</li></ul></li><li>数据加工<ul><li>即对数据进行算术运算和逻辑运算，或进行其他的信息处理</li></ul></li></ul><h4 id="基本组成"><a class="markdownIt-Anchor" href="#基本组成"></a> 基本组成</h4><ul><li>现代CPU一般由运算器、控制器、数据通路和Cache组成</li></ul><h4 id="指令执行的基本步骤"><a class="markdownIt-Anchor" href="#指令执行的基本步骤"></a> 指令执行的基本步骤</h4><blockquote><p>一条指令的执行过程包括3个基本步骤：</p></blockquote><ol><li>取指令：从存储器取出一条指令，该指令的地址由程序计数器PC给出。</li><li>译码：对该指令的操作码进行译码分析，确定是哪一种指令，并转到这种指令对应的执行阶段。</li><li>执行：按指令操作码的要求执行该指令。执行过程可能需要多步操作，控制器将为之形成完成该指令功能所需要的操作控制信号。执行完毕后,回到取指令阶段，去取下一条指令。如此反复，直到整个程序执行完。</li></ol><h3 id="模型机mips结构的简单实现"><a class="markdownIt-Anchor" href="#模型机mips结构的简单实现"></a> 模型机:MIPS结构的简单实现</h3><p>所包含的指令</p><ul><li>算术逻辑运算指令（R类型指令格式）<ul><li>add，sub，and，or，slt</li><li>操作码字段Op=0</li></ul></li><li>存储器访问指令（I类型指令格式）<ul><li>lw（load word，op=35）</li><li>sw（store word，Op=43）</li></ul></li><li>等于“0”分支（I类型指令格式）<ul><li>beqz，Op=63</li><li>说明：beqz在MIPS中实际上是条伪指令。<br /><strong>R</strong></li></ul></li></ul><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-29-31.webp" alt="alt text" /></p><ul><li><p><strong>Op</strong> —— 操作码字段<br />用 IR[Op] 或 IR[31:26] 表示</p></li><li><p><strong>rs</strong> —— 第一源操作数字段<br />用 IR[rs] 或 IR[25:21] 表示</p></li><li><p><strong>rt</strong> —— 第二源操作数字段<br />用 IR[rt] 或 IR[20:16] 表示</p></li><li><p><strong>rd</strong> —— 目标操作数字段(或结果字段)<br />用 IR[rd] 或 IR[15:11] 表示</p></li><li><p><strong>shamt</strong> —— 无用</p></li><li><p><strong>funct</strong> —— ALU 指令的运算函数码字段<br />用 IR[funct] 或 IR[5:0] 表示</p></li></ul><hr /><p><strong>I</strong></p><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-30-12.webp" alt="alt text" /></p><ul><li><p><strong>rs</strong> —— 基址寄存器字段<br />用 IR[rs] 或 IR[25:21] 表示<br />对于 beqz 指令来说, 是存放被检测的数据</p></li><li><p><strong>adr</strong> —— 偏移量字段<br />用 IR[adr] 或 IR[15:0] 表示<br />rs 和 adr 用于计算访存有效地址或分支目标地址</p></li><li><p><strong>rt</strong> —— 寄存器字段<br />对于 load 指令来说, rt 所指出的寄存器是存放所取的数据<br />对于 store 指令来说, 是存放要写入存储器的数据</p></li></ul><h3 id="构建基本的数据通路"><a class="markdownIt-Anchor" href="#构建基本的数据通路"></a> 构建基本的数据通路</h3><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-39-16.webp" alt="alt text" /></p><ul><li>程序计数器(PC):指出当前正在执行的指令的地址,每执行一条指令,PC+4</li><li>指令存储器(IM):假设IM内已经加载好了所需的指令,在IA加载地址,就可以从Ins得到对应指令</li><li>数据存储器(DM):两个输入端,一个是DA,给出要写入或读出的存储单元的地址,另一个是WD,给出要写入DM的数据;有两个控制信号:DMRead和DMWrite,任何时候最多只有一个有效</li><li>通用寄存器组:输入端有4个,RR1和RR2给出两个读操作的地址,WR给出写操作的地址,WD给出要写入的数据;输出端有两个:RD1和RD2分别给出读出的寄存器单元的数据;有一个控制信号RegWrite,当对寄存器组进行写入时才有效</li><li>ALU:输入两个32位的数据,输出ALUo是运算结果,由ALUCtrl(4位)给出运算操作</li><li>加法器:将两个输入数据相加,结果放到输出端SUM</li><li>符号位扩展部件:把16位的数据按符号扩展为32位的数据</li><li>判0部件:输入一个32位的数据,输出是一位信号,若输入为0时输出为真<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-53-11.webp" alt="alt text" /></li></ul><h4 id="构建r类指令"><a class="markdownIt-Anchor" href="#构建r类指令"></a> 构建R类指令</h4><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-55-38.webp" alt="alt text" /></p><h4 id="构建访存指令load和store"><a class="markdownIt-Anchor" href="#构建访存指令load和store"></a> 构建访存指令(load和store)</h4><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-58-09.webp" alt="alt text" /><br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-59-29.webp" alt="alt text" /><br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-01-46.webp" alt="alt text" /></p><h4 id="beqz指令"><a class="markdownIt-Anchor" href="#beqz指令"></a> beqz指令</h4><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-10-09.webp" alt="alt text" /><br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-10-38.webp" alt="alt text" /></p><h3 id="alu控制器"><a class="markdownIt-Anchor" href="#alu控制器"></a> ALU控制器</h3><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-18-57.webp" alt="alt text" /></p><blockquote><p>ALU完成具体的运算有5个：加、减、或、与、比较</p></blockquote><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-20-40.webp" alt="alt text" /></p><h3 id="多周期实现方案"><a class="markdownIt-Anchor" href="#多周期实现方案"></a> 多周期实现方案</h3><h4 id="为什么用多周期"><a class="markdownIt-Anchor" href="#为什么用多周期"></a> 为什么用多周期</h4><p><strong>单周期方案的不足</strong></p><ul><li><p><strong>效率低下</strong><br />不同类型的指令所完成的工作量有很大的差别<br />所要用到的部件和所通过的数据通路不同<br />所用时间的长短也有很大的差别</p></li><li><p><strong>硬件利用率低</strong><br />每个时钟周期中功能部件最多被使用一次<br />如果在执行一条指令的过程中多次使用某一部件<br />就需要重复设置该部件（增加实现成本）</p></li></ul><hr /><p><strong>解决方法：采用多周期方案</strong></p><ul><li>采用更短的时间作为时钟周期</li><li>允许一条指令的执行跨越多个时钟周期</li><li>该时钟周期通常等于一个基本部件的延迟时间</li></ul><p><strong>好处</strong></p><ul><li>可以共享同一个功能部件</li></ul><h3 id="控制器设计"><a class="markdownIt-Anchor" href="#控制器设计"></a> 控制器设计</h3><p>实现控制器的技术有两种：硬连逻辑和微程序设计</p><ul><li>硬连逻辑是建立在有限状态机的基础上，并且一般是以状态图的形式表示。</li><li>微程序设计则是采用微指令的方式来表示和实现控制。</li></ul><h4 id="控制器的组成"><a class="markdownIt-Anchor" href="#控制器的组成"></a> 控制器的组成</h4><ul><li>指令部件<ul><li>程序计数器PC</li><li>指令寄存器IR</li><li>指令译码器ID</li><li>地址形成部件</li></ul></li><li>时序控制部件<ul><li>时钟脉冲CP</li><li>时序信号发生器</li></ul></li><li>微操作控制信号形成部件</li><li>中断控制逻辑</li><li>程序状态寄存器</li></ul><h3 id="流水线技术"><a class="markdownIt-Anchor" href="#流水线技术"></a> 流水线技术</h3><blockquote><p>什么是流水线技术<br />定义：<br />流水线技术是把一条指令的执行过程划分为若干个顺序阶段，每个阶段由专门的部件完成，不同指令在不同阶段上并行执行的一种处理技术。</p></blockquote><blockquote><p>为什么要采用流水线技术<br />提高处理器吞吐率：在同一时间并行处理多条指令的不同阶段，使单位时间内完成的指令数增加<br />提高硬件利用率：各功能部件（取指、译码、执行等）可以同时工作，减少空闲时间<br />提升整体性能：在不显著增加主频的情况下，提高平均指令执行速度</p></blockquote><h2 id="第九章-微程序控制器"><a class="markdownIt-Anchor" href="#第九章-微程序控制器"></a> 第九章 微程序控制器</h2><blockquote><p>组合逻辑控制器存在的两个比较突出的缺点:</p></blockquote><ul><li>设计复杂、繁琐，缺乏规律性，设计效率低</li><li>不易修改和扩充，缺乏灵活性</li></ul><blockquote><p>微程序控制器的缺点:速度比较慢</p></blockquote><ul><li>因此RISC仍旧采用硬连逻辑设计</li></ul><h3 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h3><blockquote><p>用二进制编码字（称为微指令字）来代替组合逻辑控制器中的微操作控制信号的产生</p></blockquote><h4 id="微操作和微命令"><a class="markdownIt-Anchor" href="#微操作和微命令"></a> 微操作和微命令</h4><p>微命令:构成控制信号序列的最小单位<br />微操作:接受微命令后进行的最基本的操作</p><ul><li>分为两种：<ul><li>相容的微操作：可以同时进行的微操作</li><li>互斥的微操作：不能同时进行的微操作</li></ul></li></ul><h4 id="微指令和微程序"><a class="markdownIt-Anchor" href="#微指令和微程序"></a> 微指令和微程序</h4><p><strong>微指令</strong><br />微指令：用来产生微控制信号的二进制编码字,用于控制完成一组微操作</p><p><strong>微程序</strong><br />微程序：由一系列微指令构成的有序集合<br />每一条机器指令都对应一段微程序<br />通过解释执行该微程序，完成指令所规定的操作</p><hr /><h4 id="微指令周期"><a class="markdownIt-Anchor" href="#微指令周期"></a> 微指令周期</h4><p><strong>微指令周期</strong><br />微指令周期：微程序控制器的工作周期<br />从控制存储器中读取一条微指令到执行完相应微操作所需时间的最大值</p><h3 id="微指令的编码方法"><a class="markdownIt-Anchor" href="#微指令的编码方法"></a> 微指令的编码方法</h3><blockquote><p>设计目标: 减少微指令的宽度, 减少微程序的长度, 提高执行速度, 保持微程序设计的灵活性</p></blockquote><p>共有四种编码方法</p><hr /><h4 id="直接控制编码法不译码法"><a class="markdownIt-Anchor" href="#直接控制编码法不译码法"></a> 直接控制编码法(不译码法)</h4><ul><li>微操作控制字段的每一位直接对应一个微操作</li><li>当某位为 1 时, 表示执行相应的微操作;为 0 时不执行该微操作</li></ul><p><strong>优点</strong></p><ul><li>结构简单</li><li>并行性最好</li><li>操作速度快</li></ul><p><strong>缺点</strong></p><ul><li>微指令字太长<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_14-53-30.webp" alt="alt text" /></li></ul><hr /><h4 id="最短字长编码法"><a class="markdownIt-Anchor" href="#最短字长编码法"></a> 最短字长编码法</h4><ul><li>将所有微命令进行统一的二进制编码</li><li>每条微指令只定义一个微操作</li></ul><p><strong>微操作控制字段长度关系</strong></p><ul><li><p>微操作控制字段长度 L 与微命令总数 N 的关系</p><ul><li>L ≥ log2 N</li></ul></li></ul><p><strong>优缺点</strong></p><ul><li>微指令字长最短</li><li>需要经过译码才能得到所需的微命令, 执行速度受影响</li><li>一条微指令只能产生一个微命令</li><li>无法利用硬件的并行性<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_14-54-21.webp" alt="alt text" /></li></ul><hr /><h4 id="字段直接编码法"><a class="markdownIt-Anchor" href="#字段直接编码法"></a> 字段直接编码法</h4><ul><li>将微操作控制字段进一步划分为若干字段</li><li>每个字段单独编码</li><li>每个码点表示一个微命令</li></ul><p><strong>折中方案</strong></p><ul><li>字段之间采用直接控制</li><li>字段内部采用最短字长编码</li></ul><p><strong>字段划分原则</strong></p><ul><li><p>可按功能或部件划分</p><ul><li>对机器中的每一类功能或每一个部件分配一个字段</li></ul></li><li><p>将互斥的微操作分在同一字段</p></li><li><p>将相容的微操作分在不同字段</p></li><li><p>字段划分应与数据通路相适应</p></li><li><p>一般每个字段应保留一个码点,用于表示不发任何微命令<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_14-55-50.webp" alt="alt text" /></p></li></ul><hr /><h4 id="字段间接编码"><a class="markdownIt-Anchor" href="#字段间接编码"></a> 字段间接编码</h4><ul><li>字段编码的含义需要由另一个字段的编码来解释确定</li><li>一个解释字段可同时对多个字段进行控制</li><li>只有这样才能有效缩短微指令字长</li><li>解释字段应具有一定的分类特征<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_14-56-53.webp" alt="alt text" /></li></ul><hr /><h4 id="常数源字段的设置"><a class="markdownIt-Anchor" href="#常数源字段的设置"></a> 常数源字段的设置</h4><p><strong>作用</strong></p><ul><li>提供常数</li><li>参与其他字段的间接编码</li></ul><h3 id="微指令的格式"><a class="markdownIt-Anchor" href="#微指令的格式"></a> 微指令的格式</h3><p>分为两大类: 水平型微指令 和 垂直型微指令</p><hr /><h4 id="水平型微指令"><a class="markdownIt-Anchor" href="#水平型微指令"></a> 水平型微指令</h4><p>一次能定义并执行多个微操作的微指令</p><p><strong>特点</strong></p><ul><li><p>微指令字较长,一般为几十位到上百位</p></li><li><p>描述并行微操作的能力强<br />在一个微周期中可并行执行多个微操作</p></li><li><p>微指令译码简单<br />一般采用直接控制编码法和分段直接编码法</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点</p><ul><li>并行操作能力强</li><li>执行速度快</li><li>代码长度短</li></ul></li><li><p>缺点</p><ul><li>微指令字较长,明显增加控存宽度</li><li>微程序编制复杂,难度较大,不易实现设计自动化</li></ul></li></ul><hr /><h4 id="垂直型微指令"><a class="markdownIt-Anchor" href="#垂直型微指令"></a> 垂直型微指令</h4><blockquote><p>一次只能定义一两个微操作,微指令字长较短</p></blockquote><p><strong>特点</strong></p><ul><li><p>微指令字短<br />一般为十几位到二十位左右</p></li><li><p>并行微操作能力差<br />一条微指令只能控制数据通路的一两种信息传送</p></li><li><p>通过微操作码字段定义微指令的基本功能和信息传送路径<br />执行时需要完全译码<br />译码过程较复杂</p></li><li><p>微指令各二进制位与数据通路控制点之间不存在直接对应关系</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点</p><ul><li>结构直观、规整,易于编制微程序</li><li>微指令字较短,控存横向较窄</li></ul></li><li><p>缺点</p><ul><li>微程序较长,微指令需经译码产生微命令,执行速度较慢</li><li>描述并行微操作能力差,不适合并行性较强的数据通路机器</li></ul></li></ul><h3 id="后续微地址的产生"><a class="markdownIt-Anchor" href="#后续微地址的产生"></a> 后续微地址的产生</h3><blockquote><p>两种方式: 增量方式, 断定方式</p></blockquote><hr /><h4 id="增量方式"><a class="markdownIt-Anchor" href="#增量方式"></a> 增量方式</h4><ul><li>设置一个微程序计数器 μPC</li><li>顺序执行时<br />给 μPC 增加一个增量(通常为 1), 得到下一条微指令地址</li><li>遇到转移时<br />由微指令给出转移目标微地址</li></ul><p><strong>微地址字段 SCF 的组成</strong></p><ul><li><p>转移控制字段 BCF<br />用于规定是顺序执行还是转移<br />若为转移, 由 BCF 指出转移地址的来源</p></li><li><p>转移地址字段 BAF<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_15-45-43.webp" alt="alt text" /><br /><strong>转移地址的来源有 3 种</strong></p></li><li><p>由 BAF 给出的地址</p></li><li><p>机器指令所对应微程序的入口地址</p></li><li><p>微子程序入口地址和返回地址<br />返回地址存放在返回地址寄存器中</p></li></ul><p><strong>优点</strong></p><ul><li>SCF 字段较短</li><li>后继微地址生成逻辑较简单</li><li>微程序编制较容易</li></ul><p><strong>缺点</strong></p><ul><li>不能直接实现多路转移</li></ul><hr /><h4 id="断定方式"><a class="markdownIt-Anchor" href="#断定方式"></a> 断定方式</h4><p><strong>后继微地址的确定方式</strong></p><ul><li><p>由微程序设计者直接指定</p></li><li><p>由微程序设计者指定的测试判别逻辑字段控制产生<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-14_15-46-10.webp" alt="alt text" /><br /><strong>后继微地址的组成</strong></p></li><li><p>非测试地址<br />由微程序设计者直接指定<br />地址不变<br />构成微地址的高位部分</p></li><li><p>测试地址<br />在微程序执行过程中<br />通过测试某些状态位动态决定<br />构成微地址的低位部分</p></li></ul><p><strong>分支能力与字段位数</strong></p><ul><li><p>若测试地址位数为 m<br />分支路数为 2^m<br />测试字段个数为 m</p></li><li><p>测试字段位数 n 取决于测试条件个数 N<br />一般有<br />n = [log2 N] + 1</p></li></ul><p><strong>优点</strong></p><ul><li>可实现快速多路转移</li><li>提高微程序执行速度</li><li>微程序在控存中的存放位置灵活、方便</li></ul><p><strong>缺点</strong></p><ul><li>后继微地址生成逻辑较复杂</li><li>微程序执行顺序不直观</li></ul><h3 id="微指令的执行方式"><a class="markdownIt-Anchor" href="#微指令的执行方式"></a> 微指令的执行方式</h3><h4 id="串行执行"><a class="markdownIt-Anchor" href="#串行执行"></a> 串行执行</h4><blockquote><p>取微指令和执行微指令串行进行。在前一条的微指令执行完之后，才能取下一条微指令。<br /><strong>特点</strong><br />设备效率低，执行速度慢。控制简单，易于实现。</p></blockquote><h4 id="并行执行"><a class="markdownIt-Anchor" href="#并行执行"></a> 并行执行</h4><blockquote><p>当前微指令的执行和下一条微指令的取出重叠进行</p></blockquote><p><strong>优点</strong></p><ul><li>提高了执行速度和设备利用率</li></ul><hr /><p><strong>存在的问题</strong></p><ul><li>当需要根据当前微指令的执行结果进行转移时<br />会产生控制上的困难</li></ul><hr /><p><strong>两种处理方法</strong></p><ul><li><p><strong>方法一: 推迟取指</strong><br />推迟下一条微指令的取出<br />使其取出时间与串行执行方式相同</p></li><li><p><strong>方法二: 猜测法</strong><br />采用猜测方式<br />在两条可能的分支中<br />猜测性地选择其中一条作为后继微指令</p></li></ul><h2 id="第十章-运算方法和运算器"><a class="markdownIt-Anchor" href="#第十章-运算方法和运算器"></a> 第十章 运算方法和运算器</h2><h3 id="移位运算"><a class="markdownIt-Anchor" href="#移位运算"></a> 移位运算</h3><h4 id="逻辑移位"><a class="markdownIt-Anchor" href="#逻辑移位"></a> 逻辑移位</h4><p>逻辑移位中,被移动的数据是逻辑数,没有符号和数值大小</p><ol><li>逻辑左移: 数据各位左移一位,最高位丢弃,最低位移入0</li><li>逻辑右移: 依次右移,最低位丢弃,最高位移入0</li></ol><h4 id="循环移位"><a class="markdownIt-Anchor" href="#循环移位"></a> 循环移位</h4><p>将被移位的数据左右两端相连形成闭合回路<br />如10011左移变成00111</p><h4 id="算术移位"><a class="markdownIt-Anchor" href="#算术移位"></a> 算术移位</h4><p>对带符号的数进行移位;会引发数值变化</p><h5 id="原码算术移位"><a class="markdownIt-Anchor" href="#原码算术移位"></a> 原码算术移位</h5><p>符号位不参加移位,将相应数值进行逻辑移位</p><h5 id="补码算术移位"><a class="markdownIt-Anchor" href="#补码算术移位"></a> 补码算术移位</h5><p>对补码进行算术移位时,符号位一起参与移位</p><ol><li>算术左移: 连同符号位一起左移一位,最高位丢弃,最低位移入0</li><li>算术右移:连同符号位一起右移一位,符号位不变,最低位移出丢弃</li></ol><ul><li>左移时可能发生溢出,取模时得到负数</li></ul><h3 id="定点数加减法运算"><a class="markdownIt-Anchor" href="#定点数加减法运算"></a> 定点数加减法运算</h3><h4 id="补码加减法"><a class="markdownIt-Anchor" href="#补码加减法"></a> 补码加减法</h4><p>若符号位产生进位则舍弃进位</p><h4 id="判断溢出"><a class="markdownIt-Anchor" href="#判断溢出"></a> 判断溢出</h4><blockquote><p><strong>采用两个操作数和结果的符号来判断</strong><br />当两个同号数的补码相加，若得到的结果的符号与两个操作数的符号不同，则发生了溢出</p></blockquote><blockquote><p><strong>采用最高数值位产生的进位与符号位产生的进位是否相同来判断</strong> ,当不相同时，则发生了溢出</p></blockquote><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_17-40-21.webp" alt="alt text" /></p><blockquote><p>采用变形补码,将符号位扩展为2位,若运算结果的两个符号位不同,则发生了溢出</p></blockquote><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_17-46-46.webp" alt="alt text" /></p><h3 id="定点数乘除法运算"><a class="markdownIt-Anchor" href="#定点数乘除法运算"></a> 定点数乘除法运算</h3><h4 id="原码一位乘法"><a class="markdownIt-Anchor" href="#原码一位乘法"></a> 原码一位乘法</h4><p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_17-53-17.webp" alt="alt text" /></p><h3 id="浮点数加减法运算"><a class="markdownIt-Anchor" href="#浮点数加减法运算"></a> 浮点数加减法运算</h3><p>设有两个规格化浮点数 X 和 Y, 分别为<br />X: XEXM<br />Y: YEYM</p><p>其中</p><ul><li>XE 和 YE: 阶码</li><li>XM 和 YM: 尾数</li></ul><hr /><h4 id="浮点加减法运算的步骤"><a class="markdownIt-Anchor" href="#浮点加减法运算的步骤"></a> 浮点加减法运算的步骤</h4><ol><li>判 0 操作</li><li>对阶</li><li>尾数加减</li><li>规格化与舍入<br />（在规格化过程中需要判断运算结果是否溢出）</li></ol><hr /><h4 id="1-判-0-操作"><a class="markdownIt-Anchor" href="#1-判-0-操作"></a> 1. 判 0 操作</h4><ul><li><p>若两个操作数 X 和 Y 中有一个为 0<br />则不需要进行运算<br />直接设置运算结果为 0<br />运算结束</p></li><li><p>否则进入下一步</p></li></ul><hr /><h4 id="2-对阶"><a class="markdownIt-Anchor" href="#2-对阶"></a> 2. 对阶</h4><p><strong>目的</strong></p><ul><li>使小数点对齐</li></ul><p><strong>方法</strong></p><ul><li>对其中一个操作数进行变换<br />使两个操作数的阶码相等</li></ul><ul><li>对齐大阶码<br /><strong>实现步骤</strong></li></ul><ol><li><p>求阶差<br />△E = XE − YE</p></li><li><p>若 △E &gt; 0</p><ul><li><p>表示 X 的阶码大于 Y 的阶码</p></li><li><p>调整操作数 Y</p><ul><li>将 Y 的尾数 YM 右移</li><li>每右移一位<br />阶码 YE 加 1</li><li>直到两数阶码相等</li></ul></li></ul></li><li><p>若 △E &lt; 0</p><ul><li>表示 X 的阶码小于 Y 的阶码</li><li>调整操作数 X</li><li>调整方法与上述相同</li></ul></li></ol><hr /><h4 id="3-尾数加减"><a class="markdownIt-Anchor" href="#3-尾数加减"></a> 3. 尾数加减</h4><ul><li>将两数的尾数 XM 和 YM<br />按照相应的定点加减运算规则<br />进行加法或减法运算</li><li>得到运算结果的尾数</li></ul><hr /><h4 id="4-结果规格化并判溢出"><a class="markdownIt-Anchor" href="#4-结果规格化并判溢出"></a> 4. 结果规格化并判溢出</h4><ol><li><p>右规情况</p><ul><li><p>若运算结果的绝对值大于 1</p><ul><li>将结果右移一位</li><li>相应的阶码加 1</li><li>右规最多只需一位</li></ul></li></ul></li><li><p>左规情况</p><ul><li><p>若运算结果的绝对值小于 1</p><ul><li>将结果左移</li><li>每左移一位<br />阶码减 1</li><li>直到结果的绝对值大于等于 1/2 为止</li></ul></li></ul></li><li><p>溢出判断</p><ul><li><p>每次阶码加 1 或减 1 后<br />都要判断阶码是否越界</p></li><li><p>阶码上溢</p><ul><li>阶码大于可表示的最大正数</li><li>可置溢出标志</li><li>或将结果作为 +∞ 或 −∞ 处理</li></ul></li><li><p>阶码下溢</p><ul><li>阶码小于可表示的最小负数</li><li>可置溢出标志</li><li>或将结果作为 0 处理</li></ul></li></ul></li></ol><hr /><h4 id="5-舍入处理"><a class="markdownIt-Anchor" href="#5-舍入处理"></a> 5. 舍入处理</h4><p>常用的舍入方法有</p><ol><li>0 舍 1 入法:类似四舍五入</li><li>截断法:直接舍去右移的数字</li><li>朝 +∞ 舍入法:若为正数,只要移出的数位不全为0,则最低有效位加1;若为负数则采用截断法</li><li>朝 −∞ 舍入法:若为负数,只要移出的数位不全为0,则最低有效位加1;若为正数则采用截断法</li></ol><h2 id="第十一章-存储器"><a class="markdownIt-Anchor" href="#第十一章-存储器"></a> 第十一章 存储器</h2><h3 id="存储子系统概述"><a class="markdownIt-Anchor" href="#存储子系统概述"></a> 存储子系统概述</h3><blockquote><p>三级存储系统:</p><ul><li>Cache（高速缓冲存储器）</li><li>主存储器</li><li>磁盘存储器（辅存）</li></ul></blockquote><ul><li><p>最靠近CPU的Cache速度最快,容量最小;离CPU最远的硬盘速度最慢，但容量最大</p></li><li><p>CPU所访问的指令和数据的绝大部分都能在Cache中找到,之所以可以做到,是根据程序访问的局部性原理,即程序在一小段时间间隔内访问的指令和数据在地址上是相对集中的</p></li><li><p>两个存储层次</p><ul><li>“Cache—主存”层次：解决主存速度不足的问题</li><li>“主存—辅存”层次：解决主存容量不足的问题<br /><img src="/images/archives/2026-01-11/PixPin_2026-01-13_21-57-01.webp" alt="alt text" /></li></ul></li></ul><h3 id="存储器分类"><a class="markdownIt-Anchor" href="#存储器分类"></a> 存储器分类</h3><h4 id="按在计算机系统中的作用分类"><a class="markdownIt-Anchor" href="#按在计算机系统中的作用分类"></a> 按在计算机系统中的作用分类</h4><ol><li><strong>主存储器</strong>,又简称为主存或内存。</li></ol><ul><li>它是整个存储系统的核心，用来存放计算机当前运行的程序以及所需的数据，CPU可直接随机地对它进行访问。</li></ul><ol start="2"><li><strong>辅助存储器</strong>,简称为辅存或外存</li></ol><ul><li>弥补主存的容量不足,用来存放暂时不用的程序和数据。CPU不能直接访问它，当需要运行辅助存储器中的程序时，需将它们调入主存后供CPU使用。</li></ul><ol start="3"><li>高速缓冲存储器Cache</li></ol><ul><li>弥补主存的速度不足,位于CPU和主存储器之间</li></ul><h4 id="按照存取方式分类"><a class="markdownIt-Anchor" href="#按照存取方式分类"></a> 按照存取方式分类</h4><blockquote><p>存取方式：指访问存储单元的方法</p></blockquote><ul><li><p><strong>随机存储器 RAM</strong><br />Random Access Memory</p></li><li><p><strong>只读存储器 ROM</strong><br />Read Only Memory</p></li><li><p><strong>顺序存取存储器 SAM</strong><br />Sequential Access Memory</p></li></ul><ol><li>随机存储器RAM</li></ol><blockquote><p>可随机地读取或写入存储器的任何一个单元，访问时间是固定的，与存储单元的物理位置无关</p></blockquote><ul><li>在系统断电后大多数随机存储器RAM所保存的信息将丢失</li><li>常用来作主存和Cache</li></ul><ol start="2"><li>只读存储器ROM</li></ol><blockquote><p>只能随机读取存储器的任何一个单元，不能写入信息。</p></blockquote><ul><li>系统断电后，所保存的信息不会丢失。</li><li>用来存放不需要改变的信息,比如存放系统程序</li></ul><ol start="3"><li>顺序存取存储器SAM</li></ol><blockquote><p>只能按顺序访问存储器中的信息，访问时间与信息在存储器中所处的物理位置有关。</p></blockquote><ul><li>信息通常以文件或数据块的形式存放,如磁带</li></ul><h4 id="按照存储介质分类"><a class="markdownIt-Anchor" href="#按照存储介质分类"></a> 按照存储介质分类</h4><blockquote><p>存储介质一般具备3个特点:</p></blockquote><ol><li><p>具有两种稳定的状态，分别代表二进制代码0和1</p></li><li><p>能方便地检测出存储介质所处的状态</p></li><li><p>两种状态容易相互转换</p></li><li><p>半导体存储器</p></li><li><p>磁表面存储器</p></li><li><p>光存储器</p></li></ol><h3 id="主存储器"><a class="markdownIt-Anchor" href="#主存储器"></a> 主存储器</h3><h4 id="主存的组成结构"><a class="markdownIt-Anchor" href="#主存的组成结构"></a> 主存的组成结构</h4><ol><li>存储体</li></ol><blockquote><p>存储二进制信息的主体，由许多存储单元构成，每一个存储单元存放1～8个字节<br />每一个存储单元都有一个统一的编号，称为地址,地址与存储单元之间是一一对应的。</p></blockquote><ol start="2"><li>地址译码和驱动电路</li><li>读写电路</li><li>存储控制电路</li></ol><h3 id="主存的主要技术指标"><a class="markdownIt-Anchor" href="#主存的主要技术指标"></a> 主存的主要技术指标</h3><h4 id="存储容量"><a class="markdownIt-Anchor" href="#存储容量"></a> 存储容量</h4><p>一个存储器中所能存储的二进制信息的总量.<br />常用位 b 和字节 B 来表示<br />如 64Kb, 512KB, 4MB.</p><hr /><h4 id="存取速度"><a class="markdownIt-Anchor" href="#存取速度"></a> 存取速度</h4><p>指访问存储器的速度.</p><p><strong>存取时间 TA</strong><br />又称访问时间或读写时间, 指从启动一次存储器访存操作到完成该操作所需要的时间.</p><p><strong>存储周期 TM</strong><br />指连续两次启动存储器访问所需的最小时间间隔.</p><ul><li>包括存储器的存取时间和自身恢复时间.</li><li>存储周期通常大于或等于存取时间.</li></ul><p><strong>主存带宽 BM</strong><br />存储器单位时间内所能存取的信息量.</p><ul><li>也称为数据传输率或主存的数据传输频率.</li><li>单位为 bit/s 或 byte/s.</li></ul><p>BM 的计算公式为:</p><ul><li>BM = 每个存储单元的位数 / TM (bit/s)</li><li>BM = 每个存储单元的位数 / (TM × 8) (byte/s)</li></ul><p>提高 BM 的方法有三种:</p><ul><li>增加存储单元的位数</li><li>减少 TM</li><li>采用多个存储体</li></ul><hr /><h4 id="可靠性"><a class="markdownIt-Anchor" href="#可靠性"></a> 可靠性</h4><p>在规定的时间内, 存储器无故障读写的概率.<br />通常用平均无故障间隔时间 MTBF (Mean Time Between Failures) 来衡量.<br />MTBF 越长, 说明存储器的可靠性越高.</p><hr /><h4 id="功耗"><a class="markdownIt-Anchor" href="#功耗"></a> 功耗</h4><p>指单位时间存储器所消耗的电能,功耗越小越好</p><h3 id="随机存储器"><a class="markdownIt-Anchor" href="#随机存储器"></a> 随机存储器</h3><h4 id="静态随机存储器sram"><a class="markdownIt-Anchor" href="#静态随机存储器sram"></a> 静态随机存储器SRAM</h4><blockquote><p>利用触发器来储存二进制信息<br />优点：SRAM 工作速度快，稳定可靠，不需要外加刷新电路，从而简化了外电路设计<br />缺点：所含晶体管较多，故集成度较低，功耗较大</p></blockquote><h4 id="动态随机存储器dram"><a class="markdownIt-Anchor" href="#动态随机存储器dram"></a> 动态随机存储器DRAM</h4><blockquote><p>利用 MOS 晶体管的管极电容来存储二进制信息<br />优点：基本存储位元电路中所含晶体管数目少、集成度高、成本低、功耗小<br />缺点：它需外加刷新电路，工作速度比 SRAM 慢得多（破坏性读出且需要刷新）</p></blockquote><h3 id="dram的刷新"><a class="markdownIt-Anchor" href="#dram的刷新"></a> DRAM的刷新</h3><blockquote><p>什么叫刷新：为维持 DRAM 所存信息不变，需要定时地对 DRAM 中的电容充电，以补充泄漏掉的电荷。这个过程叫刷新</p></blockquote><blockquote><p>DRAM 为什么需要刷新： DRAM 是利用电容上保存的电荷来存储信息的，由于存在漏电阻，即使电源不掉电，时间长了，电容上的电荷也会慢慢泄漏掉，DRAM 内存储的信息会自动消失。</p></blockquote><blockquote><p>什么叫刷新周期：从上一次对整个存储器刷新结束到下一次对整个存储器刷新结束所需的时间</p></blockquote><ol><li>集中式刷新：在一个刷新周期内，集中一段时间连续地对全部存储单元逐行刷新一遍。</li></ol><ul><li>在刷新操作期间，不允许 CPU 对存储器进行正常的访问</li></ul><p>优点：读写操作时不受刷新工作的影响，系统的存取速度比较高<br />缺点：在集中刷新期间必须停止读写，这一段时间称为“死区”，而且存储容量越大，死区就越长。<br />2. 分散式刷新：把对每行存储单元的刷新分散到每个系统存取周期内完成。此时系统存取周期被分为两部分，周期前半段时间进行正常的存储器访问，后半段时间进行刷新操作。在一个系统存取周期内刷新存储矩阵中的一行,增加了系统的存取周期<br />优点：没有死区<br />缺点：刷新过于频繁。系统存取周期是存储芯片存取周期的两倍，降低了访问存储器的速度。<br />3. 异步式刷新：把刷新操作平均分配到整个最大刷新间隔内进行，相邻两行的刷新间隔为：刷新周期÷行数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;考试事项&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#考试事项&quot;&gt;&lt;/a&gt; 考试事项&lt;/h2&gt;
&lt;p&gt;考试分数占比60%&lt;br /&gt;
填空15分 一空一分&lt;br /&gt;
选择20分 20道题&lt;br /&gt;
综合题65分 七道大题,基本一个</summary>
      
    
    
    
    
    <category term="计算机组成原理" scheme="https://revival-of-hope.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-11 再战算法</title>
    <link href="https://revival-of-hope.github.io/2026/01/11/archives-2026-01-11-%E5%86%8D%E6%88%98%E7%AE%97%E6%B3%95/"/>
    <id>https://revival-of-hope.github.io/2026/01/11/archives-2026-01-11-%E5%86%8D%E6%88%98%E7%AE%97%E6%B3%95/</id>
    <published>2026-01-11T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.534Z</updated>
    
    <content type="html"><![CDATA[<p>昨天考了程序设计范式,一开始觉得三个小时三道题不是有手就行,后来发现我太天真了.</p><p>第一道题是leetcode2002,一道关于不相交回文子串的中级题,我硬是没想到用dfs做,可能是一个月没碰算法生疏了吧,<br />第二道题是设计几个角色的类,考察多态和继承,还真有点难,报错信息我都看不懂,第三道题是求满足给定和的最短子串,尽管我一开始就把双指针写出来了,但却在一些测试数据中一直死循环,还好机房上装了vscode,不然我都不知道要怎么调试,前前后后最少调了半个小时才解决这个问题,只能说是在第一题没做出来的情况下太紧张脑子短路了.</p><p>这一顿折腾下来,我才发现我连最基本的dfs都没能很好地掌握,连普通的课程考试都过不了关,啥也不说了,速速去刷题,<br />之前看了百度之星的题目,彻底断了打acm的念想,但刷点水题娱乐一下也是挺好的,不仅能应付考试,还能应付面试.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天考了程序设计范式,一开始觉得三个小时三道题不是有手就行,后来发现我太天真了.&lt;/p&gt;
&lt;p&gt;第一道题是leetcode2002,一道关于不相交回文子串的中级题,我硬是没想到用dfs做,可能是一个月没碰算法生疏了吧,&lt;br /&gt;
第二道题是设计几个角色的类,考察多态和继承</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-03 考研人数的下降</title>
    <link href="https://revival-of-hope.github.io/2026/01/03/archives-2026-01-03-%E6%84%9F%E6%83%B3/"/>
    <id>https://revival-of-hope.github.io/2026/01/03/archives-2026-01-03-%E6%84%9F%E6%83%B3/</id>
    <published>2026-01-03T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.534Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/archives/2026-01-03/PixPin_2026-01-03_21-30-11.webp" alt="" /></p><p><img src="/images/archives/2026-01-03/PixPin_2026-01-03_21-46-12.webp" alt="" /><br />可以看出来,尽管本科毕业人数越来越多,研究生招生人数越来越多,报考研究生的人数却越来越少,接着看下图<br /><img src="/images/archives/2026-01-03/PixPin_2026-01-03_21-56-44.webp" alt="" /><br /><img src="/images/archives/2026-01-03/PixPin_2026-01-03_21-57-46.webp" alt="" /><br />疫情的影响太大了,大家都开始捂住钱包,不会再去做大胆的投资了,因此收入较稳定的餐饮业扶摇直上,而旅游业直到现在也未必恢复了元气.<br /><img src="/images/archives/2026-01-03/PixPin_2026-01-03_22-07-44.webp" alt="" /><br />越来越多的人选择去找一些稳定的工作如公务员,医护人员,不愿意去创业了.</p><p>顺带一提还有战败cg,尽管没有今年的数据,但我相信降幅不会相差太多<br /><img src="/images/archives/2026-01-03/PixPin_2026-01-03_21-50-15.webp" alt="" /></p><blockquote><p>这也是普通人的无奈吧,尽管身处这个时代,却连发生了什么都难以把握,只能隐约感觉到大环境不好,却找不到合理的数据来帮自己掌握一点点情况,连知情权也被剥夺,不知道下一步要怎么走,迷茫的在原地打转,只好依着惯例提心吊胆的生活,提不上享受生活,只看得见压抑和悲哀,失去了相信他人的胆量,失去了期盼明天的幸福,只是靠本分承担着责任,不是为了自己,而是为了亲人</p></blockquote><p>很早就想要拿日本跟本国做一个对比了,尽管人口基数差的很离谱,但以前的日本或许就是现在的我们,现在这里预告提醒我自己一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/archives/2026-01-03/PixPin_2026-01-03_21-30-11.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/archives/2026-01-03/PixPin_2026</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-02 离散数学整理-图论</title>
    <link href="https://revival-of-hope.github.io/2026/01/02/archives-2025-2026-01-02-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E5%9B%BE%E8%AE%BA/"/>
    <id>https://revival-of-hope.github.io/2026/01/02/archives-2025-2026-01-02-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E5%9B%BE%E8%AE%BA/</id>
    <published>2026-01-02T00:00:00.000Z</published>
    <updated>2026-02-01T03:53:25.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的基本概念"><a class="markdownIt-Anchor" href="#图的基本概念"></a> 图的基本概念</h1><h2 id="有向图"><a class="markdownIt-Anchor" href="#有向图"></a> 有向图</h2><ul><li><code>&lt;V,E&gt;</code>（<code>v = vertex(节点)</code>，<code>e = edge(边)</code>）</li><li>平凡图：只有一个 <code>v</code>，没有 <code>e</code> 的图</li><li>n 阶图：<code>n</code> 为节点数</li><li>邻接：有向边起点邻接到终点，故邻接矩阵中第 <code>n</code> 行为第 <code>n</code> 个节点作为起点，第 <code>n</code> 列为第 <code>n</code> 个节点作为终点，以此统计出度和入度</li></ul><hr /><h2 id="子图"><a class="markdownIt-Anchor" href="#子图"></a> 子图</h2><ul><li>真子图：与原图不一样就行</li><li>生成子图：节点数一样就行，边可以比原图连的少，但不能自己加边</li><li>导出子图：可以不用到所有节点，但母图中对应用到节点的边都要保留（或者不用到所有边，但对应的节点保留（废话，你都用到边了，那没节点哪来的边））</li></ul><hr /><h2 id="补图"><a class="markdownIt-Anchor" href="#补图"></a> 补图</h2><blockquote><p><strong>补图</strong>：设简单无向图 G = (V, E)，其补图记为 Ḡ = (V, Ē)，其中</p><ul><li>Ē = { {u, v} | u, v ∈ V，u ≠ v，且 {u, v} ∉ E }<br />即在保持顶点集不变的情况下，Ḡ 中的边恰好是 G 中不存在的边。</li></ul></blockquote><hr /><h2 id="同构图"><a class="markdownIt-Anchor" href="#同构图"></a> 同构图</h2><blockquote><p><strong>同构图</strong>：设图 G₁ = (V₁, E₁)，G₂ = (V₂, E₂)，若存在一个双射 f : V₁ → V₂，使得</p><ul><li>对任意 u, v ∈ V₁，{u, v} ∈ E₁ 当且仅当 {f(u), f(v)} ∈ E₂，</li></ul><p>则称 G₁ 与 G₂ 同构，记为 G₁ ≅ G₂。</p></blockquote><ul><li>顶点数相同，边数相同，度数序列相同,但这只是必要条件，充分条件只能用瞪眼法了</li></ul><hr /><h2 id="连通性"><a class="markdownIt-Anchor" href="#连通性"></a> 连通性</h2><h3 id="回路与通路"><a class="markdownIt-Anchor" href="#回路与通路"></a> 回路与通路</h3><blockquote><p>当一条回路中的所有边互不相同时为简单回路，与此相反，有边相同时就是复杂回路，一个由 3 个节点形成的 <code>8</code> 是简单回路<br />若简单回路中除了初始节点和结束节点相同外，其他节点都不相同，则为初级回路，上文的 <code>8</code> 就不是初级回路</p></blockquote><ul><li>初级回路和简单回路<strong>区分</strong>:初级想成是最基本的,结构最为合理,故不会出现重复节点;简单说明是回路就行,要求少一点</li><li>把上面的回路两个字换成通路就可以得到简单通路,复杂通路,初级通路的定义了</li></ul><blockquote><p>如果 <code>u</code> 到 <code>v</code> 存在通路，则称u和v是连通的,在有向图中称 <code>u</code> 可达 <code>v</code>，若图 <code>G</code> 任意两个顶点都连通，则称 <code>G</code> 是<strong>连通图</strong>，注意平凡图也是连通图<br /><strong>连通分支</strong>:图G相互之间不连通的导出子图<br />G的连通分支的数量记为p(G)</p></blockquote><hr /><h3 id="有向图的连通性"><a class="markdownIt-Anchor" href="#有向图的连通性"></a> 有向图的连通性</h3><h4 id="可达与相互可达"><a class="markdownIt-Anchor" href="#可达与相互可达"></a> 可达与相互可达</h4><p>设有向图 D = &lt;V, E&gt;，u, v ∈ V。</p><ul><li><p><strong>u 可达 v</strong>：<br />从 u 到 v 存在一条有向通路。<br />规定：u 到自身总是可达。</p></li><li><p><strong>u 与 v 相互可达</strong>：<br />u 可达 v 且 v 可达 u。</p></li></ul><hr /><ul><li><strong>弱连通</strong></li></ul><blockquote><p>将 D 中所有有向边忽略方向，得到的无向图是连通图。</p></blockquote><ul><li><strong>单向连通</strong></li></ul><blockquote><p>对任意 u, v ∈ V,u 可达 v 或 v 可达 u</p></blockquote><ul><li><strong>强连通</strong></li></ul><blockquote><p>对任意 u, v ∈ V,u 与 v 相互可达</p></blockquote><h3 id="割集"><a class="markdownIt-Anchor" href="#割集"></a> 割集</h3><p>设 G = (V, E) 为连通图。</p><blockquote><p><strong>边割集</strong>：设 C ⊆ E，若</p><ul><li>图 G − C 不连通；</li><li>对任意 e ∈ C，G − (C \ {e}) 仍连通；<br />则称 C 为 G 的边割集。</li></ul></blockquote><ul><li>即C已经是能够让G不连通的最小边集合了,若C只有一条边e,称e为割边或桥</li></ul><hr /><blockquote><p><strong>点割集</strong>：设 S ⊆ V，若</p><ul><li>图 G − S 不连通或退化为单点图；</li><li>对任意 v ∈ S，G − (S \ {v}) 仍连通；<br />则称 S 为 G 的点割集。</li></ul></blockquote><ul><li>即S已经是能够让G不连通的最小点集合了,若S只有一个顶点v,称v为割点</li></ul><h3 id="分量与割"><a class="markdownIt-Anchor" href="#分量与割"></a> 分量与割</h3><h4 id="连通分量"><a class="markdownIt-Anchor" href="#连通分量"></a> 连通分量</h4><ul><li><p><strong>无向图的连通分量</strong><br />无向图 G 的一个极大连通子图称为 G 的一个连通分量（或连通分支）。</p><ul><li>每一个顶点和每一条边都属于唯一的一个连通分量</li><li>连通图只有一个连通分量，即其自身</li><li>非连通无向图有多个连通分量</li></ul></li><li><p><strong>有向图的强连通分量</strong><br />有向图中的强连通分量是其极大的强连通子图。</p><ul><li>强连通图只有一个强连通分量，即其自身</li><li>非强连通的有向图有多个强连通分量</li></ul></li></ul><hr /><h4 id="点割与点连通度"><a class="markdownIt-Anchor" href="#点割与点连通度"></a> 点割与点连通度</h4><ul><li><p><strong>割点集</strong><br />在连通图 G 中，一个由顶点组成的集合，若从 G 中删除这些顶点后图变得不连通，则称该集合为割点集。</p></li><li><p><strong>点连通度</strong><br />点连通度 κ(G) 定义为割点集中顶点数的最小值。</p></li><li><p><strong>k-点连通图</strong><br />若图 G 可以在删除 k 个顶点后变得不连通，但不能在删除 k−1 个顶点后变得不连通，则称 G 为 k-点连通图。<br />特别地，阶数为 n 的完全图是 (n−1)-点连通的。</p></li></ul><hr /><h4 id="局部连通度"><a class="markdownIt-Anchor" href="#局部连通度"></a> 局部连通度</h4><ul><li><p><strong>u, v 的割点集</strong><br />对一对顶点 u, v，若删除某个顶点集合后使 u 与 v 不连通，则该集合称为 u, v 的割点集。</p></li><li><p><strong>局部连通度</strong><br />κ(u, v) 表示使 u 与 v 不连通的最小割点集的大小。</p></li><li><p><strong>性质</strong></p><ul><li>在无向图中，κ(u, v) = κ(v, u)</li><li>除完全图外，κ(G) 等于所有不相邻顶点对 u, v 的 κ(u, v) 的最小值</li></ul></li></ul><hr /><h4 id="边割与边连通度"><a class="markdownIt-Anchor" href="#边割与边连通度"></a> 边割与边连通度</h4><ul><li><p><strong>桥</strong><br />在图 G 中，删除某一条边后图变得不连通，则该边称为桥。</p></li><li><p><strong>割边集</strong><br />一个由边组成的集合，若删除这些边后图变得不连通，则称为割边集。</p></li><li><p><strong>边连通度</strong><br />λ(G) 表示最小割边集的大小。</p></li><li><p><strong>局部边连通度</strong><br />λ(u, v) 表示使 u 与 v 不连通的最小割边集的大小。</p></li><li><p><strong>k-边连通图</strong><br />若 λ(G) ≥ k，则称图 G 为 k-边连通图。</p></li></ul><hr /><h4 id="连通度之间的关系"><a class="markdownIt-Anchor" href="#连通度之间的关系"></a> 连通度之间的关系</h4><ul><li>设 δ(G) 为图 G 的最小度，则有不等式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">κ(G) ≤ λ(G) ≤ δ(G)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>极大连通图</strong></li><li>若 κ(G) = δ(G)，称 G 为极大连通图</li><li>若 λ(G) = δ(G)，称 G 为极大边连通图</li></ul><h2 id="图的矩阵表示"><a class="markdownIt-Anchor" href="#图的矩阵表示"></a> 图的矩阵表示</h2><hr /><h3 id="无向图的关联矩阵"><a class="markdownIt-Anchor" href="#无向图的关联矩阵"></a> 无向图的关联矩阵</h3><blockquote><p><strong>定义</strong>：设无向图 G = (V, E)，|V| = n，|E| = m。<br />无向图的关联矩阵是一个 n × m 的 0-1 矩阵 M，其中</p><ul><li>M[i][j] = 1或2，当且仅当顶点 v_i 与边 e_j 关联；</li><li>否则 M[i][j] = 0。</li></ul></blockquote><ul><li>关联即顶点作为该边的起点或者终点出现次数,当出现自环时关联次数为2</li><li>每一列都恰好有两个1或一个2</li><li>第i行元素之和为vi的度数,所有元素之和为2m<br /><strong>例</strong>：</li><li>V = {v1, v2, v3, v4}</li><li>E = {<br />e1 = {v1, v2},<br />e2 = {v1, v3},<br />e3 = {v2, v3},<br />e4 = {v4, v4}<br />}</li></ul><table><thead><tr><th></th><th>e1</th><th>e2</th><th>e3</th><th>e4</th></tr></thead><tbody><tr><td>v1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>v2</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>v3</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>v4</td><td>0</td><td>0</td><td>0</td><td>2</td></tr></tbody></table><hr /><h3 id="有向图的关联矩阵"><a class="markdownIt-Anchor" href="#有向图的关联矩阵"></a> 有向图的关联矩阵</h3><blockquote><p><strong>定义</strong>：设无环有向图 G = (V, E)，|V| = n，|E| = m。<br />有向图的关联矩阵是一个 n × m 的矩阵 M，其中</p><ul><li>M[i][j] = -1，若边 e_j 从 v_i 出发；</li><li>M[i][j] = 1，若边 e_j 指向 v_i；</li><li>否则 M[i][j] = 0。</li></ul></blockquote><ul><li>每一列都有一个-1和1</li></ul><p><strong>例</strong>：</p><ul><li>V = {v1, v2, v3, v4}</li><li>E = {<br />e1: v1 → v2,<br />e2: v1 → v3,<br />e3: v2 → v4,<br />e4: v3 → v4<br />}</li></ul><table><thead><tr><th></th><th>e1</th><th>e2</th><th>e3</th><th>e4</th></tr></thead><tbody><tr><td>v1</td><td>-1</td><td>-1</td><td>0</td><td>0</td></tr><tr><td>v2</td><td>1</td><td>0</td><td>-1</td><td>0</td></tr><tr><td>v3</td><td>0</td><td>1</td><td>0</td><td>-1</td></tr><tr><td>v4</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><hr /><h3 id="有向图的邻接矩阵"><a class="markdownIt-Anchor" href="#有向图的邻接矩阵"></a> 有向图的邻接矩阵</h3><blockquote><p><strong>定义</strong>：设有向图 G = (V, E)，|V| = n。<br />有向图的邻接矩阵是一个 n × n 的矩阵 A，其中</p><ul><li>A[i][j] = 1，表示存在从 v_i 到 v_j 的有向边；</li><li>否则 A[i][j] = 0。</li></ul></blockquote><ul><li>所有元素之和等于边数</li></ul><p><strong>例</strong>：</p><ul><li>v1 → v2，v1 → v3，v2 → v4，v3 → v4</li></ul><table><thead><tr><th></th><th>v1</th><th>v2</th><th>v3</th><th>v4</th></tr></thead><tbody><tr><td>v1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>v2</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>v3</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>v4</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><hr /><h3 id="有向图的可达矩阵"><a class="markdownIt-Anchor" href="#有向图的可达矩阵"></a> 有向图的可达矩阵</h3><blockquote><p><strong>定义</strong>：设有向图 G = (V, E)，|V| = n。<br />可达矩阵是一个 n × n 的矩阵 R，其中</p><ul><li>R[i][j] = 1，表示从 v_i 出发存在一条路径可到达 v_j；</li><li>否则 R[i][j] = 0。</li></ul></blockquote><ul><li>由于顶点到自身都是可达的,故可达矩阵对角线上的元素恒为1<br /><strong>例</strong>：<br />基于上述有向图</li></ul><table><thead><tr><th></th><th>v1</th><th>v2</th><th>v3</th><th>v4</th></tr></thead><tbody><tr><td>v1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>v2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>v3</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>v4</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><h2 id="着色问题"><a class="markdownIt-Anchor" href="#着色问题"></a> 着色问题</h2><blockquote><p><em>着色问题</em>：设 G = (V, E) 为无向无环图，给每个顶点分配一种颜色，使得</p><ul><li>若 {u, v} ∈ E，则 u 与 v 的颜色不同,即<strong>相邻顶点颜色不同</strong><br />记使用的最少颜色数为k,称G为k-可着色的</li></ul></blockquote><blockquote><p><strong>Welsh–Powell 算法</strong>：<br />是一种求图顶点着色的启发式算法，其基本思想是优先为度数大的顶点着色。</p></blockquote><p><strong>算法步骤</strong>：</p><ol><li>将图中所有顶点按度数从大到小排序（若度数相同，可任意排列）；</li><li>取尚未着色的第一个顶点，赋予一种新颜色；</li><li>在剩余未着色顶点中，按排序顺序选择与已着该颜色顶点均不相邻的顶点，赋予同一颜色；</li><li>重复步骤 2–3，直到所有顶点均被着色。</li></ol><hr /><p><strong>例题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">设  </span><br><span class="line">V = &#123;v1, v2, v3, v4, v5&#125;  </span><br><span class="line">E = &#123; &#123;v1,v2&#125;, &#123;v1,v3&#125;, &#123;v1,v4&#125;, &#123;v2,v3&#125;, &#123;v3,v4&#125;, &#123;v4,v5&#125; &#125;</span><br><span class="line"></span><br><span class="line">各顶点度数：  </span><br><span class="line">deg(v1)=3，deg(v3)=3，deg(v4)=3，deg(v2)=2，deg(v5)=1  </span><br><span class="line"></span><br><span class="line">排序结果：  </span><br><span class="line">v1, v3, v4, v2, v5  </span><br><span class="line"></span><br><span class="line">着色过程：  </span><br><span class="line">- 颜色 1：v1，v5  </span><br><span class="line">- 颜色 2：v3  </span><br><span class="line">- 颜色 3：v4  </span><br><span class="line">- 颜色 4：v2  </span><br><span class="line"></span><br><span class="line">因此该算法得到 G 为 4-可着色（不一定是最小色数）。</span><br></pre></td></tr></table></figure><h3 id="练手"><a class="markdownIt-Anchor" href="#练手"></a> 练手</h3><p><img src="/images/archives/2026-01-02/PixPin_2026-01-05_18-46-51.webp" alt="" /></p><hr /><p><strong>答案</strong><br /><img src="/images/archives/2026-01-02/PixPin_2026-01-05_18-59-15.webp" alt="" /></p><h1 id="特殊的图"><a class="markdownIt-Anchor" href="#特殊的图"></a> 特殊的图</h1><h2 id="二部图"><a class="markdownIt-Anchor" href="#二部图"></a> 二部图</h2><blockquote><p>把一个图的顶点划分为两个不相交子集，使得每一条边都分别连接两个集合中的顶点，如果存在这样的划分，则此图为一个二部图</p><p>[深入理解](htt ps://blog.csdn.net/qq_26822029/article/details/90382581)<br />若 <code>G</code> 中无长度为奇数的回路，则无向图 <code>G</code> 是二部图<br /><a href="https://www.zhihu.com/question/474576285">证明</a></p></blockquote><ul><li>也就是说各自的子集中两个顶点之间都没有边</li></ul><h3 id="匹配"><a class="markdownIt-Anchor" href="#匹配"></a> 匹配</h3><blockquote><p><strong>匹配（Matching）</strong><br />在无向图 <code>G = (V, E)</code> 中，若边集 <code>M ⊆ E</code> 满足：<br />任意两条边不共享公共顶点(即<strong>不相连</strong>)，则称 <code>M</code> 为图 <code>G</code> 的一个匹配。</p></blockquote><blockquote><p><strong>极大匹配（Maximal Matching）</strong><br />若匹配 <code>M</code> 满足：<br />在图中不能再加入任何一条边而仍保持是匹配，则称 <code>M</code> 为极大匹配。</p></blockquote><blockquote><p><strong>最大匹配（Maximum Matching）</strong><br />在图 <code>G</code> 的所有匹配中，边数最多的匹配称为最大匹配。</p></blockquote><ul><li><strong>匹配数</strong><br />最大匹配 <code>M</code> 中边的条数称为匹配数</li></ul><hr /><blockquote><p><strong>完美匹配（Perfect Matching）</strong><br />若匹配 <code>M</code> 覆盖图中所有顶点，即每个顶点都恰好与一条匹配边相关联，<br />则称 <code>M</code> 为完美匹配。</p></blockquote><blockquote><p><strong>完备匹配（Complete Matching）</strong><br />在二部图 <code>G = (X, Y, E)</code> 中，若存在一个匹配使得 <code>X</code> 中的每个顶点<br />都与 <code>Y</code> 中某个顶点匹配，则称该匹配为完备匹配。(<em>当|X|&lt;|Y|时允许存在有顶点不匹配的情况</em>)</p></blockquote><hr /><h3 id="hall-定理及其引申"><a class="markdownIt-Anchor" href="#hall-定理及其引申"></a> Hall 定理及其引申</h3><blockquote><p><strong>Hall 定理（婚姻定理）</strong><br />设 <code>G = (X, Y, E)</code> 为二部图。<br />存在一个覆盖 <code>X</code> 的完备匹配，当且仅当对 <code>X</code> 的任意子集 <code>S</code>，<br /><code>S</code> 的邻接顶点集合 <code>N(S)</code> 满足：</p></blockquote><ul><li><code>|N(S)| ≥ |S|</code></li></ul><hr /><blockquote><p><strong>Hall 定理的等价表述</strong><br />二部图 <code>G = (X, Y, E)</code> 中存在完备匹配<br />当且仅当 <code>X</code> 的任意子集都不“缺少”可匹配的邻接顶点。</p></blockquote><ul><li>用人话说,当|X|&lt;=|Y|时需要保证X中任意k个顶点至少邻接Y中k个顶点</li></ul><blockquote><p><strong>Hall 定理的推论</strong><br />设 <code>G = (X, Y, E)</code> 为二部图，若存在t&gt;0,使得:</p><ul><li>X中每个顶点至少关联t条边</li><li>Y中每个顶点至多关联t条边<br />则称G中存在X到Y的完备匹配</li></ul></blockquote><ul><li>显然这是一个很强烈的充分条件而非必要条件</li></ul><h2 id="欧拉图"><a class="markdownIt-Anchor" href="#欧拉图"></a> 欧拉图</h2><blockquote><p><strong>欧拉回路</strong>:通过图中所有边且每边仅通过一次的回路，具有欧拉回路的图称为欧拉图（Euler Graph）</p></blockquote><ul><li>将回路改为通路就得到了欧拉通路的定义</li></ul><blockquote><p>无向图中：</p><ul><li>有欧拉回路：当且仅当 <code>G</code> 是连通图且无奇度顶点</li><li>有欧拉通路但没有欧拉回路：当且仅当 <code>G</code> 是连通图且恰好有两个奇度顶点</li></ul></blockquote><ul><li>当然有欧拉回路就有欧拉通路,少连一条边就是了</li></ul><blockquote><p>有向图中：</p><ul><li>有欧拉回路：当且仅当 <code>G</code> 是连通图且每个顶点的入度等于出度<br />直观上很好理解，证明还是算了吧</li></ul></blockquote><hr /><h2 id="哈密顿图"><a class="markdownIt-Anchor" href="#哈密顿图"></a> 哈密顿图</h2><blockquote><p>通过图 <code>G</code> 的每个结点一次且仅一次的通路（回路），就是<strong>哈密顿通路</strong>（回路），存在哈密顿回路的图就是哈密顿图</p></blockquote><h3 id="判定方法"><a class="markdownIt-Anchor" href="#判定方法"></a> 判定方法</h3><blockquote><p>若n阶有向图G对应的无向图中含有生成子图Kn(即生成子图为完全图),则G中存在哈密顿通路</p></blockquote><ul><li>这个挺显然的,如果每个顶点间都有连线,怎么都能把所有顶点连接起来</li></ul><hr /><h2 id="平面图"><a class="markdownIt-Anchor" href="#平面图"></a> 平面图</h2><blockquote><p>若 <code>G</code> 能画在平面上而不出现边交叉，则为<strong>平面图</strong>，画出的图称为 <code>G</code> 的平面嵌入</p></blockquote><blockquote><p><strong>面</strong>:设G是一个平面嵌入,G<br />的边将整个平面划分成若干区域,每个区域称为G的一个面,其中面积无限的区域称为<em>无限面</em>或<em>外部面</em>,面积有限的区域称为<em>有限面</em>或<em>内部面</em></p></blockquote><ul><li><em>nnd图论这一堆中文别名就不能统一一下,自己研究起来不麻烦吗</em></li></ul><blockquote><p>包围面R的所有边构成的回路称为R的边界,边界的长度称为R的次数,记为deg®</p></blockquote><ul><li>注意若外部面包含割边,需要沿着割边的两侧绕行形成回路,故会计算两次</li><li>在简单平面图中，每个面的次数 ≥ 3 （因为不存在长度为 1 或 2 的回路）。</li><li>各面次数之和等于边数的 2 倍：</li><li><strong>平面图各面的次数之和等于边数的2倍</strong></li></ul><blockquote><p>证明<br />在平面图中，每一条边都有两侧：</p><ul><li>要么分别邻接两个不同的面；</li><li>要么作为桥或割边，在同一个面边界上出现两次</li></ul><p>无论哪种情况，<br /><strong>每一条边都会被恰好计入两个面的次数中</strong>。</p></blockquote><h3 id="极大平面图"><a class="markdownIt-Anchor" href="#极大平面图"></a> 极大平面图</h3><blockquote><p>若G是简单平面图, 且在任意两个不相邻的顶点<br />之间加一条新边所得图为非平面图, 则称G为极大平面图</p></blockquote><ul><li>极大平面图是连通的 (若不连通则可以继续加边,矛盾)</li><li>设G为n(n3)阶简单图, G为极大平面图的充分必要条件是, G每个面的次数均为3.</li></ul><h3 id="欧拉公式"><a class="markdownIt-Anchor" href="#欧拉公式"></a> 欧拉公式</h3><blockquote><p>对于连通平面图有欧拉公式：<code>n + r - 2 = m</code>，其中 <code>n</code> 为顶点数，<code>m</code> 为边数，<code>r</code> 为面数（显然边数总是最多的一方）</p></blockquote><ul><li>记住有个两个数相加减2等于另一个数,然后立方体中边数为12,顶点数为8,面数为6,就能记住欧拉公式</li></ul><hr /><h1 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h1><p><strong>定义</strong></p><blockquote><p>不含回路的连通无向图称为树，平凡图(即一个点)称为平凡树,度数为 <code>1</code> 的顶点称为树叶，度数大于 <code>1</code> 的称为分支点</p></blockquote><ul><li><strong>注意!!!</strong><br /><strong>关于二叉树本教材默认第一层高度为0,第二层高度为1,以此类推!!!</strong></li></ul><h2 id="生成树"><a class="markdownIt-Anchor" href="#生成树"></a> 生成树</h2><p>生成树</p><blockquote><p><code>G</code> 是无向连通图，<code>T</code> 是 <code>G</code> 的生成子图且是树，则 <code>T</code> 为 <code>G</code> 的生成树（即连接了所有节点），<code>G</code> 在 <code>T</code> 中的边称为 <code>T</code> 的树枝，不在 <code>T</code> 中的边称为 <code>T</code> 的弦，<code>T</code> 中所有弦生成的导出子图称为 <code>T</code> 的余树(不一定是树,也未必连通)</p></blockquote><h3 id="定理任何无向连通图g都有生成树"><a class="markdownIt-Anchor" href="#定理任何无向连通图g都有生成树"></a> 定理:任何无向连通图G都有生成树</h3><blockquote><p>证明:若G无回路,则本身就是生成树,若含有回路,则删去回路上任意一条边,直到图中不再有回路,这不影响G的连通性,从而得到生成树</p></blockquote><h3 id="推论n阶无向连通图g的边数大于等于n-1"><a class="markdownIt-Anchor" href="#推论n阶无向连通图g的边数大于等于n-1"></a> 推论:n阶无向连通图G的边数大于等于n-1</h3><blockquote><p>证明:其生成树的边数为n-1</p></blockquote><h3 id="基本回路和基本割集"><a class="markdownIt-Anchor" href="#基本回路和基本割集"></a> 基本回路和基本割集</h3><blockquote><p><strong>基本回路（Fundamental Circuit）</strong><br />设 <code>T</code> 是连通图 <code>G</code> 的一棵生成树。<br />对任意一条不属于 <code>T</code> 的边 <code>e</code>(弦)，将 <code>e</code> 加入 <code>T</code> 中，<br />则在 <code>T ∪ &#123;e&#125;</code> 中产生且<strong>唯一</strong>的回路，称为关于生成树 <code>T</code> 的一个基本回路。</p></blockquote><hr /><blockquote><p><strong>基本回路系统</strong><br />由生成树 <code>T</code> 中<strong>所有弦</strong>各自对应的基本回路所组成的集合，<br />称为图 <code>G</code> 的一个基本回路系统。</p></blockquote><hr /><blockquote><p><strong>基本割集（Fundamental Cutset）</strong><br />设 <code>T</code> 是连通图 <code>G</code> 的一棵生成树。<br />对任意一条属于 <code>T</code> 的边 <code>e</code>，从 <code>T</code> 中删去 <code>e</code>，<br />生成树被分成两个连通分量。<br />在原图 <code>G</code> 中，所有连接这两个分量的边构成的集合，<br />称为关于生成树 <code>T</code> 和边 <code>e</code> 的基本割集。</p></blockquote><hr /><blockquote><p><strong>基本割集系统</strong><br />由生成树 <code>T</code> 中<strong>每一条树边</strong>所对应的基本割集组成的集合，<br />称为图 <code>G</code> 的一个基本割集系统。</p></blockquote><hr /><ul><li><strong>加一条非树边 → 一个基本回路</strong></li><li><strong>删一条树边 → 一个基本割集</strong></li><li>基本回路数 = 非树边数  (m-n+1)</li><li>基本割集数 = 树边数    (n-1)</li></ul><hr /><p><strong>真整理完了发现确实是文科,基本上所有例题只要懂了概念就能做,唯一难的地方就是证明题,很多证明想破脑袋都想不到,只好继续背书了</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图的基本概念&quot;&gt;&lt;/a&gt; 图的基本概念&lt;/h1&gt;
&lt;h2 id=&quot;有向图&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#有向图&quot;&gt;&lt;/a&gt; 有向图&lt;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2026-01-01 浏览器实用插件</title>
    <link href="https://revival-of-hope.github.io/2026/01/01/dynamic-2026-01-01-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>https://revival-of-hope.github.io/2026/01/01/dynamic-2026-01-01-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</id>
    <published>2026-01-01T00:00:00.000Z</published>
    <updated>2026-01-01T09:25:11.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gitzip-for-github"><a class="markdownIt-Anchor" href="#gitzip-for-github"></a> <a href="https://microsoftedge.microsoft.com/addons/detail/gitzip-for-github/iemilfmlaliblejogfofhmjbfiaiegnd">GitZip for github</a></h1><h1 id="octotree"><a class="markdownIt-Anchor" href="#octotree"></a> <a href="https://www.octotree.io/">Octotree</a></h1><h1 id="pixiv-downloader"><a class="markdownIt-Anchor" href="#pixiv-downloader"></a> <a href="https://github.com/xuejianxianzun/PixivBatchDownloader">Pixiv Downloader</a></h1><h1 id="competitive-companion-customed"><a class="markdownIt-Anchor" href="#competitive-companion-customed"></a> <a href="https://github.com/lnw143/competitive-companion-customized">Competitive Companion customed</a></h1><h1 id="lingvanex"><a class="markdownIt-Anchor" href="#lingvanex"></a> <a href="https://microsoftedge.microsoft.com/addons/detail/lingvanex-%E7%BF%BB%E8%AF%91%E5%92%8C%E8%AF%8D%E5%85%B8%E3%80%82%E5%97%93%E9%9F%B3/pppgidljpojmcjehgdnfmmffbhifdloh">Lingvanex</a></h1><h1 id="unpaywall"><a class="markdownIt-Anchor" href="#unpaywall"></a> <a href="https://chromewebstore.google.com/detail/unpaywall/iplffkdpngmdjhlpjmppncnlhomiipha">unpaywall</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gitzip-for-github&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#gitzip-for-github&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://microsoftedge.microsoft.com/addons/d</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2026-01-01 离散数学整理-群论</title>
    <link href="https://revival-of-hope.github.io/2026/01/01/archives-2025-2026-01-01-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E7%BE%A4%E8%AE%BA/"/>
    <id>https://revival-of-hope.github.io/2026/01/01/archives-2025-2026-01-01-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86-%E7%BE%A4%E8%AE%BA/</id>
    <published>2026-01-01T00:00:00.000Z</published>
    <updated>2026-01-12T01:21:11.294Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113979489780353&bvid=BV1H2NoeiE1K&cid=28736228422&p=1"        width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe><p>由于学校规定的那本臭不可闻的ts离散教材已经沉浸在自己的优越感里了,找不到一点点系统性,只好我自己从头开始梳理,大多数定义都是直接引用的wiki</p><h2 id="运算律"><a class="markdownIt-Anchor" href="#运算律"></a> 运算律</h2><h3 id="结合律"><a class="markdownIt-Anchor" href="#结合律"></a> 结合律</h3><ul><li><code>a+(b+c)=(a+b)+c</code><br />结合律是群论中最为重要的部分,只有满足结合律的代数系统才可以进行两项以上的计算,例如计算a+b+c.如果(a+b)+c!=q+(b+c),那就无法得出唯一的结果了</li></ul><h3 id="交换律"><a class="markdownIt-Anchor" href="#交换律"></a> 交换律</h3><ul><li><code>a+b=b+a</code><br />很多代数系统不满足交换律,例如矩阵乘法</li></ul><h3 id="分配律"><a class="markdownIt-Anchor" href="#分配律"></a> 分配律</h3><p>如果<em>对+满足以下式子,则称</em>对+满足分配律</p><ul><li><code>a*(b+c)=a*b+a*c</code></li></ul><h3 id="幂等律"><a class="markdownIt-Anchor" href="#幂等律"></a> 幂等律</h3><ul><li><code>a+a=a</code><br />在幂等律成立的代数系统中，对同一元素重复运算不会产生新的结果，常见于集合的并运算与交运算中。</li></ul><h3 id="吸收律"><a class="markdownIt-Anchor" href="#吸收律"></a> 吸收律</h3><p>需要同时满足下面两个式子</p><ul><li><code>a+(a*b)=a</code></li><li><code>a*(a+b)=a</code></li></ul><h3 id="消去律"><a class="markdownIt-Anchor" href="#消去律"></a> 消去律</h3><p><img src="/images/archives/2026-01-01/PixPin_2026-01-01_15-47-28.webp" alt="例题" /><br />逆元和结合律保证了消去律的存在</p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><img src="/images/archives/2026-01-01/PixPin_2026-01-01_10-35-05.webp" alt="" /></p><h2 id="代数系统"><a class="markdownIt-Anchor" href="#代数系统"></a> 代数系统</h2><h3 id="概览"><a class="markdownIt-Anchor" href="#概览"></a> 概览</h3><p>半群满足加法,群还满足减法,环还满足乘法,域还满足除法<br /><img src="/images/archives/2026-01-01/PixPin_2026-01-02_23-06-11.webp" alt="" /></p><h3 id="子代数"><a class="markdownIt-Anchor" href="#子代数"></a> 子代数</h3><p>子代数与原代数系统含有相同的代数常数,且对于所有运算都是封闭的</p><h3 id="封闭性"><a class="markdownIt-Anchor" href="#封闭性"></a> 封闭性</h3><p><img src="/images/archives/2026-01-01/PixPin_2026-01-02_23-12-44.webp" alt="" /></p><blockquote><p>封闭性其实是非常重要的性质,保证了集合内的运算结果保留在集合内,而不会出现任何特殊情况,而由于作为整个群论基础的半群具有封闭性,故下文讨论到的所有代数系统都具有封闭性.</p></blockquote><h3 id="同态和同构"><a class="markdownIt-Anchor" href="#同态和同构"></a> 同态和同构</h3><p><img src="/images/archives/2026-01-01/PixPin_2026-01-02_22-38-55.webp" alt="" /></p><p>如果同态满足单射,称为单同态,满足满射,称为满同态,满足双射,则称为同构</p><h4 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h4><p><img src="/images/archives/2026-01-01/PixPin_2026-01-01_14-30-58.webp" alt="" /><br />通过这个例题可以明确几点关于映射的知识</p><ul><li>没参与映射的元素不会计入原像集合,例如这里的0在原像集合中,故一定有像存在</li><li>双射时像和原像一定是一一对应的</li></ul><h3 id="半群"><a class="markdownIt-Anchor" href="#半群"></a> 半群</h3><p>满足结合律的封闭代数系统称为半群</p><p>例子: 自然数下的加法</p><p>含有幺元的半群称为独异点(垃圾翻译)</p><h3 id="群"><a class="markdownIt-Anchor" href="#群"></a> 群</h3><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p>存在一个数e,使得对于集合S内所有的元素a都满足以下公式,则称e为集合S的幺元</p><ul><li><code>e+a=a,a+e=a</code></li></ul><p>若一个半群S存在幺元e,且对于集合S内所有的元素a都有逆元b满足以下公式,则称S为群</p><ul><li><code>b+a=a+b=e</code></li></ul><ol><li>由于零元不存在逆元,故群都不含零元</li><li>除单位元素e外群不存在等幂元素</li></ol><h4 id="群的阶数"><a class="markdownIt-Anchor" href="#群的阶数"></a> 群的阶数</h4><p>群G中元素的个数称为阶数,记作|G|,若个数有限,称为有限群,否则为无限群,若G只有一个单位元素e,则称为平凡群</p><h4 id="交换群阿贝尔群"><a class="markdownIt-Anchor" href="#交换群阿贝尔群"></a> 交换群(阿贝尔群)</h4><blockquote><p>满足交换律的群称为交换群</p></blockquote><h4 id="klein四元群"><a class="markdownIt-Anchor" href="#klein四元群"></a> Klein四元群</h4><p><img src="/images/archives/2026-01-01/PixPin_2026-01-01_15-36-07.webp" alt="" /></p><blockquote><p>Klein四元群G的运算具有以下特点:</p></blockquote><ol><li>e为G中的幺元</li><li>.是可交换的</li><li>任何G中元素与自己运算的结果都为e</li><li>除幺元外任意两个元素的运算结果都等于另一个元素</li></ol><blockquote><p>可以看出Klein四元群既是交换群又是有限群</p></blockquote><h4 id="子群"><a class="markdownIt-Anchor" href="#子群"></a> 子群</h4><p>显然只要是群S的子集,并满足群的性质就可以称为子群,重点在于证明一个子集是一个群的子群<br /><img src="/images/archives/2026-01-01/PixPin_2026-01-02_23-22-23.webp" alt="" /></p><blockquote><p>关键在于一点点补全群的定义,首先找到幺元,接着找到逆元存在,由于集合被划分,故原来的封闭性可能被破坏,还需要证明封闭性,而结合律不用证明,因为所有半群的子集都是满足结合律的</p></blockquote><h4 id="循环群"><a class="markdownIt-Anchor" href="#循环群"></a> 循环群</h4><p><img src="/images/archives/2026-01-01/PixPin_2026-01-02_22-54-02.webp" alt="定义" /></p><ul><li>这里的幂次不一定是乘方,只是表示对g进行多次运算</li><li>生成元g与群G的阶数是一样的,无限循环群的生成元是a和a^-1,而n阶循环群的生成元是与a所有与n互质的幂次(互质:最大公约数为1,因此1也包含在互质的幂次里)</li><li>从定义可以知道循环群一定是交换群</li><li><blockquote><p>由于要满足封闭性,故n阶循环群子群的生成元的幂次一定都是n的因数,可以把g的n次方计为幺元e,这个刚看到时很难理解,但如果没有幺元,那么就可以一直运算下去,就不是有限群了,故一定存在一个边界保证阶数不超过n,那么把g的n次方看作e就非常合适了.</p></blockquote></li></ul><h4 id="置换群"><a class="markdownIt-Anchor" href="#置换群"></a> 置换群</h4><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">置换通常写作轮换形式。例如，在轮换表示法中，给定集合  </span><br><span class="line">M = &#123;1, 2, 3, 4&#125;。</span><br><span class="line"></span><br><span class="line">设 M 的一个置换 g 满足：</span><br><span class="line"><span class="bullet">-</span> g(1) = 2  </span><br><span class="line"><span class="bullet">-</span> g(2) = 4  </span><br><span class="line"><span class="bullet">-</span> g(4) = 1  </span><br><span class="line"><span class="bullet">-</span> g(3) = 3  </span><br><span class="line"></span><br><span class="line">则该置换可以写作：</span><br><span class="line">(1, 2, 4)(3)</span><br><span class="line"></span><br><span class="line">或者更常见地写作：</span><br><span class="line">(1, 2, 4)</span><br><span class="line"></span><br><span class="line">因为元素 3 在该置换下保持不变。</span><br><span class="line"></span><br><span class="line">当对象用单个字母或数字表示时，逗号通常也可以省略，因此也可记作：</span><br><span class="line">(1 2 4)</span><br></pre></td></tr></table></figure><ul><li>涉及集合S中m个不同数的置换称为m阶轮换</li></ul><h3 id="环和域"><a class="markdownIt-Anchor" href="#环和域"></a> 环和域</h3><p>显然wiki上定义的环是真环,乘法有幺元;教材里用的定义是伪环,乘法不含幺元</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个环是一个集合 R，具有两个二元运算（+ 和 ·），分别称为“加法”和“乘法”。</span><br><span class="line"></span><br><span class="line">其中，乘法对加法满足分配律,并且满足以下代数结构条件：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> (R, +) 是一个阿贝尔群  </span><br><span class="line"><span class="bullet">-</span> (R, ·) 是一个半群</span><br></pre></td></tr></table></figure><p><strong>零因子</strong>:</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对所有 (a, b) ∈ R × R， 若当a,b都不为0时存在a × b = 0</span><br><span class="line">则a称为左零因子,b称为右零因子</span><br></pre></td></tr></table></figure><p><strong>证明零因子可以用消去律代替</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">假设 R 中没有零因子。</span><br><span class="line"></span><br><span class="line">已知：</span><br><span class="line">a ≠ 0 </span><br><span class="line">a x b = a x c</span><br><span class="line"></span><br><span class="line">两边相减，得到：</span><br><span class="line">a x (b − c) = 0</span><br><span class="line"></span><br><span class="line">由于 a ≠ 0，</span><br><span class="line">又因为没有零因子，</span><br><span class="line"></span><br><span class="line">只能推出：</span><br><span class="line">b − c = 0</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">b = c</span><br></pre></td></tr></table></figure><ul><li>只有所有非零数相乘都不为0才可以说环不存在零因子,称为无零因子环</li><li>若环R中乘法满足交换律,含有幺元,无零因子,则R称为整环</li><li>若环R至少含有两个元素且含有幺元,无零因子,所有非零元素都存在乘法逆元,则称R为除环</li></ul><blockquote><ul><li>简短说来,环中多了一个对有无零因子的考察,因为如果不满足消去律的话研究这个代数系统就很困难了,而整环中乘法是一个可交换独异点,除环除开零以外是一个群</li></ul></blockquote><blockquote><ul><li>若环R既是整环又是除环,则称R是域</li></ul></blockquote><h3 id="格与布尔代数"><a class="markdownIt-Anchor" href="#格与布尔代数"></a> 格与布尔代数</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">考虑一个偏序集合 (L, ≤)。  </span><br><span class="line">如果对集合 L 中的任意两个元素 a、b，  </span><br><span class="line">它们在 L 中都存在最大下界和最小上界，  </span><br><span class="line">则称 (L, ≤) 是一个格。</span><br><span class="line">(由于偏序符号不好打,这里的小于等于都是偏序符号,表示可比,可比要求两个元素在哈斯图里处于同一分支上)</span><br><span class="line">从这个定义可以看出：</span><br><span class="line">格并不要求像全序集合那样，任意两个元素都必须可比；</span><br><span class="line">但仍要求任意两个元素都具有最大下界和最小上界。</span><br></pre></td></tr></table></figure><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在这里，取 a、b 的最大下界的运算记作  </span><br><span class="line">a ∧ b；</span><br><span class="line"></span><br><span class="line">取 a、b 的最小上界的运算记作  </span><br><span class="line">a ∨ b。</span><br></pre></td></tr></table></figure><hr /><blockquote><ul><li>格和全序集的区别:<br />简单画哈斯图便可以知道,全序集是一条线,而格可以有多个分支,只要分支最后能汇合到一点就可以</li></ul></blockquote><blockquote><ul><li>格满足交换律,结合律,幂等律和吸收律,这些从定义来看就很好理解,故无需证明</li></ul></blockquote><h4 id="补充概念"><a class="markdownIt-Anchor" href="#补充概念"></a> 补充概念</h4><p><strong>最大元和最小元</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">设 (P, ≤) 为一个偏序集 ，S 为其子集。</span><br><span class="line"></span><br><span class="line">若 S 中的元素 g 满足：  </span><br><span class="line">对 S 的任意元素 s，都有 s ≤ g，  </span><br><span class="line">则称 g 为 S 的最大元（greatest element）。</span><br><span class="line"></span><br><span class="line">对偶地，若 S 中的元素 l 满足：  </span><br><span class="line">对 S 的任意元素 s，都有 l ≤ s，  </span><br><span class="line">则称 l 为 S 的最小元（least element）。</span><br><span class="line"></span><br><span class="line">由定义可知，S 的最大元（最小元）必定是 S 的上界（下界）。</span><br><span class="line"></span><br><span class="line">并且集合 S 至多只能有一个最大元：  </span><br><span class="line">若 g₁ 和 g₂ 都是 S 的最大元，则由定义有  </span><br><span class="line">g₁ ≤ g₂，且 g₂ ≤ g₁，  </span><br><span class="line">由反对称性可得 g₁ = g₂。</span><br><span class="line"></span><br><span class="line">因此，若 S 存在最大元,则该最大元必定是唯一的,最小元同理</span><br></pre></td></tr></table></figure><p><strong>最小上界和最大上界</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设 (A, ≤) 为一个偏序集，B ⊆ A。</span><br><span class="line"></span><br><span class="line">若存在 y ∈ A，使得对任意 x ∈ B 都有  </span><br><span class="line">x ≤ y，  </span><br><span class="line">则称 y 为集合 B 的上界。</span><br><span class="line"></span><br><span class="line">对称地，若存在 z ∈ A，使得对任意 x ∈ B 都有  </span><br><span class="line">z ≤ x，  </span><br><span class="line">则称 z 为集合 B 的下界。</span><br><span class="line"></span><br><span class="line">偏序集A的子集B在A中的上界集合的最小元称为最小上界,对偶概念即为最大下界</span><br></pre></td></tr></table></figure><h4 id="特殊的格"><a class="markdownIt-Anchor" href="#特殊的格"></a> 特殊的格</h4><p><strong>分配格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个格。  </span><br><span class="line">若对任意 a、b、c ∈ L，都有：</span><br><span class="line"></span><br><span class="line">a ∧ (b ∨ c) = (a ∧ b) ∨ (a ∧ c)  </span><br><span class="line">a ∨ (b ∧ c) = (a ∨ b) ∧ (a ∨ c)</span><br><span class="line"></span><br><span class="line">则称 L 为一个分配格。</span><br></pre></td></tr></table></figure><hr /><p><strong>有界格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个格。  </span><br><span class="line">若 L 有最小元0和最大元1,即对任意 a ∈ L 都满足  </span><br><span class="line">a ∨ 0 = a 和 a ∧ 1 = a，  </span><br><span class="line">则称 L 为一个有界格,这里的最小元称为全下界,最大元称为全上界</span><br></pre></td></tr></table></figure><ul><li>可以认为所有元素有限的格都是有界格,因为格的定义就要求了哈斯图的两端是封闭的,故一定有上下界</li></ul><hr /><p><strong>有补格</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设 (L, ∨, ∧) 是一个有界格  </span><br><span class="line">并且 L 中的每个元素 a 都存在一个b ∈ L 使得  </span><br><span class="line">a ∨ b = 1 且 a ∧ b = 0。  </span><br><span class="line">这样的 b 称为 a 的补元。</span><br><span class="line">L则称为有补格</span><br></pre></td></tr></table></figure><p><em>证明分配格中任意元素的补元唯一</em></p><blockquote><p>设 L 是一个分配格，有界格，且 a ∈ L 有两个补元 b 和 c。<br />根据补元的定义：</p><ol><li>a ∨ b = 1 且 a ∧ b = 0</li><li>a ∨ c = 1 且 a ∧ c = 0</li></ol><p>要证明 b = c。</p><p>步骤 1：利用分配律</p><p>考虑 b ∧ (a ∨ c)：</p><p>b ∧ (a ∨ c) = (b ∧ a) ∨ (b ∧ c)  （分配律）</p><p>代入已知 a ∧ b = 0：</p><p>0 ∨ (b ∧ c) = b ∧ c</p><p>而 a ∨ c = 1，所以：</p><p>b ∧ 1 = b</p><p>所以 b = b ∧ c。</p><p>步骤 2：对称地</p><p>同理，c = a ∨ b ∧ c，经过类似推导可得：</p><p>c = b ∧ c</p><p>步骤 3：结合得到</p><p>b = b ∧ c = c</p><p>因此，补元是唯一的。</p></blockquote><p><strong>布尔格(布尔代数)</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">布尔格是一个有补分配格,换句话说，它是一个有最小元 0 和最大元 1 的格,</span><br><span class="line">满足分配律，并且每个元素都有补元</span><br></pre></td></tr></table></figure><ul><li>由上述证明可以明确布尔代数每个元素的补元唯一,求补元可以看成是一元运算</li></ul><hr /><p><strong>仔细一看就算都理解透了,还是有一堆要背的,因为不可能到考试的时候现推啊,能把数学课教成文科也是挺nb的.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=113979489780353&amp;bvid=BV1H2NoeiE1K&amp;cid=28736228422&amp;p=1&quot;        width=&quot;100%&quot;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://revival-of-hope.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2025 年终总结</title>
    <link href="https://revival-of-hope.github.io/2025/12/31/archives-2025-2025-12-31-%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <id>https://revival-of-hope.github.io/2025/12/31/archives-2025-2025-12-31-%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%A7%E4%BD%9C%E4%B8%9A/</id>
    <published>2025-12-31T00:00:00.000Z</published>
    <updated>2026-01-01T05:51:44.863Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周都在忙cocos大作业,差点在30号晚上熬通宵.今天下午答辩,答辩前五分钟才把ppt写完,而项目到演示时都没能完整运行,还好老师们都不怎么在意真正的成品,反而是一直拷打代码中继承和多态的应用,侥幸过关,如果真的要当场演示,那估计就有大问题了.</p><p>究其原因,是小组合作的环节出了问题,我们组有一个本来能自己单干的大佬,而剩下的两人包括我则是不一般的菜鸡,大多数代码都是由AI完成的,很多报错也只有问AI才能解决,因为我之前根本就没接触过CPP的工程构建,多文件的集成也都是靠AI解决的.</p><p>尽管大佬给了很详细的接口文档,但由于文档全是英文,于是我们就直接贴给AI让它翻译,又没好意思让他一个人帮我们看代码,那样他就把活儿都干了.于是就悲剧了.尽管UI层的隔离测试可以跑通,Gameplay和Engine部分单独跑也可以,但由于我们这边的实现不够完全,接口没能全部写完整,于是在答辩前三天的合并时就出问题了,而且在大佬很早就提出要对齐接口的时候我们不够重视,导致接口一直有偏差,等发现是由于接口没对齐导致报错的时候离答辩只有不到一天了.而大佬以为我们都实现好了,只是路径包含或者平台差异导致报错,之前就没有来帮我们改代码,而这个时候再改就已经来不及了.</p><p><strong>复盘</strong><br />小组项目成功的必要条件:</p><ul><li>组员之间关系平等,不存在不好意思说话的情况,只有好好的沟通交流才能保证项目协作正常</li><li>组员之间能力不能相差太大,如果能力都有限反而更好团队协作,光是抱大腿未免有些太要不得了</li><li>组员需要掌握基本的Debug能力,光是靠AI或者求爷爷告奶奶是不行的,而是要能够自己独立解决基本的技术问题</li><li>每次更新都需要及时通过文档告知其他组员,详细写明更改的地方,以及对合作者的接口要求,最好是中文(😀)</li><li>在开始项目之前就要搭出一个最基本的框架,即使再抽象也可以,把所有必须要实现的功能要求先列出来,才可以保证后续运行的时候不跑偏</li><li>分工不合理很有可能导致组员间暗藏怨气,需要找到一个合理的分工方式和架构保证工作量分配均匀</li><li>使用git进行版本控制,每次commit时不要偷懒,多打几个字把本次commit好好说清楚,才不会在日后受罪</li><li>需要尽早进行合并,才能确认基本功能有没有正常实现,否则后期的合并会极其痛苦</li><li>永远不要孤军奋战,给代码一通乱改,而是虚心请教他人,如果拉不下脸,想想项目失败的后果</li></ul><p>想来这也是对我这一个学期课业的一个糟糕的总结吧,学的不够精,学的不够多,到最后啥都没剩下,还有三个小时就跨年了,祝新的一年我能更成熟一点,更好学一点,更活泼一点,更努力一点,不用太多,一点点就够了,能让我自己感觉到就够了.</p><p><strong>目标</strong></p><ul><li>[ ] cpp工程学习</li><li>[ ] 后端学习(数据库+Java)</li><li>[ ] 网络安全学习</li><li>[ ] 编写一个开源项目</li><li>[ ] 参加十场以上的比赛</li><li>[ ] 明确就业还是读研</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一周都在忙cocos大作业,差点在30号晚上熬通宵.今天下午答辩,答辩前五分钟才把ppt写完,而项目到演示时都没能完整运行,还好老师们都不怎么在意真正的成品,反而是一直拷打代码中继承和多态的应用,侥幸过关,如果真的要当场演示,那估计就有大问题了.&lt;/p&gt;
&lt;p&gt;究其原因</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
</feed>

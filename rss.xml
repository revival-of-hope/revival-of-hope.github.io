<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>当时只道是寻常</title>
  
  
  <link href="https://revival-of-hope.github.io/rss.xml" rel="self"/>
  
  <link href="https://revival-of-hope.github.io/"/>
  <updated>2025-12-22T10:19:16.203Z</updated>
  <id>https://revival-of-hope.github.io/</id>
  
  <author>
    <name>Revival-of-hope</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025-12-21 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/21/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/21/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-21T00:00:00.000Z</published>
    <updated>2025-12-22T10:19:16.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li><a href="https://ruanyf-weekly.vercel.app/weekly/issue-210">周刊210期</a><br>诺拉·劳森还说了一个观点。大家通常认为，复杂系统往往会在经济繁荣的时候崩溃，因为业务太多，支撑不过来，但他认为不是这样的，系统崩溃往往发生在经济收缩期。<br>经济繁荣时期，软件公司会大量雇佣新员工，投入更多的财力和人力，支撑复杂系统。等到经济收缩期，公司开始减少投入、冻结招聘或裁员，复杂系统可能就会在这个时候出问题，变得难以维护。<br>现在就是经济收缩期，那么接下来，会不会就是软件故障的高发期，我们将看到很多复杂系统的崩溃？</li></ol></blockquote><blockquote><ol start="2"><li>IT 行业与传统制造业有一个重要区别，就是 IT 行业有着严重的垄断。<br>全世界的智能手机有70亿部，比汽车多出5倍（14亿辆）。但是，智能手机制造商比汽车制造商少了好几个数量级。搜索引擎、社交网络、操作系统都是这样，几个巨头就垄断了整个市场。</li></ol></blockquote><blockquote><p>3.<a href="https://blog.amamiyayuuko.com/p/ai-new-bing/">来源</a><br>各个互联网公司都试图把自己的网站做成一个完全封闭的APP，你没法在搜索引擎上搜索到微信公众号的文章、小红书的内容、淘宝的商品描述……这就导致bing只能从非常有限的地方获得中文语料，最后就导致他的回答特别池沼……而且比别的AI都池沼十倍甚至九倍……</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://ruanyf-weekly.vercel.app/weekly/issue-210&quot;&gt;周刊210期&lt;/a&gt;&lt;br&gt;诺拉·劳森还说了一个观点。大家通常认为，复杂系统往往会在经济繁荣的时候崩溃，因为业务太多</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>精品技术文章</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/dynamic-2025-12-20-%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-20T02:58:05.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cpp构造与析构"><a href="#cpp构造与析构" class="headerlink" title="cpp构造与析构"></a><a href="https://blog.csdn.net/2501_91275995/article/details/156042381">cpp构造与析构</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;cpp构造与析构&quot;&gt;&lt;a href=&quot;#cpp构造与析构&quot; class=&quot;headerlink&quot; title=&quot;cpp构造与析构&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/2501_91275995/article/details/1</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-20 数据结构重点例题分析</title>
    <link href="https://revival-of-hope.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/"/>
    <id>https://revival-of-hope.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/</id>
    <published>2025-12-20T00:00:00.000Z</published>
    <updated>2025-12-22T03:42:24.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="稀疏矩阵的三元组表"><a href="#稀疏矩阵的三元组表" class="headerlink" title="稀疏矩阵的三元组表"></a>稀疏矩阵的三元组表</h2><p>三元组表需要把行,列,值分别列出来(意义在哪里?)<br><img src="/images/archives/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image.webp"></p><p>甚至还要再写辅助数组rowSize和rowStart,把很明显的东西再写一遍,却又不考算法,没招了.</p><h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    LNode* q;</span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;   <span class="comment">// 断开头结点与原链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;      <span class="comment">// 保存后继</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;      <span class="comment">// 头插</span></span><br><span class="line">        p = q;            <span class="comment">// 处理下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴下代码就能看懂了,其实我觉得就是两端交换</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p><a href="https://www.cnblogs.com/Higurashi-kagome/p/18013626">参考1</a><br><a href="https://www.xdull.cn/kmp.html">参考2</a><br>都讲的挺好.</p><p>重点是明确next数组的作用,之所以存储模式的对应字串最长公共前后缀,是因为当匹配失败时,原字符串中在匹配失败位置前的成功匹配部分刚好可以作为重置后的模式字符串的前缀,它同时也是先前匹配时得到对应长度模式字串的后缀.搞懂了这个就能彻底理解kmp了.</p><blockquote><p>例题: 设主串T&#x3D;”abaabaabcabaabc”，模式串P&#x3D;”abaabc”，采用KMP算法进行模式匹配，到匹配成功为止，在匹配过程中进行的单个字符间的比较次数是（ ）.</p></blockquote><blockquote><p>解题: int num&#x3D;0,<br>先写出next数组[0,0,1,1,2,0],第一次匹配到abaab,num+&#x3D;5,但由于失败的匹配也要算上,num+&#x3D;1<br>指针移到后缀ab,接着比较找到abaabc,num+&#x3D;4,故num&#x3D;10</p></blockquote><h2 id="组合数求解"><a href="#组合数求解" class="headerlink" title="组合数求解"></a>组合数求解</h2><blockquote><p>【例4】编写一个递归算法，找出从自<br>然数1,2,3,4,…,n中任取r个数的所有组<br>合。例如，n&#x3D;5，r&#x3D;3时的组合是543，<br>542，541，532，531，521，432，431<br>，421，321.</p><p>【解答】本问题就是求解组合数。<br>int Combin(int m, int n)<br>{ if(m&#x3D;&#x3D;n||n&#x3D;&#x3D;0) return 1;<br>else return Combin(m-1,n)+<br>Combin(m-1,n-1);}</p></blockquote><p>一开始是用dfs写的,但没想到ppt里根本没考虑把组合写出来,不过这个递归也挺难想到的.</p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><blockquote><p>假设广义表是由带头节点的链<br>表存储，请画出广义表A(a, B((),<br>C(1)))的存储结构；假设head，tail分<br>别是求首元素操作和求尾表操作，求<br>如何获得元素1.</p></blockquote><p><img src="/images/archives/2025-12-20-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%94%90%E6%B0%8F%E8%80%83%E7%82%B9/image2.webp" alt="解答"><br>其中,一个结点的定义如下:</p><blockquote><p>utype &#x3D; 0&#x2F;1&#x2F;2&#x2F;3 ;<br>value &#x3D; ref &#x2F;intgrinfo &#x2F;charinfo &#x2F; hlink ;tlink</p></blockquote><p>0表示该节点为头节点,1表示为整数,2表示为char,3表示为子表节点,∧表示该节点为尾节点,指向该子表头节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> GenList :: <span class="built_in">depth</span> ( GenListNode *ls ) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ls→tlink == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//空表</span></span><br><span class="line">GenListNode *temp = ls→tlink;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( temp != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"> <span class="comment">//横扫广义表</span></span><br><span class="line"><span class="keyword">if</span> ( temp→utype == LST ) &#123;</span><br><span class="line"> <span class="comment">//子表深度</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">depth</span> ( temp→value.hlink );</span><br><span class="line"><span class="keyword">if</span> ( m &lt; n ) m = n;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//不是子表不加深度</span></span><br><span class="line">temp = temp→tlink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;稀疏矩阵的三元组表&quot;&gt;&lt;a href=&quot;#稀疏矩阵的三元组表&quot; class=&quot;headerlink&quot; title=&quot;稀疏矩阵的三元组表&quot;&gt;&lt;/a&gt;稀疏矩阵的三元组表&lt;/h2&gt;&lt;p&gt;三元组表需要把行,列,值分别列出来(意义在哪里?)&lt;br&gt;&lt;img src=&quot;/im</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>我遇到的各种调试问题</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/dynamic-2025-12-19-%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2025-12-19T01:58:56.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode-powershell终端打字缺字漏字"><a href="#vscode-powershell终端打字缺字漏字" class="headerlink" title="vscode powershell终端打字缺字漏字"></a>vscode powershell终端打字缺字漏字</h2><p>解决方法:<br>搜索设置<br>Terminal &gt; Integrated &gt; Default Profile: Windows<br>换为cmd</p><h2 id="左斜线和右斜线问题"><a href="#左斜线和右斜线问题" class="headerlink" title="左斜线和右斜线问题"></a>左斜线和右斜线问题</h2><p>windows路径都是,转义符是,而网页链接,linux都是&#x2F;<br>解决方法:<br>在搜索框输入：”Explorer: Copy Relative Path Separator”<br>将\改为正斜杠&#x2F;<br><a href="https://blog.csdn.net/kdz6511/article/details/148712726">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vscode-powershell终端打字缺字漏字&quot;&gt;&lt;a href=&quot;#vscode-powershell终端打字缺字漏字&quot; class=&quot;headerlink&quot; title=&quot;vscode powershell终端打字缺字漏字&quot;&gt;&lt;/a&gt;vscode powe</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-19 数据结构整理-6</title>
    <link href="https://revival-of-hope.github.io/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/"/>
    <id>https://revival-of-hope.github.io/2025/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-6/</id>
    <published>2025-12-19T00:00:00.000Z</published>
    <updated>2025-12-21T13:41:56.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vector使用注意事项"><a href="#vector使用注意事项" class="headerlink" title="vector使用注意事项"></a>vector使用注意事项</h2><blockquote><p>1.向未初始化vector里添加 元素需要用push_back,而不能用下标访问,想要用下标访问就要先初始化或resize</p></blockquote><blockquote><p>2.<code>upper_bound(a,a+n,num)</code>访问的是第一个比num大的位置,lower_bound访问的则是第一个大于等于num的位置</p></blockquote><blockquote><p>3.用下标访问时和数组一样前闭后开,注意begin() 和 end() 返回的是迭代器(iterator),这里end()访问的也是下一个位置</p></blockquote><blockquote><p>4.可以用a&#x3D;b直接覆盖数组</p></blockquote><h2 id="快速转置稀疏矩阵"><a href="#快速转置稀疏矩阵" class="headerlink" title="快速转置稀疏矩阵"></a>快速转置稀疏矩阵</h2><p>ppt上的原文(显然不想让我们看懂)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">SparseMatrix&lt;Type&gt; SparseMatrix&lt;Type&gt;::<span class="built_in">FastTranspos</span>() &#123;</span><br><span class="line">    <span class="type">int</span> *rowSize = <span class="keyword">new</span> <span class="type">int</span>[Cols];</span><br><span class="line">    <span class="type">int</span> *rowStart = <span class="keyword">new</span> <span class="type">int</span>[Cols];</span><br><span class="line"></span><br><span class="line">    <span class="function">SparseMatrix&lt;Type&gt; <span class="title">b</span><span class="params">(Cols, Rows)</span></span>;</span><br><span class="line">    b.Rows = Cols;</span><br><span class="line">    b.Cols = Rows;</span><br><span class="line">    b.Terms = Terms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Terms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化每列元素个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Cols; i++)</span><br><span class="line">            rowSize[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每列的非零元素数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Terms; i++)</span><br><span class="line">            rowSize[smArray[i].col]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每行的起始位置</span></span><br><span class="line">        rowStart[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; Cols; i++)</span><br><span class="line">            rowStart[i] = rowStart[i - <span class="number">1</span>] + rowSize[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将元素放到转置后的正确位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Terms; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = rowStart[smArray[i].col];</span><br><span class="line">            b.smArray[j].row = smArray[i].col;</span><br><span class="line">            b.smArray[j].col = smArray[i].row;</span><br><span class="line">            b.smArray[j].value = smArray[i].value;</span><br><span class="line">            rowStart[smArray[i].col]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] rowSize;</span><br><span class="line">    <span class="keyword">delete</span>[] rowStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说真的,他只要提一嘴用一个数组来存储矩阵中的所有非零元素就可以了,而ppt的原话是:</p><blockquote><p>核心思想：事先统计好转置后各行非零元素在转置矩阵的三元组表中应存放的位置</p></blockquote><p>受不了了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vector使用注意事项&quot;&gt;&lt;a href=&quot;#vector使用注意事项&quot; class=&quot;headerlink&quot; title=&quot;vector使用注意事项&quot;&gt;&lt;/a&gt;vector使用注意事项&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1.向未初始化vector里添加 </summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/18/archives-2025-12-18-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/18/archives-2025-12-18-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-18T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://exquora.thoughtstorms.info/"></a></p><p>我对 Quora 上瘾，情不自禁使用这个网站。那里有一些很棒的问题和讨论，激发了我的灵感和想法。</p><p>但是当我重新阅读自己写的答案，一方面欣赏我的修辞和洞察力，另一方面也看到了很多想法可以成长为更大的成果。它们本可能进一步发展为软件、文章、论文、创业公司、书籍或社会运动，但任何事都没有发生。</p><p>不仅如此，还有许多篇我写的长篇大论已经无关紧要，沦为了废文。还有很多我花了好几个小时写的评论，试图说服对于这些问题永远不可能改变观点的那些读者。</p><p>我花了数千（也许是数万）小时在 Quora 上写作。我写的远不止11000个答案，还有5000多个草稿答案，其中很多已经写得很长了，只是因为来不及最终润色而没​​有发表。</p></blockquote><p>这篇文章说出了我想说的,我见过很多极其优秀的故事或者技术讲解,可作者发布的网站恰恰是贴吧,天涯或者知乎这样的问答网站或者论坛,作者的观点被一篇篇孤立的文章或者一条条回复分割开来,很难形成一个完整的体系.</p><p>而天涯的倒闭也说明了在这些自己不能掌控的平台上并不能保证自己的思想可以永久保留下来,那些优秀的文章随着服务器的关闭直接成为了无法触及的历史,即便是作者本人也无法找回.</p><p>因此,我拒绝在论坛里写长篇大论,而是作为读者去发掘优秀的文章,可惜的是现在优秀的文章也越来越少了,而AI生成的无意义内容充斥着论坛的每个角落,很难找到真正有意义的东西,这也是我悲哀的一点.</p><p>一方面,论坛不能让作者的文字体系化,另一方面,博客不能保证作者的文章能广泛传播,比如我这个博客就不是所有国人都能访问到的,很难找到一个折衷点.</p><p>如果我有那个能力,我可能会去开发一个跨平台的博客论坛吧,侧重点在于分享生活和技术,每个人都能像写博客一样把文章从自己本地上传,改进一下SEO算法,保证最好的文章优先显示,集成了评论系统和follow功能,最大幅度减少作者需要折腾的东西,只写md就行了,呈现的页面也由作者自己在前端设置.重点是这个网站能长久保存,不会让作者的心血白费.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://exquora.thoughtstorms.info/&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我对 Quora 上瘾，情不自禁使用这个网站。那里有一些很棒的问题和讨论，激发了我的灵感和想法。&lt;/p&gt;
&lt;p&gt;但是当我重新阅读自己</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-18 触动过我的文章</title>
    <link href="https://revival-of-hope.github.io/2025/12/18/dynamic-2025-12-18-%E8%A7%A6%E5%8A%A8%E8%BF%87%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://revival-of-hope.github.io/2025/12/18/dynamic-2025-12-18-%E8%A7%A6%E5%8A%A8%E8%BF%87%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2025-12-18T00:00:00.000Z</published>
    <updated>2025-12-22T05:53:03.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十年前的实习面试-https-zhuanlan-zhihu-com-p-117315093"><a href="#十年前的实习面试-https-zhuanlan-zhihu-com-p-117315093" class="headerlink" title="(十年前的实习面试)[https://zhuanlan.zhihu.com/p/117315093]"></a>(十年前的实习面试)[<a href="https://zhuanlan.zhihu.com/p/117315093]">https://zhuanlan.zhihu.com/p/117315093]</a></h3><h3 id="疫情求职-https-juejin-cn-post-7180678820796563516-searchId-20251125151954D8EF0E1FE1D09C7C0330"><a href="#疫情求职-https-juejin-cn-post-7180678820796563516-searchId-20251125151954D8EF0E1FE1D09C7C0330" class="headerlink" title="(疫情求职)[https://juejin.cn/post/7180678820796563516?searchId=20251125151954D8EF0E1FE1D09C7C0330]"></a>(疫情求职)[<a href="https://juejin.cn/post/7180678820796563516?searchId=20251125151954D8EF0E1FE1D09C7C0330%5D">https://juejin.cn/post/7180678820796563516?searchId=20251125151954D8EF0E1FE1D09C7C0330]</a></h3><h3 id="github-stars-wont-pay-your-rent-https-www-kitze-io-posts-github-stars-wont-pay-your-rent"><a href="#github-stars-wont-pay-your-rent-https-www-kitze-io-posts-github-stars-wont-pay-your-rent" class="headerlink" title="(github-stars-wont-pay-your-rent)[https://www.kitze.io/posts/github-stars-wont-pay-your-rent]"></a>(github-stars-wont-pay-your-rent)[<a href="https://www.kitze.io/posts/github-stars-wont-pay-your-rent]">https://www.kitze.io/posts/github-stars-wont-pay-your-rent]</a></h3><h3 id="git考古-https-blog-brachiosoft-com"><a href="#git考古-https-blog-brachiosoft-com" class="headerlink" title="(git考古)[https://blog.brachiosoft.com/]"></a>(git考古)[<a href="https://blog.brachiosoft.com/]">https://blog.brachiosoft.com/]</a></h3><h3 id="速通日语-https-galgame-dev-topic-639-E5-85-B3-E4-BA-8E-E6-88-91-E4-B8-80-E5-B9-B4-E4-B8-8D-E5-88-B0-E9-80-9F-E9-80-9An1-E8-BF-99-E4-BB-B6-E4-BA-8B-E5-9F-BA-E4-BA-8E-E5-95-83-E7-94-9F-E8-82-89galgame-E7-9A-84-E6-97-A5-E8-AF-AD-E5-AD-A6-E4-B9-A0-E6-94-BB-E7-95-A5-8"><a href="#速通日语-https-galgame-dev-topic-639-E5-85-B3-E4-BA-8E-E6-88-91-E4-B8-80-E5-B9-B4-E4-B8-8D-E5-88-B0-E9-80-9F-E9-80-9An1-E8-BF-99-E4-BB-B6-E4-BA-8B-E5-9F-BA-E4-BA-8E-E5-95-83-E7-94-9F-E8-82-89galgame-E7-9A-84-E6-97-A5-E8-AF-AD-E5-AD-A6-E4-B9-A0-E6-94-BB-E7-95-A5-8" class="headerlink" title="(速通日语)[https://galgame.dev/topic/639/%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%80%E5%B9%B4%E4%B8%8D%E5%88%B0%E9%80%9F%E9%80%9An1%E8%BF%99%E4%BB%B6%E4%BA%8B-%E5%9F%BA%E4%BA%8E%E5%95%83%E7%94%9F%E8%82%89galgame%E7%9A%84%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/8]"></a>(速通日语)[<a href="https://galgame.dev/topic/639/%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%80%E5%B9%B4%E4%B8%8D%E5%88%B0%E9%80%9F%E9%80%9An1%E8%BF%99%E4%BB%B6%E4%BA%8B-%E5%9F%BA%E4%BA%8E%E5%95%83%E7%94%9F%E8%82%89galgame%E7%9A%84%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/8]">https://galgame.dev/topic/639/%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%80%E5%B9%B4%E4%B8%8D%E5%88%B0%E9%80%9F%E9%80%9An1%E8%BF%99%E4%BB%B6%E4%BA%8B-%E5%9F%BA%E4%BA%8E%E5%95%83%E7%94%9F%E8%82%89galgame%E7%9A%84%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/8]</a></h3><h3 id="加拿大体验-https-ramsayleung-github-io-zh-post-2024-E7-99-BB-E9-99-86-E5-8A-A0-E6-8B-BF-E5-A4-A7-E4-B8-80-E5-B9-B4-E7-9A-84-E4-BD-93-E4-BC-9A"><a href="#加拿大体验-https-ramsayleung-github-io-zh-post-2024-E7-99-BB-E9-99-86-E5-8A-A0-E6-8B-BF-E5-A4-A7-E4-B8-80-E5-B9-B4-E7-9A-84-E4-BD-93-E4-BC-9A" class="headerlink" title="(加拿大体验)[https://ramsayleung.github.io/zh/post/2024/%E7%99%BB%E9%99%86%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/]"></a>(加拿大体验)[<a href="https://ramsayleung.github.io/zh/post/2024/%E7%99%BB%E9%99%86%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/]">https://ramsayleung.github.io/zh/post/2024/%E7%99%BB%E9%99%86%E5%8A%A0%E6%8B%BF%E5%A4%A7%E4%B8%80%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/]</a></h3><h3 id="日本游记-https-nekonull-me-archive-2310-jp-travel"><a href="#日本游记-https-nekonull-me-archive-2310-jp-travel" class="headerlink" title="(日本游记)[https://nekonull.me/archive/2310-jp-travel/]"></a>(日本游记)[<a href="https://nekonull.me/archive/2310-jp-travel/]">https://nekonull.me/archive/2310-jp-travel/]</a></h3><h3 id="python的问题-https-www-dongwm-com-post-be-a-gopher"><a href="#python的问题-https-www-dongwm-com-post-be-a-gopher" class="headerlink" title="(python的问题)[https://www.dongwm.com/post/be-a-gopher/]"></a>(python的问题)[<a href="https://www.dongwm.com/post/be-a-gopher/]">https://www.dongwm.com/post/be-a-gopher/]</a></h3><h3 id="My-solopreneur-story-zero-to-45K-mo-in-2-years-https-news-tonydinh-com-p-my-solopreneur-story-zero-to-45kmo"><a href="#My-solopreneur-story-zero-to-45K-mo-in-2-years-https-news-tonydinh-com-p-my-solopreneur-story-zero-to-45kmo" class="headerlink" title="(My solopreneur story: zero to $45K&#x2F;mo in 2 years)[https://news.tonydinh.com/p/my-solopreneur-story-zero-to-45kmo]"></a>(My solopreneur story: zero to $45K&#x2F;mo in 2 years)[<a href="https://news.tonydinh.com/p/my-solopreneur-story-zero-to-45kmo]">https://news.tonydinh.com/p/my-solopreneur-story-zero-to-45kmo]</a></h3><h3 id="肮脏的交易-https-www-mooreslawisdead-com-post-sam-altman-s-dirty-dram-deal"><a href="#肮脏的交易-https-www-mooreslawisdead-com-post-sam-altman-s-dirty-dram-deal" class="headerlink" title="(肮脏的交易)[https://www.mooreslawisdead.com/post/sam-altman-s-dirty-dram-deal]"></a>(肮脏的交易)[<a href="https://www.mooreslawisdead.com/post/sam-altman-s-dirty-dram-deal]">https://www.mooreslawisdead.com/post/sam-altman-s-dirty-dram-deal]</a></h3><h3 id="十年学会编程"><a href="#十年学会编程" class="headerlink" title="十年学会编程"></a><a href="http://daiyuwen.freeshell.org/gb/misc/21-days-cn.html">十年学会编程</a></h3><h3 id="契诃夫分析"><a href="#契诃夫分析" class="headerlink" title="契诃夫分析"></a><a href="https://mhperng.blogspot.com/2025/12/anton-chekhov.html">契诃夫分析</a></h3><h3 id="软件开发经验"><a href="#软件开发经验" class="headerlink" title="软件开发经验"></a><a href="https://cloud.tencent.com/developer/article/1004735">软件开发经验</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;十年前的实习面试-https-zhuanlan-zhihu-com-p-117315093&quot;&gt;&lt;a href=&quot;#十年前的实习面试-https-zhuanlan-zhihu-com-p-117315093&quot; class=&quot;headerlink&quot; title=&quot;(十</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 道路与选择</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/archives-2025-12-16-%E9%81%93%E8%B7%AF%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/archives-2025-12-16-%E9%81%93%E8%B7%AF%E4%B8%8E%E9%80%89%E6%8B%A9/</id>
    <published>2025-12-16T08:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<p>这几天有点焦躁和郁闷,总有种无所适从的感觉,浑浑噩噩的,对很多事都不上心了,于是现在静下来认真思考了一下当前的处境.</p><p>人生是由一大堆选择构成的,每一个分岔路口都决定了我以后的人生道路,有时候选择多种多样,似乎哪里都是通路,有时候仿佛是山穷水尽,让我别无选择.</p><p>人自然是希望选择越多越好,这就是我以前为什么倾向于做事提早做准备的原因,为的就是不让自己在ddl的时候显得无路可走.</p><p>但过多的选择,太多的可能,悲观的现实又让我痛苦万分,人生的道路总是要自己走的,但如果有一个引路人就更好了.看不清未来的道路只会使我无所适从,一边厌恶着填鸭式的教育,一边追求绩点的完美,只怕到头来也是一场空.</p><h2 id="梁甫吟"><a href="#梁甫吟" class="headerlink" title="梁甫吟"></a>梁甫吟</h2><p><strong>唐 · 李白</strong></p><blockquote><p>長嘯梁甫吟，何時見陽春？<br>君不見，朝歌屠叟辭棘津，八十西來釣渭濱。<br>寧羞白髮照清水，逢時壯氣思經綸。<br>廣張三千六百釣，風期暗與文王親。<br>大賢虎變愚不測，當年頗似尋常人。  </p><p>君不見，高陽酒徒起草中，長揖山東隆準公。<br>入門不拜逞雄辯，兩女輟洗來趨風。<br>東下齊城七十二，指揮楚漢如鏇蓬。<br>狂客落魄尚如此，何況壯士當群雄！  </p><p>我欲攀龍見明主，雷公砰訇震天鼓。<br>帝旁投壺多玉女，三時大笑開電光，<br>倏爍晦冥起風雨。<br>閶闔九門不可通，以額扣關閽者怒。  </p><p>白日不照我精誠，杞國無事憂天傾。<br>猰貐磨牙競人肉，騶虞不折生草莖。<br>手接飛猱搏雕虎，側足焦原未言苦。  </p><p>智者可卷愚者豪，世人見我輕鴻毛。<br>力排南山三壯士，齊相殺之費二桃。<br>吳楚弄兵無劇孟，亞夫咍爾為徒勞。  </p><p>梁甫吟，聲正悲。<br>張公兩龍劍，神物合有時。<br>風雲感會起屠釣，大人臲屼當安之。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天有点焦躁和郁闷,总有种无所适从的感觉,浑浑噩噩的,对很多事都不上心了,于是现在静下来认真思考了一下当前的处境.&lt;/p&gt;
&lt;p&gt;人生是由一大堆选择构成的,每一个分岔路口都决定了我以后的人生道路,有时候选择多种多样,似乎哪里都是通路,有时候仿佛是山穷水尽,让我别无选择.&lt;</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 数据结构整理-5</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/2025-12-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-5/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/2025-12-16-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-5/</id>
    <published>2025-12-16T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.505Z</updated>
    
    <content type="html"><![CDATA[<p>(突然发现这部分期末不考算法,懒得挂代码上来了)<br>(第二次复习时需要画图补充)</p><h2 id="Dijkstra最短路径算法"><a href="#Dijkstra最短路径算法" class="headerlink" title="Dijkstra最短路径算法"></a>Dijkstra最短路径算法</h2><p><a href="https://gallery.selfboot.cn/zh/algorithms/dijkstra">极好的证明</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 归纳基础：k = 1 时，T 中只包含起点 s，dist[s] = short[s] = 0，因此命题在 k = 1 时成立。</span><br><span class="line"></span><br><span class="line">2. 归纳假设：假设命题在第 k 步时成立，即 T 中所有节点的 dist 值都是最短路径长度。</span><br><span class="line"></span><br><span class="line">3. 归纳步骤：证明第 k+1 步时命题也成立：</span><br><span class="line"></span><br><span class="line">设第 k+1 步选择的节点为 v（v 是未访问节点中 dist 值最小的）；v 与集合 T 中的某个节点 u 相连；</span><br><span class="line">需要证明：dist[v] = short[v]。</span><br><span class="line">这里用反证法：</span><br><span class="line"></span><br><span class="line">假设存在一条从起点 s 到 v 的路径 P，其长度是 short[v]，且 short[v] &lt; dist[v]。</span><br><span class="line">由于起点 s 在集合 T 中，而终点 v 不在集合 T 中，路径 P 必然至少经过一个集合 T 中的节点（除起点外）。因为起点 s 到任何不在 T 中节点的距离，都是通过 T 中的节点来计算和更新的。</span><br><span class="line">设路径 P 上最后一个在集合 T 中的节点为 last，之后经过未访问集合中的节点 y 最终到达 v；下面看路径 P 的长度计算：</span><br><span class="line">  short[v] = dist[last] + distance[last,y] + distance[y,v]  // 路径 P 的长度</span><br><span class="line">           ≥ dist[y] + distance[y,v]                        // 根据 dist[y] 的更新规则</span><br><span class="line">           ≥ dist[v]      </span><br><span class="line">要理解下面这两个点才能明白上面的推导：</span><br><span class="line">首先由归纳假设，到达 last 的距离 dist[last] 是最短的；对于节点 y，根据 Dijkstra 算法的更新规则：dist[y] ≤ dist[last] + distance[last,y]</span><br><span class="line"></span><br><span class="line">又因为算法第 k+1 步选择了 v 作为当前最小距离节点，所以 dist[v] ≤ dist[y] + distance[y,v]。</span><br><span class="line">于是就推导出 short[v] &gt;= dist[v]，这和我们的假设 short[v] &lt; dist[v] 矛盾，因此假设不成立，dist[v] 就是从起点到 v 的最短路径长度。这也证明了算法每一步选择的节点的距离都是最短路径长度。</span><br></pre></td></tr></table></figure><p>这个归纳证明直接讲明白了算法的核心步骤,每次取未vis的最短路后更新其他未vis的最短路,直到遍历完所有节点就可以了</p><h2 id="floyd最短路径算法"><a href="#floyd最短路径算法" class="headerlink" title="floyd最短路径算法"></a>floyd最短路径算法</h2><p>重点是确认初始状态,之后将所有点遍历作为中间点更新最短路径,写一个三重循环,可得到任意两点之间的最短路径.<br>可以看出来floyd更为通用,dijkstra只能得到单源最短路径</p><h2 id="aoe网络关键路径"><a href="#aoe网络关键路径" class="headerlink" title="aoe网络关键路径"></a>aoe网络关键路径</h2><p><a href="https://blog.csdn.net/ROBOT_a/article/details/147289874">讲的最清楚</a></p><blockquote><p>关键路径所经过的结点的最迟发生时间和最早发生时间是一致的。如果不好理解的话，打个比方，比如小组作业中，有个同学做的特别慢（关键路径）。所有人同时开始做，其他组员都做完了，他还没有做完，而小组只有等所有人都做完才能上交作品，那么完成小组作业所需的总时间就取决于他的时间。为了不拖后腿，对于他来说，他所做的n个事情就没有“最早什么时候做”“最晚什么时候做”这个说法，而是要马不停蹄地一直做。其他组员则可以选择早一点或晚一点做，只要不比他（关键路径）慢就行。<br>————————————————<br>版权声明：本文为CSDN博主「木卫三上的下午茶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ROBOT_a/article/details/147289874">https://blog.csdn.net/ROBOT_a/article/details/147289874</a></p></blockquote><p>这个解释非常妙,让我一下看懂了.</p><p>关键是先求每个节点的最早发生时间和最迟发生时间,<br>再根据节点反推边对应事件的最早发生时间和最迟发生时间,相减得到差额,等于0的就是关键路径所经过的边.<br>需要明确的是递推方向,最早从前往后推,最迟从后往前推,节点和事件都是这样.<br>(到处搜资料还是没看懂,一翻到这篇文章就看懂了)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;(突然发现这部分期末不考算法,懒得挂代码上来了)&lt;br&gt;(第二次复习时需要画图补充)&lt;/p&gt;
&lt;h2 id=&quot;Dijkstra最短路径算法&quot;&gt;&lt;a href=&quot;#Dijkstra最短路径算法&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra最短路径算法</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-16 折腾记录-动态更新</title>
    <link href="https://revival-of-hope.github.io/2025/12/16/dynamic-2025-12-16-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    <id>https://revival-of-hope.github.io/2025/12/16/dynamic-2025-12-16-%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/</id>
    <published>2025-12-16T00:00:00.000Z</published>
    <updated>2025-12-22T11:15:46.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo图片管理困难-帖子多了很难阅读"><a href="#hexo图片管理困难-帖子多了很难阅读" class="headerlink" title="hexo图片管理困难,帖子多了很难阅读"></a>hexo图片管理困难,帖子多了很难阅读</h2><p>解决方法:<br>config_yml里修改<br>new_post_name: :year-:month-:day-:title.md<br>同时,听从大佬建议,将所有图片改成webp格式,效果立竿见影<br><img src="/images/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/tmpDAFA.png"></p><h2 id="还是图片问题-每次复制images子文件夹路径太麻烦"><a href="#还是图片问题-每次复制images子文件夹路径太麻烦" class="headerlink" title="还是图片问题,每次复制images子文件夹路径太麻烦"></a>还是图片问题,每次复制images子文件夹路径太麻烦</h2><p>根据<a href="https://www.hwpo.top/posts/d87f7e0c/index.html"></a>教程在post文件夹里设置同名文件夹没解决</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>最后写了一个脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 用 data.path 生成文件夹名</span></span><br><span class="line">  <span class="comment">// data.path 是相对于 source/_posts 的路径，带后缀</span></span><br><span class="line">  <span class="keyword">const</span> filename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, path.<span class="title function_">extname</span>(data.<span class="property">path</span>)); <span class="comment">// 去掉扩展名</span></span><br><span class="line">  <span class="keyword">const</span> imagesDir = path.<span class="title function_">join</span>(hexo.<span class="property">base_dir</span>, <span class="string">&#x27;source/images&#x27;</span>, filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(imagesDir)) &#123;</span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(imagesDir, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Created image folder: <span class="subst">$&#123;imagesDir&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在同级目录下生成图像文件夹来管理,麻烦的是每次都要删去相对路径里的’source&#x2F;‘</p><h2 id="hexo命令行"><a href="#hexo命令行" class="headerlink" title="hexo命令行"></a>hexo命令行</h2><p>hexo new post&#x2F;draft&#x2F;page<br>hexo publish draft”文章名”<br>hexo d           –push my blog  deploy<br>hexo new  +name     –new blog<br>hexo g            –apply changes  generate<br>hexo s            –local static html #预览<br>hexo g -d   #一次完成</p><p>draft也就是草稿，在使用hexo创建文章时，可以先指定为草稿。<br>hexo new draft <title><br>然后在完成之后，使用publish命令将draft转移到post下。<br>hexo publish <title></p><h2 id="改用butterfly主题"><a href="#改用butterfly主题" class="headerlink" title="改用butterfly主题"></a>改用butterfly主题</h2><p>这个主题确实好用了不少</p><h2 id="增加评论系统"><a href="#增加评论系统" class="headerlink" title="增加评论系统"></a>增加评论系统</h2><p><a href="https://tech.yemengstar.com/vercel-twikoo-comment-your-hexo/">参考文章</a></p><h2 id="尝试新部署方式"><a href="#尝试新部署方式" class="headerlink" title="尝试新部署方式"></a>尝试新部署方式</h2><p><a href="https://tech.yemengstar.com/github-actions-auto-hexo/"></a></p><h2 id="增加了category条目-tag条目和背景图片"><a href="#增加了category条目-tag条目和背景图片" class="headerlink" title="增加了category条目,tag条目和背景图片"></a>增加了category条目,tag条目和背景图片</h2><p>原来要用<code>hexo new page tag</code>才能在hexo里显示tag页</p><h2 id="发现md只要在posts下都能被直接解析-25-12-21"><a href="#发现md只要在posts下都能被直接解析-25-12-21" class="headerlink" title="发现md只要在posts下都能被直接解析(25&#x2F;12&#x2F;21)"></a>发现md只要在posts下都能被直接解析(25&#x2F;12&#x2F;21)</h2><p>于是我将不会再修改的文章都移动到了archives文件夹,图片路径也做了对应的修改,<br>之前我还想文章多了要怎么处理呢.</p><h2 id="还是图片问题-hexo本地无法正确解析相对路径"><a href="#还是图片问题-hexo本地无法正确解析相对路径" class="headerlink" title="还是图片问题,hexo本地无法正确解析相对路径"></a>还是图片问题,hexo本地无法正确解析相对路径</h2><p>例如<code>source/images/archives/2025-11-26/image.png</code><br>需要改为’images&#x2F;archives&#x2F;2025-11-26&#x2F;image.png’,每次改就很麻烦了<br>于是找ai弄了脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data.<span class="property">cover</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    data.<span class="property">cover</span> = data.<span class="property">cover</span>.<span class="title function_">replace</span>(</span><br><span class="line">      <span class="regexp">/^\/?source\//</span>,</span><br><span class="line">      <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完美解决,以后只要把复制相对路径就可以了,不要再删删减减了.</p><h2 id="增加rss订阅图标"><a href="#增加rss订阅图标" class="headerlink" title="增加rss订阅图标"></a>增加rss订阅图标</h2><p><a href="https://mitpoppy.github.io/posts/fe13d434.html">参考文章</a><br>发现了RSS订阅方式,于是增加了这一功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo图片管理困难-帖子多了很难阅读&quot;&gt;&lt;a href=&quot;#hexo图片管理困难-帖子多了很难阅读&quot; class=&quot;headerlink&quot; title=&quot;hexo图片管理困难,帖子多了很难阅读&quot;&gt;&lt;/a&gt;hexo图片管理困难,帖子多了很难阅读&lt;/h2&gt;&lt;p&gt;解决</summary>
      
    
    
    
    <category term="动态更新" scheme="https://revival-of-hope.github.io/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2025-12-14 数据结构整理-4</title>
    <link href="https://revival-of-hope.github.io/2025/12/14/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/"/>
    <id>https://revival-of-hope.github.io/2025/12/14/2025-12-14-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-4/</id>
    <published>2025-12-14T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><h3 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h3><p>模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; other.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用lamda或许更好,这个重载太难理解了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5005</span>;</span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">e</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按边权排序</span></span><br><span class="line">    <span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 已加入 MST 的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kruskal,用引用更安全</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ed : e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(ed.u) != <span class="built_in">find</span>(ed.v))&#123;</span><br><span class="line">            <span class="built_in">unite</span>(ed.u, ed.v);</span><br><span class="line">            ans += ed.w;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt != n - <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz\n&quot;</span>; <span class="comment">// 图不连通</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是用避圈法,难点是确保不形成圈,<br>用并查集来处理这我自己真想不出来,拿ai生成的我也不好意思在luogu上提交.<br>由于还是看不太懂,于是我用ai做了一个网页.</p><details><summary>点击展开 Kruskal 最小生成树演示</summary><p>下面是 Kruskal 最小生成树演示：</p><!-- Canvas 和按钮 --><canvas id="graphCanvas" width="600" height="400" style="border:1px solid #ccc;"></canvas><div style="margin-top:10px;">  <button id="nextStep">下一步</button>  <button id="reset">重置</button>  <span id="mstSum" style="margin-left:20px;">当前 MST 总权值: 0</span></div><script>// ------------------- 数据 -------------------const nodes = [  {id:0,x:100,y:100},{id:1,x:300,y:100},{id:2,x:500,y:100},  {id:3,x:200,y:300},{id:4,x:400,y:300}];const edges = [  {u:0,v:1,w:2},{u:0,v:3,w:3},{u:1,v:2,w:4},  {u:1,v:3,w:2},{u:2,v:4,w:1},{u:3,v:4,w:3}];// ------------------- Canvas 绘图 -------------------const canvas = document.getElementById('graphCanvas');const ctx = canvas.getContext('2d');function drawGraph(highlightEdge=null, skip=false) {  ctx.clearRect(0,0,canvas.width,canvas.height);  edges.forEach(e => {    const n1 = nodes[e.u], n2 = nodes[e.v];    if(e === highlightEdge){ ctx.strokeStyle = skip?'#aaa':'red'; ctx.lineWidth = 4; }    else if(e.inMST){ ctx.strokeStyle = 'green'; ctx.lineWidth = 3; }    else { ctx.strokeStyle = '#ccc'; ctx.lineWidth = 2; }    ctx.beginPath(); ctx.moveTo(n1.x,n1.y); ctx.lineTo(n2.x,n2.y); ctx.stroke();    const mx = (n1.x+n2.x)/2, my=(n1.y+n2.y)/2;    ctx.fillStyle='black'; ctx.font='14px sans-serif';    ctx.fillText(e.w,mx+5,my-5);  });  nodes.forEach(n => {    ctx.beginPath(); ctx.arc(n.x,n.y,15,0,Math.PI*2);    ctx.fillStyle='#fff'; ctx.fill();    ctx.strokeStyle='#000'; ctx.stroke();    ctx.fillStyle='black'; ctx.fillText(n.id,n.x-5,n.y+5);  });}// ------------------- 并查集 -------------------let parent = nodes.map(n=>n.id);function find(u){ return parent[u]===u ? u : (parent[u]=find(parent[u])); }function unite(u,v){ parent[find(u)] = find(v); }// ------------------- Kruskal -------------------edges.sort((a,b)=>a.w-b.w);let step=0;let mstSum = 0;document.getElementById('nextStep').onclick = function(){  if(step >= edges.length) return;  const e = edges[step];  let skip = false;  if(find(e.u) !== find(e.v)){    unite(e.u,e.v); e.inMST = true; mstSum += e.w;  } else skip = true;  drawGraph(e, skip);  document.getElementById('mstSum').textContent = "当前 MST 总权值: " + mstSum;  step++;}document.getElementById('reset').onclick = function(){  step = 0;  parent = nodes.map(n=>n.id);  edges.forEach(e=>e.inMST=false);  mstSum = 0;  drawGraph();  document.getElementById('mstSum').textContent = "当前 MST 总权值: " + mstSum;}// 初始化drawGraph();</script></details><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>写<a href="https://www.luogu.com.cn/problem/P1194">P1194</a>的时候脑袋卡壳了,怎么都想不出如何得到和更新当前的最小代价<br>于是问了ai,发现还有prim算法可以用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> k[MAX][MAX];</span><br><span class="line"><span class="type">int</span> dist[MAX];</span><br><span class="line"><span class="type">bool</span> vis[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入代价矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">            cin &gt;&gt; k[i][j];</span><br><span class="line">            <span class="comment">// 如果通过别人得到比直接买还贵，直接舍弃</span></span><br><span class="line">            <span class="keyword">if</span> (k[i][j] &gt; a||k[i][j]==<span class="number">0</span>) k[i][j] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        dist[i] = a;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim 主循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mn = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找当前未加入生成树、代价最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dist[j] &lt; mn) &#123;</span><br><span class="line">                mn = dist[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入生成树</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans += dist[u];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 u 更新其他点的最小代价</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= b; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                dist[v] = <span class="built_in">min</span>(dist[v], k[u][v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实好理解不少,可以看出来prim是点驱动的,每次找到代价最小的点,起点任意选择;<br>而kruskal是边驱动的,每次找到代价最小的不成环边,起点选最小边.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最小生成树算法&quot;&gt;&lt;a href=&quot;#最小生成树算法&quot; class=&quot;headerlink&quot; title=&quot;最小生成树算法&quot;&gt;&lt;/a&gt;最小生成树算法&lt;/h2&gt;&lt;h3 id=&quot;kruskal&quot;&gt;&lt;a href=&quot;#kruskal&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-14 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/14/archives-2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/14/archives-2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-14T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7%C2%B7%E5%85%8B%E4%BC%A6%E6%96%AF%E5%9F%BA">克伦斯基wiki</a></p><p>今天翻wiki时通过多次跳转转到了克伦斯基的界面,之前对他的印象只有布尔什维克对他主政政府时期的控诉,以为他只是一个常见的反对派角色.</p><p><img src="/images/2025-12-14-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/1.webp"><br>看完wiki之后才发现他与<em>陈独秀</em>,<em>托洛茨基</em>并无区别,同样是内心向往着一个更加美好,自由的社会,同样是怀有或多或少的高士情怀,但是每况愈下的社会形势迫使他们站出来,担任自己本不想担任的领袖角色,在时代的浪潮下起起落落,最终被推上风口浪尖,只是因为不愿意参与尔虞我诈的政治斗争,狠不下心去为自己谋求应有的利益,怀着革命为人民的期望,最后却成为被革命的对象,从先驱者变成背叛者,不为敌我双方所认同,无路可走,跌下本就不属于自己的神坛,摔得粉碎.<br>被尘封在历史的角落,所有的功绩都被后来者掠夺殆尽.</p><p><strong>他们宛若一颗流星,照亮了整个世界,而后轰然坠落,再无人记得他们.</strong></p><p>这也是我厌恶英雄光环和领袖情结的原因,很多人之所以能够从渺渺众生中脱颖而出,原因便是对自己狠得下心,愿意去做那些旁人坚持不下去或者难以接受的事情,可是如果一个人对自己都能如此狠心,那对待别人又怎么可能会不狠心,不使用一些肮脏的手段,又怎么能让不甘居于人下的自己摘取桂冠,不通过残酷的斗争,又怎么可能胜过同样是英雄俊杰的对手甚至是同志.</p><p>可惜我对自己也狠不下心,又何从说对别人狠心,只好默默地给英雄们让道了.</p><p>之后会出一系列文章分析俄国革命的全流程,之所以写在这,是提醒自己别忘了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7%C2%B7%E5%85%8B%E4%BC%A6%E6%96%AF%E5%9F%BA&quot;&gt;克伦斯基wiki&lt;/a&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-11 数据结构整理-3</title>
    <link href="https://revival-of-hope.github.io/2025/12/11/2025-12-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-3/"/>
    <id>https://revival-of-hope.github.io/2025/12/11/2025-12-11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-3/</id>
    <published>2025-12-11T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>O(n^2)不可取</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><blockquote><p>思路:<br>找到upper_bound,插入后将后面的数组下标加一,重点是找到插入下标.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp=a[i],index=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;temp) index--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;index;j--)&#123;</span><br><span class="line">        a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    a[index]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><blockquote><p>思路与上面相同,只是这次用二分法找到upper_bound</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp=a[i],index=i;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;temp)&#123;</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l=mid<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=l;j--)&#123;</span><br><span class="line">        a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    a[l]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>思路:每次取增量的一半进行分组排序,直到增量为1,保证完全有序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;  <span class="comment">// 外层：缩小 gap</span></span><br><span class="line">        <span class="comment">// 对于当前 gap，进行分组插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;  <span class="comment">// 从 gap 开始，每个元素插入到前面的子序列</span></span><br><span class="line">            <span class="type">int</span> temp = a[i];  <span class="comment">// 当前元素</span></span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="comment">// 在子序列中向后移（步长 gap）</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; a[j - gap] &gt; temp) &#123;</span><br><span class="line">                a[j] = a[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = temp;  <span class="comment">// 插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>每一轮排好一个数字,n个数字排n-1轮</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=a[j<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;a[j])&#123;</span><br><span class="line">            a[j<span class="number">+1</span>]=a[j];</span><br><span class="line">            a[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以直接用swap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = a[l];</span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= pivot) j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a[i] = pivot;</span><br><span class="line">    <span class="keyword">return</span> i;   <span class="comment">// 返回 pivot 最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, l, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(a,<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为参考视频</p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1205817791&bvid=BV1tf421Q7eh&cid=1596291120&p=1"   width="100%"  height="500"  frameborder="0"  allowfullscreen></iframe><blockquote><p>吐槽一下B站直接在分享点嵌入代码给出的是<code>&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=1205817791&amp;bvid=BV1tf421Q7eh&amp;cid=1596291120&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;</code><br>结果只能在很小的一块区域显示,所以我用ai改成了<code>&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=1205817791&amp;bvid=BV1tf421Q7eh&amp;cid=1596291120&amp;p=1&quot; width=&quot;100%&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-09 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/12/09/archives-2025-12-09-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/12/09/archives-2025-12-09-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-12-09T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每当有人给我的开源项目，提出这样或那样的要求，我就给他三个 F，让他自己选一个。<br>Fix it, Fork it, F**k off.<br><a href="https://boyter.org/posts/the-three-f-s-of-open-source/">来源</a></p></blockquote><p>每当我看到一个比较小众的实用开源项目,通常都是只有一个contributer或者一个branch,而issue却有好几个或者几十个,这些issue很少是提修改建议的,更多的是要求增加各种各样的自己想要的需求.</p><p>如果每个人都这样做,从不想到自己加入到这个项目中帮助创建者完善功能,那么开发者的热情将会急速冷却,开源社区也将不复存在,幸好现在还不是这样.</p><blockquote><p>人生有没有意义？人类又有什么意义？<br>我说，人生是有意义的，而人类则是没有意义的。<br>询问人类的存在有没有意义，就等于询问地球或宇宙的存在有没有意义一样，是得不到答案的。<br>人生的意义是什么呢？它的意义就在于为没有意义的人类工作、服务等等，其目的不外乎是使人类生活得更好并得以延续。<br>反正人类是现实的存在，你又是其中一员，你有义务使它发展延续。你只要这样做了，你的人生就具有了意义，或者说价值，并不一定要去理会人类存在的意义。<br><a href="https://ruanyf-weekly.vercel.app/weekly/issue-228">来源</a></p></blockquote><p>要我说这段话只是消极中的乐观而已,人类没有意义,人生也没有意义.</p><p>人类只是感觉的动物,我们当前的体验决定了我们的感受,也正是一次次体验塑造了我们.所以尽管人生没有意义,我还是想去多体验目前所没能看到和听到的一切.</p><p>因此我不愿意沿着别人的老路走,因为这终究是别人的体验,重走一次未免太乏味;但我也不愿意去走一条全新的,险峻的道路,因为我不想让自己遭罪.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每当有人给我的开源项目，提出这样或那样的要求，我就给他三个 F，让他自己选一个。&lt;br&gt;Fix it, Fork it, F**k off.&lt;br&gt;&lt;a href=&quot;https://boyter.org/posts/the-three-f-s-of</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-12-01 数据结构整理-2</title>
    <link href="https://revival-of-hope.github.io/2025/12/01/2025-12-01-dfs%E8%BE%A8%E6%9E%90/"/>
    <id>https://revival-of-hope.github.io/2025/12/01/2025-12-01-dfs%E8%BE%A8%E6%9E%90/</id>
    <published>2025-12-01T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bfs搜索"><a href="#bfs搜索" class="headerlink" title="bfs搜索"></a>bfs搜索</h2><p>特点:使用队列,可以得到最短路径,无论是否会重复访问,都能一个节点一直是最优状态.<br>写法:<br><strong>以大佬的八数码解法为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//转移数组；</span></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(n);</span><br><span class="line">    map&lt;ll,ll&gt; m;</span><br><span class="line">    m[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); <span class="comment">//初始状态入队列</span></span><br><span class="line">        <span class="type">int</span> c[<span class="number">3</span>][<span class="number">3</span>],f=<span class="number">0</span>,g=<span class="number">0</span>,n=u;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">123804765</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(ll j=<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j]=n%<span class="number">10</span>,n/=<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(!c[i][j])f=i,g=j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll nx=f+dx[i],ny=g+dy[i],ns=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nx&lt;<span class="number">0</span>||ny&lt;<span class="number">0</span>||nx&gt;<span class="number">2</span>||ny&gt;<span class="number">2</span>)<span class="keyword">continue</span>; <span class="comment">//越界就不执行</span></span><br><span class="line">            <span class="built_in">swap</span>(c[nx][ny],c[f][g]);</span><br><span class="line">            <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">                <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)ns=ns*<span class="number">10</span>+c[i][j];<span class="comment">//矩阵转数列 </span></span><br><span class="line">            <span class="keyword">if</span>(!m.<span class="built_in">count</span>(ns))</span><br><span class="line">            &#123;</span><br><span class="line">                m[ns]=m[u]<span class="number">+1</span>;<span class="comment">//map去重的同时顺便统计到达这个状态所需的步数</span></span><br><span class="line">                q.<span class="built_in">push</span>(ns);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(c[nx][ny],c[f][g]);<span class="comment">//状态复原</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m[<span class="number">123804765</span>]&lt;&lt;endl; <span class="comment">// map的下标直接用数列表示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dfs搜索"><a href="#dfs搜索" class="headerlink" title="dfs搜索"></a>dfs搜索</h2><p>特点:有时候会使用栈,可以得到方案总数,有次数要求时使用这个方法.<br>写法:<br><strong>以最经典的八皇后问题为例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> col[N], d1[N], d2[N];  <span class="comment">// 列、主对角线、副对角线标记</span></span><br><span class="line"><span class="type">int</span> pos[N];                <span class="comment">// pos[x] = 皇后在第 x 行放的列号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                cout &lt;&lt; pos[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[c] || d1[row + c] || d2[row - c + n]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        col[c] = d1[row + c] = d2[row - c + n] = <span class="number">1</span>;</span><br><span class="line">        pos[row] = c;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        col[c] = d1[row + c] = d2[row - c + n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到,无论是dfs还是bfs,重点是将当前状态判定后再重置状态,保证后来的方案不会受到这次修改影响.</p><h2 id="dfs解疑"><a href="#dfs解疑" class="headerlink" title="dfs解疑"></a>dfs解疑</h2><p>dfs有两种结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll sum)</span> </span>&#123;  <span class="comment">// 前一半</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">push_back</span>(sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(l<span class="number">+1</span>, r, sum);        <span class="comment">// 不选</span></span><br><span class="line">    <span class="built_in">dfs1</span>(l<span class="number">+1</span>, r, sum + a[l]);  <span class="comment">// 选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种就像背包问题,一般都能用动态规划解决,每一步都只有两个分支</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= n; c++) &#123;</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在每一步都有多个选择</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bfs搜索&quot;&gt;&lt;a href=&quot;#bfs搜索&quot; class=&quot;headerlink&quot; title=&quot;bfs搜索&quot;&gt;&lt;/a&gt;bfs搜索&lt;/h2&gt;&lt;p&gt;特点:使用队列,可以得到最短路径,无论是否会重复访问,都能一个节点一直是最优状态.&lt;br&gt;写法:&lt;br&gt;&lt;stron</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-29 神奇的cocos2d-x</title>
    <link href="https://revival-of-hope.github.io/2025/11/29/archives-2025-11-29-%E7%A5%9E%E5%A5%87%E7%9A%84cocos2d-x/"/>
    <id>https://revival-of-hope.github.io/2025/11/29/archives-2025-11-29-%E7%A5%9E%E5%A5%87%E7%9A%84cocos2d-x/</id>
    <published>2025-11-29T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<p>由于课程作业要求用cocos2d-x完成,把我折腾的够呛.<br>以下是我的心路历程:</p><p>选用cc4.0版本,由于要求用python2编译,尽管我删除了python3的环境变量,但cmd在编译的时候还是用了python3,windows系统不得不品的一环,<br>-&gt;<br>狠下心卸载了python3,重置了python2,终于能够正常运行cmd里的cocos命令了,一打开vs看的我满头雾水.<br>-&gt;<br>于是去官网找教程,<br><a href="https://docs.cocos2d-x.org/cocos2d-x/v4/zh/basic_concepts/sprites.html"></a><br>谁想官网的教程基本啥都没教,甚至不会教我在一个新建cpp文件里要包含哪些东西,而是填鸭式的讲一些分块组件,于是放弃看教程<br>-&gt;<br>找到了cocos安装时自带的test项目,一运行,发现连官方的test的项目都跑不了,官网教程甚至没教我怎么运行这个test项目,于是换成3.17.2,还试了试github上其他的项目,可能是我打开的方法不对,总有或多或少的小问题<br>-&gt;<br>仔细研究,看了看test项目里的cmakelists<br>贴一小段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">     Classes/controller.h</span><br><span class="line">     Classes/TransitionsTest/TransitionsTest.h</span><br><span class="line">     Classes/TextureCacheTest/TextureCacheTest.h</span><br><span class="line">     Classes/MotionStreakTest/MotionStreakTest.h</span><br><span class="line">     Classes/ExtensionsTest/AssetsManagerExTest/AssetsManagerExTest.h</span><br><span class="line">     Classes/ExtensionsTest/ExtensionsTest.h</span><br><span class="line">     Classes/ExtensionsTest/TableViewTest/CustomTableViewCell.h</span><br><span class="line">     Classes/ExtensionsTest/TableViewTest/TableViewTestScene.h</span><br><span class="line">     Classes/ExtensionsTest/NetworkTest/WebSocketTest.h</span><br><span class="line">     Classes/ExtensionsTest/NetworkTest/WebSocketDelayTest.h</span><br><span class="line">     Classes/ExtensionsTest/NetworkTest/SocketIOTest.h</span><br><span class="line">     Classes/ExtensionsTest/NetworkTest/HttpClientTest.h</span><br><span class="line">     Classes/Sprite3DTest/Sprite3DTest.h</span><br><span class="line">     Classes/Sprite3DTest/DrawNode3D.h</span><br><span class="line">     Classes/BaseTest.h</span><br><span class="line">     Classes/SceneTest/SceneTest.h</span><br><span class="line">     Classes/ReleasePoolTest/ReleasePoolTest.h</span><br><span class="line">     Classes/InputTest/MouseTest.h</span><br><span class="line"><span class="comment">#     Classes/SpineTest/SpineTest.h</span></span><br><span class="line"><span class="comment">#     Classes/Scene3DTest/Scene3DTest.h</span></span><br><span class="line">     Classes/ParticleTest/ParticleTest.h</span><br><span class="line">     Classes/EffectsTest/EffectsTest.h</span><br><span class="line">     Classes/UITest/UITest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIScrollViewTest/UIScrollViewTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/CocosGUIScene.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITabControlTest/UITabControlTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITextFieldTest/UITextFieldTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITextBMFontTest/UITextBMFontTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIImageViewTest/UIImageViewTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UISliderTest/UISliderTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UILoadingBarTest/UILoadingBarTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIEditBoxTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIRichTextTest/UIRichTextTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIScene.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIPageViewTest/UIPageViewTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIButtonTest/UIButtonTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIScale9SpriteTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIWidgetAddNodeTest/UIWidgetAddNodeTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIListViewTest/UIListViewTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UISceneManager.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIRadioButtonTest/UIRadioButtonTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UILayoutTest/UILayoutTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITextAtlasTest/UITextAtlasTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UICheckBoxTest/UICheckBoxTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UIFocusTest/UIFocusTest.h</span><br><span class="line">     Classes/UITest/CocoStudioGUITest/UITextTest/UITextTest.h</span><br><span class="line">     Classes/DrawPrimitivesTest/DrawPrimitivesTest.h</span><br><span class="line">     Classes/BillBoardTest/BillBoardTest.h</span><br><span class="line">     Classes/SpriteFrameCacheTest/SpriteFrameCacheTest.h</span><br><span class="line">     Classes/EffectsAdvancedTest/EffectsAdvancedTest.h</span><br><span class="line">     Classes/SchedulerTest/SchedulerTest.h</span><br><span class="line">     Classes/MultiTouchTest/MultiTouchTest.h</span><br><span class="line">     Classes/testResource.h</span><br><span class="line">     Classes/ShaderTest/ShaderTest.vsh.h</span><br><span class="line">     Classes/ShaderTest/shaderTest.psh.h</span><br><span class="line">     Classes/ShaderTest/ShaderTest.h</span><br><span class="line">     Classes/ShaderTest/ShaderTest2.h</span><br><span class="line">     Classes/NewRendererTest/NewRendererTest.h</span><br><span class="line">     Classes/SpritePolygonTest/SpritePolygonTest.h</span><br><span class="line">     Classes/TexturePackerEncryptionTest/TextureAtlasEncryptionTest.h</span><br></pre></td></tr></table></figure><p>这怎么还一个个自己填呢<br>-&gt;<br>默默地换回cc4.0,继续受苦<br>-&gt;<br><a href="https://www.cnblogs.com/geore/p/5793864.html">找到了古早博客</a><br>但版本不是4.0的,不过对照着还能看<br>-&gt;<br><a href="https://www.freesion.com/article/7454340813/">好的,终于找到了</a><br>cocos run –proj-dir .. -p win32<br>发现这个确实就在readme.md里,好吧,是我没认真看文档…<br>![](images&#x2F;2025-11-29 神奇的cocos2d-x&#x2F;image.png)<br>好的,我不该抱着什么希望的.<br>-&gt;<br><a href="https://forum.cocos.org/t/topic/120754">好滴,又找到高人了</a><br>官方把这些问题整合一下会死吗,哈哈,不过cocos死的也差不多了.<br>-&gt;<br>好的,还是跑不了,显然test里的项目用的是vs 2010,根本兼容不了,<br>于是又换成了3.17.2里的测试项目,原来一开始自带了build好的文件,他也知道新手自己跑不了,<br>现在终于能跑测试项目了,接下来可以好好研究变量的使用了(玄学)<br>-&gt;</p><h2 id="cocos命令"><a href="#cocos命令" class="headerlink" title="cocos命令"></a>cocos命令</h2><p>cocos new &lt;项目名&gt;  -l cpp 当前目录下生成<br>cmake -S . -B build -G “Visual Studio 17 2022” -A win32 -T v143  在新项目里强制改cmake方式.<br>新增加文件时,在cmake里面加入对应的文件路径<br>再运行<code>cmake ..</code>就行了</p><h2 id="研究场景创建"><a href="#研究场景创建" class="headerlink" title="研究场景创建"></a>研究场景创建</h2><p><strong>1.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cocos2d.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __HELLOWORLD_SCENE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HELLOWORLD_SCENE_H__ <span class="comment">//防止反复包含同一头文件</span></span></span><br><span class="line">USING_NS_CC; <span class="comment">//using namespace cocos2d,意义不明的缩写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> : <span class="keyword">public</span> cocos2d::Scene <span class="comment">//继承cocos2d命名空间下的scene类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">override</span></span>;  </span><br><span class="line">    <span class="comment">//override作为关键字,要求重写scene内的这个init()函数与现在这个函数必须同名,否则报错.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> cocos2d::Scene* <span class="title">scene</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//把这个函数开放给appdelegate.cpp使用</span></span><br><span class="line">    <span class="comment">// a selector callback</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">menuCloseCallback</span><span class="params">(Ref* sender)</span></span>;</span><br><span class="line">/</span><br><span class="line">    <span class="comment">// implement the &quot;static create()&quot; method manually</span></span><br><span class="line">    <span class="built_in">CREATE_FUNC</span>(HelloWorld);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>1.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">USING_NS_CC;</span><br><span class="line"></span><br><span class="line"><span class="function">Scene* <span class="title">HelloWorld::scene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> HelloWorld::<span class="built_in">create</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HelloWorld::init</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//内部实现所有自己要搞的功能,重载原Scene对象的init()函数</span></span><br><span class="line">    <span class="keyword">auto</span> visibleSize = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleSize</span>();</span><br><span class="line">    <span class="comment">//窗口对角线向量</span></span><br><span class="line">    <span class="keyword">auto</span> origin = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getVisibleOrigin</span>();</span><br><span class="line">    <span class="comment">//左下角(0,0)</span></span><br><span class="line">    <span class="comment">// 2. add a menu item with &quot;X&quot; image, which is clicked to quit the program</span></span><br><span class="line">    <span class="comment">//    you may modify it.</span></span><br><span class="line">    <span class="keyword">auto</span> closeItem = MenuItemImage::<span class="built_in">create</span>(</span><br><span class="line">                                        <span class="string">&quot;CloseNormal.png&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;CloseSelected.png&quot;</span>,</span><br><span class="line">                                        <span class="built_in">CC_CALLBACK_1</span>(HelloWorld::menuCloseCallback,<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//第一个是未选中时的图片,第二个是选中时的图片</span></span><br><span class="line"><span class="comment">//第三个是回调函数</span></span><br><span class="line">    closeItem-&gt;<span class="built_in">setPosition</span>(origin + <span class="built_in">Vec2</span>(visibleSize) - <span class="built_in">Vec2</span>(closeItem-&gt;<span class="built_in">getContentSize</span>() / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> menu = Menu::<span class="built_in">create</span>(closeItem, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">//此时menu已经和closeitem绑定,位置也相互绑定</span></span><br><span class="line">    menu-&gt;<span class="built_in">setPosition</span>(Vec2::ZERO);</span><br><span class="line">    <span class="comment">//但还是要先初始化一下位置,sb cocos</span></span><br><span class="line">    <span class="comment">//而且莫名其妙这里就变成相对位置了</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(menu, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//调用addchild方法置于图层1,不然会被初始图层0覆盖 </span></span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line">    <span class="comment">// 3. add your codes below...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add a label shows &quot;Hello World&quot;</span></span><br><span class="line">    <span class="comment">// create and initialize a label</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> label = Label::<span class="built_in">createWithTTF</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;fonts/arial.ttf&quot;</span>, TITLE_FONT_SIZE);</span><br><span class="line"><span class="comment">//注意到这里的font size需要手动指明,没有默认字体大小给你</span></span><br><span class="line">    <span class="comment">// position the label on the center of the screen</span></span><br><span class="line">    label-&gt;<span class="built_in">setPosition</span>(origin.x + visibleSize.width/<span class="number">2</span>,</span><br><span class="line">                            origin.y + visibleSize.height - label-&gt;<span class="built_in">getContentSize</span>().height);</span><br><span class="line"><span class="comment">//注意到这不是函数重载,只传入二维向量时要写明vec2方法以接收两个参数</span></span><br><span class="line">    <span class="comment">// add the label as a child to this layer</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(label, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add &quot;HelloWorld&quot; splash screen&quot;</span></span><br><span class="line">    <span class="keyword">auto</span> sprite = Sprite::<span class="built_in">create</span>(<span class="string">&quot;HelloWorld.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position the sprite on the center of the screen</span></span><br><span class="line">    sprite-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(visibleSize / <span class="number">2</span>) + origin);</span><br><span class="line">    <span class="comment">//如果默认从(0,0)开始又为什么要把origin加上去呢</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add the sprite as a child to this layer</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addChild</span>(sprite);</span><br><span class="line">    <span class="comment">//神奇的是精灵放在-1不会被覆盖,可能默认精灵不会重叠吧</span></span><br><span class="line">    <span class="keyword">auto</span> drawNode = DrawNode::<span class="built_in">create</span>();</span><br><span class="line">    drawNode-&gt;<span class="built_in">setPosition</span>(<span class="built_in">Vec2</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">addChild</span>(drawNode);</span><br><span class="line"></span><br><span class="line">    Rect safeArea = Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getSafeAreaRect</span>();</span><br><span class="line">    drawNode-&gt;<span class="built_in">drawRect</span>(safeArea.origin, safeArea.origin + safeArea.size, Color4F::BLUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWorld::menuCloseCallback</span><span class="params">(Ref* sender)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Director::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁实例吗</span></span><br></pre></td></tr></table></figure><p>短短几行,够我研究了.<br><a href="https://blog.csdn.net/qq_42048450/article/details/117282640">虚函数了解</a></p><h2 id="研究appdelegate"><a href="#研究appdelegate" class="headerlink" title="研究appdelegate"></a>研究appdelegate</h2><p><strong>appdelegate.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">AppDelegate::<span class="built_in">AppDelegate</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line">AppDelegate::~<span class="built_in">AppDelegate</span>() </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小心翼翼的构造与析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppDelegate::initGLContextAttrs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLContextAttrs glContextAttrs = &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    GLView::<span class="built_in">setGLContextAttrs</span>(glContextAttrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没必要管的底层画布函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AppDelegate::applicationDidFinishLaunching</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize director</span></span><br><span class="line">    <span class="keyword">auto</span> director = Director::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> glview = director-&gt;<span class="built_in">getOpenGLView</span>();</span><br><span class="line">    <span class="keyword">if</span>(!glview) &#123;</span><br><span class="line">        glview = GLViewImpl::<span class="built_in">create</span>(<span class="string">&quot;Cpp Empty Test&quot;</span>);</span><br><span class="line">        <span class="comment">//窗口标题设定</span></span><br><span class="line">        director-&gt;<span class="built_in">setOpenGLView</span>(glview);</span><br><span class="line">    &#125;</span><br><span class="line">    glview-&gt;<span class="built_in">setIcon</span>(icons);</span><br><span class="line"></span><br><span class="line">    director-&gt;<span class="built_in">setOpenGLView</span>(glview);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the design resolution</span></span><br><span class="line">    glview-&gt;<span class="built_in">setDesignResolutionSize</span>(designResolutionSize.width, </span><br><span class="line">    designResolutionSize.height, ResolutionPolicy::NO_BORDER);</span><br><span class="line"></span><br><span class="line">    Size frameSize = glview-&gt;<span class="built_in">getFrameSize</span>();</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; searchPath;</span><br><span class="line">    <span class="comment">// Create a scene. it&#x27;s an autorelease object</span></span><br><span class="line">    <span class="keyword">auto</span> scene = HelloWorld::<span class="built_in">scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run</span></span><br><span class="line">    director-&gt;<span class="built_in">runWithScene</span>(scene);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="官方cpp-empty-test-项目"><a href="#官方cpp-empty-test-项目" class="headerlink" title="官方cpp_empty_test 项目"></a>官方cpp_empty_test 项目</h2><p><strong>AppMacros.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Resource mediumResource =  &#123; cocos2d::<span class="built_in">Size</span>(<span class="number">1024</span>, <span class="number">768</span>),  <span class="string">&quot;ipad&quot;</span>   &#125;;</span><br><span class="line"><span class="comment">//设置窗口尺寸</span></span><br></pre></td></tr></table></figure><h2 id="cpp-test-项目"><a href="#cpp-test-项目" class="headerlink" title="cpp_test 项目"></a>cpp_test 项目</h2><p>由于沟槽的项目文件不是按照教程步骤归类,找起来头疼.<br>![](images&#x2F;2025-11-29 神奇的cocos2d-x&#x2F;tmpC6C9.png)</p><p>发现这样写成纯吐槽了,重开一个帖子来写汇总心得.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于课程作业要求用cocos2d-x完成,把我折腾的够呛.&lt;br&gt;以下是我的心路历程:&lt;/p&gt;
&lt;p&gt;选用cc4.0版本,由于要求用python2编译,尽管我删除了python3的环境变量,但cmd在编译的时候还是用了python3,windows系统不得不品的一环,&lt;br</summary>
      
    
    
    
    
    <category term="新技术" scheme="https://revival-of-hope.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-28 一些感想</title>
    <link href="https://revival-of-hope.github.io/2025/11/28/2025-11-28-%E6%88%91%E4%B8%8D%E5%96%9C%E6%AC%A2%E5%A4%9A%E8%AF%B4%E8%AF%9D/"/>
    <id>https://revival-of-hope.github.io/2025/11/28/2025-11-28-%E6%88%91%E4%B8%8D%E5%96%9C%E6%AC%A2%E5%A4%9A%E8%AF%B4%E8%AF%9D/</id>
    <published>2025-11-28T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="夸夸其谈"><a href="#夸夸其谈" class="headerlink" title="夸夸其谈"></a>夸夸其谈</h2><p>辩论和夸夸其谈我向来是比较厌恶的,当我为了应酬而和别人侃天侃地时,如果涉及我不熟悉的领域,我会尽量闭嘴,多倾听,少发言,克制自己去说一些断然的判断(开玩笑除外).<br>如果有人在一边夸夸其谈,明明自己完全不熟悉这个领域,却在一板一眼的引用ai的话语,不去自己思考时,我就不太看得起他了.</p><h2 id="国外课程"><a href="#国外课程" class="headerlink" title="国外课程"></a>国外课程</h2><p>很多人都觉得国外的课程好的不得了,认为学完这些课程就能真正掌握自己要学的知识了,却没想到掌握知识最重要的是独立思考和反复练习.<br>老师是否教的好当然也有关系,但国内国外所要教的知识都大差不差,只是国内的讲师倾向于结果式教学,忽略了思考环节,不能从底层开始给你清楚的讲授原理罢了,而国外讲师会在课程中加入对原理的讲授,减少你独立思考的难度.<br>但我们终归是要自己去思考这些原理的,如果把思考过程全都挑明了,对知识的掌握程度反而不如上国内课程所能获得的,但如果仅仅是为了应试的话,那还是上国外课程更好了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;夸夸其谈&quot;&gt;&lt;a href=&quot;#夸夸其谈&quot; class=&quot;headerlink&quot; title=&quot;夸夸其谈&quot;&gt;&lt;/a&gt;夸夸其谈&lt;/h2&gt;&lt;p&gt;辩论和夸夸其谈我向来是比较厌恶的,当我为了应酬而和别人侃天侃地时,如果涉及我不熟悉的领域,我会尽量闭嘴,多倾听,少发言,克制</summary>
      
    
    
    
    
    <category term="感想" scheme="https://revival-of-hope.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-28 每日阅读</title>
    <link href="https://revival-of-hope.github.io/2025/11/28/archives-2025-11-28-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    <id>https://revival-of-hope.github.io/2025/11/28/archives-2025-11-28-%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</id>
    <published>2025-11-28T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.510Z</updated>
    
    <content type="html"><![CDATA[<ol><li><blockquote><p>生命太短暂，不能花在那些不值得阅读的内容上面。<br>就算你是一个很爱读书的人，活到70岁最多大概能阅读15000本书，这只占世界最大图书馆美国国会图书馆3800万册藏书的0.04%。<br>我们一生中能够阅读的书籍其实很少。因此，关键技能不是多读，而是跳过那些不值得读的内容。<br><a href="https://news.ycombinator.com/item?id=34310318">– Hacker News 读者</a></p></blockquote></li><li><blockquote><p>有些领域变化非常快，在有人写书之前，博客有时是唯一的信息来源。Stable diffusion 模型出现后的第二天，人们就已经在写博客了，书籍永远不会那么快。<br>而且，博客往往是免费的，而书籍和论文则被锁定在付费墙之后。因此，你可以这么认为，博客获取灵感，书籍获取知识<br><a href="https://news.ycombinator.com/item?id=34310109">– Hacker News 读者</a></p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;生命太短暂，不能花在那些不值得阅读的内容上面。&lt;br&gt;就算你是一个很爱读书的人，活到70岁最多大概能阅读15000本书，这只占世界最大图书馆美国国会图书馆3800万册藏书的0.04%。&lt;br&gt;我们一生中能够阅读的书籍其实很少。因此</summary>
      
    
    
    
    
    <category term="每日阅读" scheme="https://revival-of-hope.github.io/tags/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-27 数据结构整理-1</title>
    <link href="https://revival-of-hope.github.io/2025/11/27/2025-11-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://revival-of-hope.github.io/2025/11/27/2025-11-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2025-11-27T00:00:00.000Z</published>
    <updated>2025-12-21T07:49:38.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h2><p>模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        string k;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            a[i]=a[i]*mod1+k[j];</span><br><span class="line">            b[i]=b[i]*mod2+k[j];</span><br><span class="line">            <span class="comment">//这里的mod1和mod2可以是某个大质数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==a[j]&amp;&amp;b[i]==b[j]) flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><a href="https://oi-wiki.org/dp/knapsack/">参考链接</a></p><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>每个物品只取一次.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = W; l &gt;= w[i]; l--) </span><br><span class="line">        f[l] = <span class="built_in">max</span>(f[l], f[l - w[i]] + v[i]);</span><br><span class="line">    <span class="comment">//每一次只考虑一个物品,逆向确保一个物品只考虑一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>每个物品都能选无数次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = w[i]; l &lt;= W; l++)</span><br><span class="line">      <span class="keyword">if</span> (f[l - w[i]] + v[i] &gt; f[l]) f[l] = f[l -  w[i]] + v[i];</span><br><span class="line">      <span class="comment">//正向确保可以反复选同一个物品</span></span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>每个物品能选的次数有限<br><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> weight = W; weight &gt;= w[i]; weight--) &#123;</span><br><span class="line">    <span class="comment">// 多遍历一层物品数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k * w[i] &lt;= weight &amp;&amp; k &lt;= cnt[i]; k++) &#123;</span><br><span class="line">      dp[weight] = <span class="built_in">max</span>(dp[weight], dp[weight - k * w[i]] + k * v[i]);</span><br><span class="line">      <span class="comment">//看成01背包</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进一步优化</strong><br>二进制拆分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (num[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">min</span>(k, num[i]);</span><br><span class="line">            <span class="type">int</span> weight = cnt * w[i];</span><br><span class="line">            <span class="type">int</span> value  = cnt * v[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 0-1 背包更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=W; j&gt;=weight; j--) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j-weight] + value);</span><br><span class="line">            &#125;</span><br><span class="line">            num[i] -= cnt;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>单调队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">       <span class="comment">// 对每个余数 r = 0..wi-1</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> r=<span class="number">0</span>; r&lt;wi; r++) &#123;</span><br><span class="line">           deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q; <span class="comment">// pair&lt;value, index m&gt;</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>, j=r; j&lt;=W; k++, j+=wi) &#123;</span><br><span class="line">               <span class="type">int</span> val = f[j] - k*vi;  <span class="comment">// f[j - k*wi] - k*vi</span></span><br><span class="line">               <span class="comment">// 弹出不在窗口的队头</span></span><br><span class="line">               <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; k - q.<span class="built_in">front</span>().second &gt; mi) q.<span class="built_in">pop_front</span>();</span><br><span class="line">               <span class="comment">// 单调递减</span></span><br><span class="line">               <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">back</span>().first &lt;= val) q.<span class="built_in">pop_back</span>();</span><br><span class="line">               q.<span class="built_in">push_back</span>(&#123;val, k&#125;);</span><br><span class="line">               f[j] = q.<span class="built_in">front</span>().first + k*vi;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>背包问题最重要的是把状态转移想清楚,每次将新物品加入背包时,这个物品是无限的还是有一定次数的.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hash表&quot;&gt;&lt;a href=&quot;#hash表&quot; class=&quot;headerlink&quot; title=&quot;hash表&quot;&gt;&lt;/a&gt;hash表&lt;/h2&gt;&lt;p&gt;模板:&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://revival-of-hope.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2025-11-26 影评-宋飞正传(20世纪最伟大的电视剧)</title>
    <link href="https://revival-of-hope.github.io/2025/11/26/archives-2025-11-26-%E5%BD%B1%E8%AF%84-%E5%AE%8B%E9%A3%9E%E6%AD%A3%E4%BC%A0-20%E4%B8%96%E7%BA%AA%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E7%94%B5%E8%A7%86%E5%89%A7/"/>
    <id>https://revival-of-hope.github.io/2025/11/26/archives-2025-11-26-%E5%BD%B1%E8%AF%84-%E5%AE%8B%E9%A3%9E%E6%AD%A3%E4%BC%A0-20%E4%B8%96%E7%BA%AA%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E7%94%B5%E8%A7%86%E5%89%A7/</id>
    <published>2025-11-26T00:00:00.000Z</published>
    <updated>2025-12-21T14:03:04.255Z</updated>
    
    <content type="html"><![CDATA[<p>这两个月看完了宋飞正传全九季,不得不承认它确实称得上是最伟大的电视剧.</p><p>一般的喜剧到后期灵感有些枯竭时,便想方设法加入一些主角们的情感戏来充实一下贫乏的剧集内容,无论是生活大爆炸,老友记还是老爸老妈恋爱史,到了后期总显得没有一开始那么好笑了,原因便是真正的包袱少了,以主人公本身特点来制作的包袱多了,如果前面几季都没看过,会觉得有点莫名其妙.</p><p>然而宋飞正传不是这样,尽管后期有那么三四集有部分的包袱不够响,也有部分小片段是基于前几季的剧情来扩展的,但基本上来说从头到尾都是好笑的,包袱源源不断,每一集主人公们都会遇到各种各样有趣的事情,而这些事情彼此之间互不关联,从来没有一条分明的主线,主角们的关系整整九季都没变过,讲述的仅仅是关于他们普通而又特别的日常生活,无论什么时候,随便切入哪一集,都充斥着滑稽的片段,这对观众来说就足够了,而这恰恰是其他喜剧所做不到的.</p><p>宋飞正传也是除了&lt;&lt;是,大臣&gt;&gt;以外我唯一计划再重温一遍的优秀喜剧.人生如戏,娱乐而已,平淡就好.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两个月看完了宋飞正传全九季,不得不承认它确实称得上是最伟大的电视剧.&lt;/p&gt;
&lt;p&gt;一般的喜剧到后期灵感有些枯竭时,便想方设法加入一些主角们的情感戏来充实一下贫乏的剧集内容,无论是生活大爆炸,老友记还是老爸老妈恋爱史,到了后期总显得没有一开始那么好笑了,原因便是真正的包袱</summary>
      
    
    
    
    
    <category term="影评" scheme="https://revival-of-hope.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2026-01-15 计算机组成原理复习 | 独角恋歌</title><meta name="author" content="Revival-of-hope"><meta name="copyright" content="Revival-of-hope"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="考试事项 考试分数占比60% 填空15分 一空一分 选择20分 20道题 综合题65分 七道大题,基本一个章节一道题 重要的杂项 片选信号 CS(chip select): 片选信号,低电平有效,通过地址逻辑生成,故在原理图中一般都在上面加一横来表示 译码器 译码器(decoder)是一种具有“翻译”功能的多输入多输出的组合逻辑电路器件。 译码器的功能：将每一组编码序列信号转换为一个特定的输出信号">
<meta property="og:type" content="article">
<meta property="og:title" content="2026-01-15 计算机组成原理复习">
<meta property="og:url" content="https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="独角恋歌">
<meta property="og:description" content="考试事项 考试分数占比60% 填空15分 一空一分 选择20分 20道题 综合题65分 七道大题,基本一个章节一道题 重要的杂项 片选信号 CS(chip select): 片选信号,低电平有效,通过地址逻辑生成,故在原理图中一般都在上面加一横来表示 译码器 译码器(decoder)是一种具有“翻译”功能的多输入多输出的组合逻辑电路器件。 译码器的功能：将每一组编码序列信号转换为一个特定的输出信号">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://revival-of-hope.github.io/images/archives/2026-01-18/67962380_p0-%E5%A4%A2%E4%B8%AD.webp">
<meta property="article:published_time" content="2026-01-15T00:00:00.000Z">
<meta property="article:modified_time" content="2026-02-01T03:53:25.534Z">
<meta property="article:author" content="Revival-of-hope">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://revival-of-hope.github.io/images/archives/2026-01-18/67962380_p0-%E5%A4%A2%E4%B8%AD.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2026-01-15 计算机组成原理复习",
  "url": "https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/",
  "image": "https://revival-of-hope.github.io/images/archives/2026-01-18/67962380_p0-%E5%A4%A2%E4%B8%AD.webp",
  "datePublished": "2026-01-15T00:00:00.000Z",
  "dateModified": "2026-02-01T03:53:25.534Z",
  "author": [
    {
      "@type": "Person",
      "name": "Revival-of-hope",
      "url": "https://github.com/revival-of-hope"
    }
  ]
}</script><link rel="shortcut icon" href="/img/%E7%AA%97%E5%8F%B0%E7%9C%8B%E9%A3%8E.jpg"><link rel="canonical" href="https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css?v=5.5.3-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-J0CZ5BV4V7"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-J0CZ5BV4V7')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-J0CZ5BV4V7', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":300,"languages":{"author":"Author: Revival-of-hope","link":"Link: ","source":"Source: 独角恋歌","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2026-01-15 计算机组成原理复习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/rss.xml" title="独角恋歌" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/56866134_p0-%E6%A2%85%E9%9B%A8%E3%81%AE%E6%99%B4%E3%82%8C%E9%96%93.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/reimu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"><i class="fa-fw fas fa-bolt"></i><span> 动态更新</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/archives/2026-01-18/67962380_p0-%E5%A4%A2%E4%B8%AD.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">2026-01-15 计算机组成原理复习</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/categories/%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0/"><i class="fa-fw fas fa-bolt"></i><span> 动态更新</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">2026-01-15 计算机组成原理复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-15T00:00:00.000Z" title="Created 2026-01-15 08:00:00">2026-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-01T03:53:25.534Z" title="Updated 2026-02-01 11:53:25">2026-02-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>37mins</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:730,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2026-02-01 11:53:25&quot;}" hidden></div><h2 id="考试事项">考试事项</h2>
<p>考试分数占比60%<br>
填空15分 一空一分<br>
选择20分 20道题<br>
综合题65分 七道大题,基本一个章节一道题</p>
<h2 id="重要的杂项">重要的杂项</h2>
<h3 id="片选信号">片选信号</h3>
<p>CS(chip select): 片选信号,低电平有效,通过地址逻辑生成,故在原理图中一般都在上面加一横来表示</p>
<h3 id="译码器">译码器</h3>
<p>译码器(decoder)是一种具有“翻译”功能的多输入多输出的组合逻辑电路器件。<br>
译码器的功能：将每一组编码序列信号转换为一个特定的输出信号<br>
译码器的输入：一组编码序列信号<br>
译码器的输出：一条特定的译码信号（与每组输入信号对应）<br>
译码器的工作原理：当某组编码进入输入端时，相应的译码线输出为低电平，与此同时，其他所有译码线输出保持为高电平。<br>
通常，译码器的输出端与输入端的数量关系为（2^n）</p>
<h2 id="第一章-概论">第一章 概论</h2>
<h3 id="计算机5个部件的示意图">计算机5个部件的示意图</h3>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_09-42-23.webp" alt="alt text"></p>
<blockquote>
<p>由于运算器(ALU)与控制器都集成在cpu上,因此可以写成下图形式</p>
</blockquote>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_09-44-09.webp" alt="alt text"><br>
而早期的冯诺伊曼结构是这样的<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_09-47-07.webp" alt="alt text"></p>
<h3 id="各部件详解">各部件详解</h3>
<blockquote>
<p>运算器: 算术逻辑单元,用于完成算术运算和逻辑运算<br>
控制器: 计算机的管理机构和指挥中心,协调计算机各部件自动工作<br>
存储器: 计算机的存储部件,用于存储程序和数据,由内存和外存两部分构成<br>
内存: 由大量存储单元组成,构成一个按地址访问的一维线性空间,也称为主存<br>
输入设备: 将程序和数据以计算机能识别的形式输入到计算机内<br>
输出设备: 将计算机处理的结果以人们能接受或其他系统所要求的形式输出到外部世界<br>
操作系统: 最主要的系统软件,负责管理系统资源,为应用程序提供运行环境,为用户提供操作界面</p>
</blockquote>
<hr>
<p>其中,控制器由以下6部分构成:</p>
<ol>
<li>指令寄存器(IR): 用于存放当前正在执行的指令</li>
<li>程序计数器(PC): 用于存放当前正在执行的指令的地址</li>
<li>指令译码器: 对指令进行译码,形成相应的控制信号</li>
<li>时钟脉冲(CP): 协调计算机各部件的同步主时钟,工作频率称为计算机的<strong>主频</strong></li>
<li>时序信号发生器: 按时间顺序发出节拍信号</li>
<li>微操作控制部件: 根据时序信号发生器的节拍信号和指令译码器的译码结果产生微操作控制信号给各个计算机部件</li>
</ol>
<blockquote>
<p>而运算部件由运算器和通用寄存器组构成,寄存器组用于暂存运算数据和中间结果<br>
内存则由存储体,地址寄存器AR,数据寄存器DR三部分构成</p>
</blockquote>
<h3 id="计算机的性能指标">计算机的性能指标</h3>
<ol>
<li>主频: 衡量计算机工作速度的主要指标之一</li>
<li>运算速度: 以每秒执行多少条指令或完成多少次浮点运算来表示</li>
<li>基本字长: 直接参与运算的数据的二进制位数,标志着运算精度,位数越多,精度越高</li>
<li>主存容量: 主存能储存信息的总量</li>
<li>主存存取周期: 对主存连续两次访问的最小时间间隔</li>
<li>外部设备的配置</li>
</ol>
<blockquote>
<p>其中运算速度由两种计量单位,分别是</p>
</blockquote>
<ol>
<li>MIPS:百万条指令/秒(million instructions per second)</li>
<li>MFLOPS:百万次浮点运算/秒(million flops per second)</li>
</ol>
<h2 id="第二章-数的表示-作为第十章的基础">第二章 数的表示（作为第十章的基础）</h2>
<blockquote>
<p><strong>机器数</strong>：用二进制编码表示的数据<br>
在计算机中，常用 <strong>原码、补码、反码</strong> 三种方法来表示带符号的机器数</p>
</blockquote>
<hr>
<ul>
<li>下面的.表示拼接</li>
</ul>
<h3 id="原码表示法">原码表示法</h3>
<p><strong>定义</strong><br>
原码由 <strong>符号位 + 数值位</strong> 组成</p>
<ul>
<li>符号位 s：0 表示正，1 表示负</li>
<li>数值位表示绝对值的二进制</li>
</ul>
<p><strong>表示公式</strong></p>
<ul>
<li>
<p>正数</p>
<ul>
<li>原码 = 0 · |x|₂</li>
</ul>
</li>
<li>
<p>负数</p>
<ul>
<li>原码 = 1 · |x|₂</li>
</ul>
</li>
</ul>
<ul>
<li><strong>简单说就是负数前面加个1</strong></li>
</ul>
<blockquote>
<p>举例:<br>
[-0.1101]_原=1.1101<br>
[-1101]_原=11101</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>表示直观</li>
<li>存在 +0 与 −0</li>
<li>加减运算用根据符号来判断,但符号位不参与运算</li>
</ul>
<hr>
<h3 id="反码表示法">反码表示法</h3>
<p><strong>定义</strong><br>
补码的中间过程<br>
<strong>表示公式</strong></p>
<ul>
<li>
<p>正数</p>
<ul>
<li>反码 = 原码 = 0 · |x|₂</li>
</ul>
</li>
<li>
<p>负数</p>
<ul>
<li>反码 = 符号位不变，数值位逐位取反</li>
</ul>
</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>存在 +0 与 −0</li>
<li>运算仍不方便</li>
</ul>
<h3 id="补码表示法">补码表示法</h3>
<p><strong>定义</strong><br>
补码是计算机中实际采用的带符号数表示方法</p>
<p><strong>表示公式</strong></p>
<ul>
<li>
<p>正数</p>
<ul>
<li>补码 = 原码 = 0 · |x|₂</li>
</ul>
</li>
<li>
<p>负数</p>
<ul>
<li>补码 = 原码数值位逐位取反 + 1</li>
</ul>
</li>
</ul>
<p><strong>补充说明</strong></p>
<ul>
<li>小数补码中，“加 1”是对最低有效位加 1</li>
<li>若产生进位，直接舍去最高进位</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>只有一个 0</li>
<li>加减法统一为加法</li>
<li>硬件实现简单</li>
</ul>
<h4 id="深入理解">深入理解</h4>
<blockquote>
<p>一个数减去小于模的另一个数,可以用加上模与另一个数的绝对值之差来代替</p>
</blockquote>
<blockquote>
<p>实际上负数的补码是用2的(n+1)次方加上该负数得到的,若负数x有n位,则补码相当于(11…11)n +1 +x,这也就是负数补码之所以要对所有位取反再加一的真相</p>
</blockquote>
<ul>
<li>当最高位即符号位有进位时实际上相当于加上了一个2的(n+1)次方,对结果取模时可以舍去</li>
</ul>
<hr>
<h3 id="移码表示法">移码表示法</h3>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_13-32-56.webp" alt="alt text"></p>
<blockquote>
<p>无论正负均用一个式子表示</p>
</blockquote>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_13-35-46.webp" alt="alt text"></p>
<h3 id="数的浮点表示">数的浮点表示</h3>
<blockquote>
<p>浮点是指小数点的位置不固定,随时浮动</p>
</blockquote>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_13-57-51.webp" alt="alt text"></p>
<p>[<br>
X = M \times 2^{E}<br>
]</p>
<blockquote>
<p>其中：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>：阶码，用定点整数表示,采用移码<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>：尾数，用定点小数表示</p>
</blockquote>
<h4 id="规格化浮点数">规格化浮点数</h4>
<p>当浮点数的基数为 2 时，如果其尾数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 满足：<br>
[<br>
\frac{1}{2} \le |M| &lt; 1<br>
]<br>
则称该浮点数为规格化浮点数</p>
<ul>
<li>很好理解,如果尾数小于1/2,说明有前导0,那么就可以将阶码减小1来消去0</li>
</ul>
<h4 id="例题">例题</h4>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_14-02-32.webp" alt="alt text"></p>
<blockquote>
<p>步骤如下:</p>
</blockquote>
<ol>
<li>先将十进制数化成尾数乘以阶码的形式,</li>
<li>而在实际存储中,将阶码用移码表示,也就是加上2的4次方,从而保证都是正数</li>
<li>再把尾数用补码的形式表示出来,符号位放到最前面的数符位置,数值位放在最后面</li>
</ol>
<h2 id="第六章-计算机执行程序的过程">第六章 计算机执行程序的过程</h2>
<h3 id="指令说明">指令说明</h3>
<h4 id="load-指令-装载寄存器指令">Load 指令（装载寄存器指令）</h4>
<ul>
<li>功能：把一个数据送入指定的寄存器</li>
<li>数据来源：
<ul>
<li>立即数</li>
<li>存储器中的某个单元</li>
</ul>
</li>
</ul>
<hr>
<h4 id="store-指令-存储指令">Store 指令（存储指令）</h4>
<ul>
<li>功能：把指定寄存器中的数据存入存储器的某个单元</li>
</ul>
<hr>
<h4 id="add-指令-加法指令">Add 指令（加法指令）</h4>
<ul>
<li>功能：将两个寄存器中的数据相加,把运算结果存入指定寄存器</li>
</ul>
<hr>
<h4 id="jump-指令-跳转指令">Jump 指令（跳转指令）</h4>
<ul>
<li>功能：跳转到新的地址继续执行指令</li>
</ul>
<hr>
<h3 id="记号说明">记号说明</h3>
<ul>
<li><code>[Rx]</code>：寄存器 Rx 中的内容</li>
<li><code>MEM[y]</code>：存储器中地址为 y 的存储单元内容</li>
<li><code>→</code>：传送（数据流向）</li>
</ul>
<h3 id="指令示例说明">指令示例说明</h3>
<h4 id="第-1-条">第 1 条</h4>
<p><strong>Load R1，200(R0)</strong><br>
MEM[[R0] + 200] → R1<br>
以 R0 为基址，加偏移量 200，将对应存储单元内容送入 R1</p>
<h4 id="第-2-条">第 2 条</h4>
<p><strong>Load R2，#4</strong><br>
4 → R2<br>
4 直接包含在指令中，称为<strong>立即数</strong></p>
<h4 id="第-3-条">第 3 条</h4>
<p><strong>Add R3，R1，R2</strong><br>
[R1] + [R2] → R3<br>
将 R1 与 R2 中的数据相加，结果送入 R3</p>
<h4 id="第-4-条">第 4 条</h4>
<p><strong>Store R3，200(R2)</strong><br>
[R3] → MEM[[R2] + 200]<br>
以 R2 为基址，加偏移量 200，将 R3 的内容存入存储器</p>
<h4 id="第-5-条">第 5 条</h4>
<p><strong>Store R2，@(208)</strong><br>
[R2] → MEM[ MEM[208] ]<br>
@ 表示间接寻址，208 中的内容作为有效地址</p>
<h4 id="第-6-条">第 6 条</h4>
<p><strong>Jump 1000</strong><br>
1000 → PC<br>
将程序计数器 PC 置为 1000，跳转执行</p>
<hr>
<ul>
<li>指令后面跟着的第一个数就是指令操作的结果存储对象,再后面才是这个操作需要的数据</li>
<li>注意到这里的R1,R2,R3都是寄存器(register)</li>
</ul>
<h3 id="第一条指令-load-r1-200-r0-详解">第一条指令**Load R1，200(R0)**详解</h3>
<p><strong>第一步</strong></p>
<ol>
<li>[PC]-&gt;AR,将pc存放的当前指令地址传入地址寄存器AR</li>
<li>从存储体读出对应地址的指令放入数据寄存器DR</li>
<li>将DR送入指令寄存器IR</li>
</ol>
<p><strong>第二步</strong><br>
指令译码器进行译码,结合CP和时序信号发生器产生的节拍信号,产生微操作控制信号</p>
<p><strong>第三步</strong></p>
<ol>
<li>计算访问地址:[R0]+200-&gt;AR
<ol>
<li>[R0]-&gt;ALU,把寄存器R0中的内容送入ALU</li>
<li>IR中的操作数200送入ALU</li>
<li>[ALU]-&gt;AR,ALU进行加法运算,把结果传给AR</li>
</ol>
</li>
<li>从存储器读出数据,送入寄存器R1
<ol>
<li>从存储器中地址200的存储单元读出数据,送入DR</li>
<li>DR-&gt;R1,将DR中的数据送入R1</li>
</ol>
</li>
</ol>
<p><strong>第四步</strong><br>
PC+4,指向下一条指令</p>
<ul>
<li>显然所有指令的第1步(取指令),第2步(指令译码),第4步(PC+4)都是一样的,只是第三步的执行指令有区别</li>
</ul>
<hr>
<h2 id="第七章-指令系统">第七章 指令系统</h2>
<h3 id="指令格式">指令格式</h3>
<blockquote>
<p>一条指令必须包含以下三条信息</p>
</blockquote>
<ol>
<li>要执行的操作</li>
<li>操作的对象</li>
<li>操作的结果(操作结果要保存到哪里)</li>
</ol>
<ul>
<li>操作数:操作码操作的对象数据<br>
<strong>指令的基本格式</strong><br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-17-33.webp" alt="alt text"></li>
</ul>
<h3 id="指令的地址码">指令的地址码</h3>
<p>地址码中的地址可以为0,1个或多个,根据指令中地址码中的地址数量可以分为以下5种指令</p>
<h4 id="零地址指令">零地址指令</h4>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-21-33.webp" alt="alt text"></p>
<blockquote>
<p>通常在两种情况下可能采用零地址指令</p>
</blockquote>
<ol>
<li>指令本身不需要任何操作数</li>
<li>指令中所需的操作数是隐含指定的</li>
</ol>
<h4 id="一地址指令">一地址指令</h4>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-21-59.webp" alt="alt text"></p>
<blockquote>
<p>在两种情况下可能采用一地址指令</p>
</blockquote>
<ol>
<li>指令本身只需要一个操作数,如加1,求补等
<ul>
<li>A &lt;- OP[A]</li>
</ul>
</li>
<li>指令操作需要两个操作数，指令中指明一个操作数，而另外一个操作数在默认的某个地方
<ul>
<li>如 ：累加器AC中，操作结果存放到累加器AC中</li>
<li>AC &lt;- [AC] OP [A]</li>
</ul>
</li>
</ol>
<h4 id="二地址指令">二地址指令</h4>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-26-04.webp" alt="alt text"></p>
<ul>
<li>A1 &lt;- [A1] OP [A2]</li>
</ul>
<blockquote>
<p>根据存放操作数的位置不同，分为3种。</p>
</blockquote>
<ol>
<li>寄存器-寄存器型（R-R型）指令</li>
<li>存储器-存储器型（M-M型）指令</li>
<li>寄存器-存储器型（R-M型）指令</li>
</ol>
<ul>
<li>显然其中一个是用来存放操作结果地址的</li>
</ul>
<h4 id="三地址指令和多地址指令">三地址指令和多地址指令</h4>
<blockquote>
<p>三地址指令被广泛采用,特别是在RISC计算机中</p>
</blockquote>
<blockquote>
<p>多地址指令用于描述一批数据，指令中需要多个地址来指出数据存放的首地址、长度和下标等信息</p>
</blockquote>
<h3 id="指令的操作码">指令的操作码</h3>
<blockquote>
<p>指令系统中的每一条指令都有唯一确定的操作码，不同指令的操作码是不相同的。<br>
操作码的长度决定了指令系统的最大规模。<br>
若操作码的位数为 n 位，则该指令系统最多能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 条指令</p>
</blockquote>
<hr>
<h4 id="固定长度操作码">固定长度操作码</h4>
<blockquote>
<p>所有指令操作码的长度都是固定的，且集中放在指令的一个字段内。<br>
有利于简化硬件设计，减少指令译码时间。<br>
很多现代计算机都采用了固定长度操作码。</p>
</blockquote>
<hr>
<h4 id="可变长度操作码">可变长度操作码</h4>
<p>指令系统中操作码的长度有多种，不同指令的操作码长度不完全相同。</p>
<ul>
<li>使用频率高的指令使用短的操作码</li>
<li>使用频率低的指令使用较长的操作码</li>
</ul>
<p>可以缩短操作码的平均长度，但会使硬件设计复杂化，增加指令译码的时间和难度。</p>
<hr>
<h4 id="扩展操作码">扩展操作码</h4>
<p>将操作码设计为几种不同的固定长度，且相互之间按某种规则进行扩展。</p>
<p><strong>优点</strong></p>
<ul>
<li>可以简化硬件设计；</li>
<li>当指令总长度一定时，可以使操作码的长度随地址数的增加而减少，<br>
不同地址数的指令的操作码长度也不同，从而有效缩短指令总长度。</li>
</ul>
<p><strong>扩展操作码的方法</strong></p>
<ul>
<li>等长扩展</li>
<li>不等长扩展</li>
</ul>
<p><strong>扩展示例</strong><br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-41-26.webp" alt="alt text"></p>
<h3 id="指令长度">指令长度</h3>
<p><strong>指令长度</strong>：指一条指令所包含的二进制代码的总位数。</p>
<p>指令长度主要取决于以下因素：</p>
<ul>
<li>操作码的长度</li>
<li>操作数地址的长度</li>
<li>操作数地址的个数</li>
</ul>
<p>指令长度通常与机器字长存在简单的倍数关系。</p>
<hr>
<h4 id="按与机器字长的关系分类">按与机器字长的关系分类</h4>
<ul>
<li>
<p><strong>单字长指令</strong><br>
指令长度等于机器字长的指令</p>
</li>
<li>
<p><strong>半字长指令</strong><br>
指令长度等于半个机器字长的指令</p>
</li>
<li>
<p><strong>双字长指令</strong><br>
指令长度等于机器字长两倍的指令</p>
</li>
</ul>
<hr>
<ul>
<li>指令长度一般应是<strong>字节的整数倍</strong></li>
</ul>
<h3 id="寻址方式">寻址方式</h3>
<blockquote>
<p>指令的地址码给出的地址不一定是操作数的真正地址,而是形式地址,确定操作数有效地址的方法就叫寻址方式</p>
</blockquote>
<h4 id="直接寻址">直接寻址</h4>
<blockquote>
<p>在指令的地址码字段直接给出操作数所在主存单元的地址。</p>
</blockquote>
<ul>
<li>简单、快速的寻址方式，但寻址范围受限于地址码字段的位数<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-49-37.webp" alt="alt text"></li>
</ul>
<h4 id="间接寻址">间接寻址</h4>
<blockquote>
<p>指令的地址码字段给出的是操作数所在内存单元的地址的地址。</p>
</blockquote>
<ol>
<li>指令中形式地址所指定的内存单元中存放的内容才是操作数的真正地址。</li>
<li>得到操作数需要访问两次内存，指令的执行速度比较慢</li>
</ol>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_17-54-10.webp" alt="alt text"></p>
<h4 id="立即寻址">立即寻址</h4>
<ul>
<li>指令的地址码字段直接给出操作数本身，而不是操作数的地址。</li>
<li>指令执行速度最快，得到指令的同时就得到了操作数，不需要再访问内存。</li>
</ul>
<h4 id="寄存器直接寻址与寄存器间接寻址">寄存器直接寻址与寄存器间接寻址</h4>
<blockquote>
<p>寄存器直接寻址：指令的地址码字段给出一个寄存器编号，该寄存器中存放的内容就是操作数。<br>
寄存器间接寻址：寄存器中存放的内容是操作数的地址，根据此地址访问内存取得操作数。</p>
</blockquote>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-10-32.webp" alt="alt text"></p>
<h4 id="隐含寻址">隐含寻址</h4>
<blockquote>
<p>指令中不给出操作数的地址</p>
</blockquote>
<ul>
<li>操作数约定在某个特定的寄存器或堆栈中</li>
</ul>
<h4 id="pc相对寻址">PC相对寻址</h4>
<blockquote>
<p>将程序计数器PC的内容与指令中给出的形式地址（偏移量）的值相加，形成操作数的有效地址</p>
</blockquote>
<ul>
<li>形式地址（偏移量）的值可正可负。</li>
<li>对于短跳转和程序的再定位很有用。<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-12-10.webp" alt="alt text"></li>
</ul>
<h4 id="变址寻址">变址寻址</h4>
<blockquote>
<p>将指令中给出的形式地址的值与变址寄存器的内容相加，形成操作数的有效地址。</p>
</blockquote>
<ul>
<li>变址寄存器可以是专用寄存器，也可以是通用寄存器中的一个。</li>
<li>常用于字符串处理、数组运算等成批数据处理中，主要是面向用户，解决程序循环控制问题。</li>
<li>通常地址的变化体现在变址寄存器中，指令中的形式地址相对固定。<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-13-41.webp" alt="alt text"></li>
</ul>
<h4 id="基址寻址">基址寻址</h4>
<blockquote>
<p>把指令中给出的形式地址的值与基址寄存器的内容相加，形成操作数的有效地址。</p>
</blockquote>
<blockquote>
<ul>
<li>基址寄存器的内容称为基地址。</li>
<li>主要用于将用户程序的逻辑地址转换成主存的实际地址。它面向系统，解决程序重定位和扩大寻址空间等问题。</li>
<li>通常地址变化体现形式地址上，基地址相对不变。</li>
</ul>
</blockquote>
<h4 id="基址-变址-寻址">“基址+变址”寻址</h4>
<pre><code>     有效地址=（RB）+（RX）+D 
</code></pre>
<p>其中:</p>
<ul>
<li>（RB）：基址寄存器RB中的内容</li>
<li>（RX）：变址寄存器RX中的内容</li>
<li>D：指令字中给出的形式地址（偏移量）</li>
</ul>
<h3 id="指令按功能分类">指令按功能分类</h3>
<ol>
<li>
<blockquote>
<p><strong>数据传送类指令</strong><br>
将数据从一个地方传送到另一个地方</p>
</blockquote>
</li>
</ol>
<ul>
<li>主要实现主存和主存之间、主存和寄存器之间、寄存器和寄存器之间的数据传送。</li>
<li>数据传送指令一次可以传送一个数据，也可以一次传送一批数据。</li>
</ul>
<ol start="2">
<li>
<blockquote>
<p>数据运算类指令<br>
用来实现数据的算术运算、逻辑运算和移位运算</p>
</blockquote>
</li>
</ol>
<ul>
<li>算术运算：加、减、乘、除运算；加1 、减1；比较指令等。</li>
<li>逻辑运算：包括与、或、非 、异或等运算。</li>
<li>移位指令：算术移位、逻辑移位和循环移位三类，它们又可分为左移和右移两种。</li>
</ul>
<ol start="3">
<li>
<blockquote>
<p>程序控制类指令<br>
主要用来控制程序执行的顺序和方向。</p>
</blockquote>
</li>
</ol>
<ul>
<li>包含转移指令、子程序调用和返回指令、自陷指令等</li>
</ul>
<ol start="4">
<li>
<blockquote>
<p>输入输出指令</p>
</blockquote>
</li>
</ol>
<ul>
<li>简称I/O指令,主要用于实现主机与外部设备之间的信息交换</li>
</ul>
<h3 id="指令系统设计">指令系统设计</h3>
<blockquote>
<p>指令系统的设计包括指令的功能设计,指令格式的设计两部分</p>
</blockquote>
<blockquote>
<p>在确定哪些基本功能用硬件来实现时，主要考虑3个因素：速度、成本、灵活性。</p>
</blockquote>
<ul>
<li>硬件实现的特点
<ul>
<li>速度快、成本高、灵活性差</li>
</ul>
</li>
<li>软件实现的特点
<ul>
<li>速度慢、价格便宜、灵活性好</li>
</ul>
</li>
</ul>
<h4 id="对指令系统的基本要求">对指令系统的基本要求</h4>
<ol>
<li>
<blockquote>
<p>完整性：在一个有限可用的存储空间内，对于任何可解的问题，编制计算程序时，指令集所提供的指令足够用。</p>
</blockquote>
</li>
</ol>
<ul>
<li>要求指令集功能齐全、使用方便</li>
</ul>
<ol start="2">
<li>规整性：主要包括对称性和均匀性。</li>
</ol>
<ul>
<li>
<blockquote>
<p>对称性：所有与指令集有关的存储单元的使用,操作码的设置等都是对称的。</p>
</blockquote>
<ul>
<li>例如：在存储单元的使用上，所有通用寄存器都要同等对待。在操作码的设置上，如果设置了A-B的指令，就应该也设置B-A的指令。</li>
</ul>
</li>
<li>
<blockquote>
<p>均匀性：指对于各种不同的操作数类型、字长、操作种类和数据存储单元，指令的设置都要同等对待。</p>
</blockquote>
<ul>
<li>例如：如果某机器有5种数据表示，4种字长，两种存储单元，则要设置5×4×2=40种同一操作的指令。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>
<blockquote>
<p>正交性：指在指令中各个不同含义的字段，如操作类型、数据类型、寻址方式字段等，在编码时应互不相关、相互独立。</p>
</blockquote>
</li>
<li>
<blockquote>
<p>高效率：指指令的执行速度快、使用频度高。</p>
</blockquote>
</li>
<li>
<blockquote>
<p>兼容性：主要是要实现向后兼容，指令系统可以增加新指令，但不能删除指令或更改指令的功能。</p>
</blockquote>
</li>
</ol>
<h4 id="指令格式的设计">指令格式的设计</h4>
<blockquote>
<p>3种常用的指令编码格式:可变长度编码格式、固定长度编码格式、混合型编码格式</p>
</blockquote>
<h5 id="可变长度编码格式">可变长度编码格式</h5>
<blockquote>
<p>当指令系统包含多种寻址方式和操作类型时，这种编码方式可以有效减少指令系统的平均指令长度，降低目标代码的大小。</p>
</blockquote>
<ul>
<li>可能会使各条指令的字长和执行时间相差很大。</li>
<li>多数CISC指令系统均采用了这种编码格式。<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-52-58.webp" alt="alt text"></li>
</ul>
<h5 id="固定长度编码格式">固定长度编码格式</h5>
<blockquote>
<p>将操作类型和寻址方式一起编码到操作码中。</p>
</blockquote>
<ul>
<li>当寻址方式和操作类型非常少时,这种编码格式非常好,可以有效地降低译码的复杂度，提高译码的速度。</li>
<li>大部分RISC的指令系统均采用这种编码格式。</li>
</ul>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-54-43.webp" alt="alt text"></p>
<h5 id="混合型编码格式">混合型编码格式</h5>
<blockquote>
<p>提供若干种固定的指令字长,以期达到既能够减少目标代码长度又能降低译码复杂度的目标。<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_18-55-00.webp" alt="alt text"></p>
</blockquote>
<h4 id="指令系统的两种设计策略">指令系统的两种设计策略</h4>
<h5 id="cisc-复杂指令系统计算机">CISC（复杂指令系统计算机）</h5>
<p>Complex Instruction Set Computer</p>
<ul>
<li>增强指令功能</li>
<li>将越来越多的功能交由硬件实现</li>
<li>指令数量不断增加</li>
<li>单条指令可完成较复杂的操作</li>
</ul>
<hr>
<h5 id="risc-精简指令系统计算机">RISC（精简指令系统计算机）</h5>
<p>Reduced Instruction Set Computer</p>
<ul>
<li>尽可能简化指令系统</li>
<li>指令条数较少</li>
<li>指令功能相对简单</li>
<li>复杂功能由多条简单指令组合完成</li>
</ul>
<h5 id="为什么研发risc">为什么研发RISC</h5>
<blockquote>
<p>CISC的优点:指令数量多、功能多样<br>
问题:</p>
</blockquote>
<ol>
<li>
<p>各种指令的使用频度相差悬殊，许多指令很少用</p>
<ul>
<li>据统计：只有20％的指令使用频度比较高，占运<br>
行时间的80％。而其余80％的指令只在20％的运行时<br>
间内才会用到。</li>
</ul>
</li>
<li>
<p>指令系统庞大，指令条数很多，许多指令的功能又很复杂，使得控制器硬件非常复杂。</p>
<ul>
<li>占用了大量的芯片面积</li>
<li>增加了研制时间和成本，容易造成设计错误。</li>
</ul>
</li>
<li>
<p>许多指令由于操作繁杂，其CPI值比较大，执行速度慢。采用这些复杂指令有可能使整个程序的执行时间反而增加。</p>
</li>
<li>
<p>由于指令功能复杂，规整性不好，不利于采用流<br>
水技术来提高性能。</p>
</li>
</ol>
<blockquote>
<p>设计RISC机器遵循的原则</p>
</blockquote>
<ol>
<li>指令条数少、指令功能简单。只选取使用频度很高的指令，在此基础上补充一些最有用的指令</li>
<li>采用简单而又统一的指令格式，并减少寻址方式；指令字长都为32位或64位</li>
<li>指令的执行在单个机器周期内完成</li>
<li>采用load-store结构:只有load和store指令才能访问存储器,其它指令的操作都是在寄存器之间进行</li>
<li>大多数指令都采用硬连逻辑来实现</li>
<li>强调优化编译器的作用,为高级语言程序生成优化的代码</li>
<li>充分利用流水技术来提高性能</li>
</ol>
<h3 id="典型risc实例-mips">典型RISC实例:MIPS</h3>
<h4 id="寄存器">寄存器</h4>
<ul>
<li>32个64位通用寄存器,其中R0的值永远是0(GPRs)</li>
<li>32个64位浮点数寄存器(FPRs)</li>
<li>一些特殊寄存器</li>
</ul>
<h4 id="数据表示">数据表示</h4>
<ul>
<li>整数:字节（8位）;半字（16位）;字（32位）; 双字（64位）</li>
<li>浮点数:单精度浮点数（32位）  双精度浮点数（64位）</li>
</ul>
<blockquote>
<p>字节、半字或者字在装入64位寄存器时，用零扩展或者用符号位扩展来填充该寄存器的剩余部分。装入以后，对它们将按照64位整数的方式进行运算。</p>
</blockquote>
<h4 id="数据寻址方式">数据寻址方式</h4>
<p>只有立即数寻址与偏移量寻址两种</p>
<h4 id="指令格式">指令格式</h4>
<blockquote>
<p>只有三种指令格式,都是32位,其中操作码占6位</p>
</blockquote>
<h5 id="i-类指令-immediate">I 类指令（Immediate）</h5>
<p><strong>包含类型</strong></p>
<ul>
<li>Load / Store 指令</li>
<li>立即数指令</li>
<li>分支指令</li>
<li>寄存器跳转指令</li>
<li>寄存器链接跳转指令</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>立即数字段长度：16 位</li>
<li>用途：提供立即数或地址偏移量</li>
</ul>
<p><strong>指令语义</strong></p>
<ul>
<li>
<p><strong>Load 指令</strong></p>
<ul>
<li>有效地址：<code>Regs[rs] + immediate</code></li>
<li>从存储器读取数据，写入寄存器 <code>rt</code></li>
</ul>
</li>
<li>
<p><strong>Store 指令</strong></p>
<ul>
<li>有效地址：<code>Regs[rs] + immediate</code></li>
<li>将寄存器 <code>rt</code> 中的数据写入存储器</li>
</ul>
</li>
<li>
<p><strong>立即数指令</strong></p>
<ul>
<li><code>Regs[rt] ← Regs[rs] op immediate</code></li>
</ul>
</li>
<li>
<p><strong>分支指令</strong></p>
<ul>
<li>转移目标地址：<code>Regs[rs] + immediate</code></li>
<li>寄存器 <code>rt</code> 不使用</li>
</ul>
</li>
<li>
<p><strong>寄存器跳转并链接</strong></p>
<ul>
<li>转移目标地址：<code>Regs[rs]</code></li>
</ul>
</li>
</ul>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-03-14.webp" alt="I类指令格式"></p>
<hr>
<h5 id="r-类指令-register">R 类指令（Register）</h5>
<p><strong>包含类型</strong></p>
<ul>
<li>ALU 运算指令</li>
<li>专用寄存器读 / 写指令</li>
<li>move 指令等</li>
</ul>
<p><strong>ALU 指令语义</strong></p>
<ul>
<li><code>Regs[rd] ← Regs[rs] funct Regs[rt]</code></li>
<li><code>funct</code> 字段指定具体运算类型</li>
</ul>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-03-40.webp" alt="R类指令格式"></p>
<hr>
<h5 id="j-类指令-jump">J 类指令（Jump）</h5>
<p><strong>包含类型</strong></p>
<ul>
<li>跳转指令</li>
<li>跳转并链接指令</li>
<li>自陷指令</li>
<li>异常返回指令</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>指令字低 26 位为偏移量</li>
<li>与当前 PC 值组合形成跳转目标地址</li>
</ul>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-04-15.webp" alt="J类指令格式"></p>
<h4 id="mips的操作">MIPS的操作</h4>
<p>MIPS指令可以分为四大类<br>
load和store<br>
ALU操作<br>
分支与跳转<br>
浮点操作</p>
<h4 id="数据表示">数据表示</h4>
<h4 id="数据表示">数据表示</h4>
<h2 id="第八章-cpu">第八章 CPU</h2>
<h3 id="cpu的功能">CPU的功能</h3>
<p>CPU具有以下4个方面的基本功能</p>
<ul>
<li>指令顺序控制
<ul>
<li>指控制程序中指令的执行顺序。</li>
<li>程序中各指令之间是有严格先后顺序的，必须严格按程序规定的顺序执行，才能保证计算机工作的正确性</li>
</ul>
</li>
<li>操作控制
<ul>
<li>一条指令的功能往往是由计算机中的部件执行一序列的操作来实现的。</li>
<li>CPU要根据指令的功能，产生相应的操作控制信号，发送给相应的部件，从而控制这些部件按指令的要求进行动作</li>
</ul>
</li>
<li>时间控制<br>
对各种操作实施时间上的定时。
<ul>
<li>在一条指令的执行过程中，在什么时间做什么操作均应受到严格的控制</li>
</ul>
</li>
<li>数据加工
<ul>
<li>即对数据进行算术运算和逻辑运算，或进行其他的信息处理</li>
</ul>
</li>
</ul>
<h4 id="基本组成">基本组成</h4>
<ul>
<li>现代CPU一般由运算器、控制器、数据通路和Cache组成</li>
</ul>
<h4 id="指令执行的基本步骤">指令执行的基本步骤</h4>
<blockquote>
<p>一条指令的执行过程包括3个基本步骤：</p>
</blockquote>
<ol>
<li>取指令：从存储器取出一条指令，该指令的地址由程序计数器PC给出。</li>
<li>译码：对该指令的操作码进行译码分析，确定是哪一种指令，并转到这种指令对应的执行阶段。</li>
<li>执行：按指令操作码的要求执行该指令。执行过程可能需要多步操作，控制器将为之形成完成该指令功能所需要的操作控制信号。执行完毕后,回到取指令阶段，去取下一条指令。如此反复，直到整个程序执行完。</li>
</ol>
<h3 id="模型机-mips结构的简单实现">模型机:MIPS结构的简单实现</h3>
<p>所包含的指令</p>
<ul>
<li>算术逻辑运算指令（R类型指令格式）
<ul>
<li>add，sub，and，or，slt</li>
<li>操作码字段Op=0</li>
</ul>
</li>
<li>存储器访问指令（I类型指令格式）
<ul>
<li>lw（load word，op=35）</li>
<li>sw（store word，Op=43）</li>
</ul>
</li>
<li>等于“0”分支（I类型指令格式）
<ul>
<li>beqz，Op=63</li>
<li>说明：beqz在MIPS中实际上是条伪指令。<br>
<strong>R</strong></li>
</ul>
</li>
</ul>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-29-31.webp" alt="alt text"></p>
<ul>
<li>
<p><strong>Op</strong> —— 操作码字段<br>
用 IR[Op] 或 IR[31:26] 表示</p>
</li>
<li>
<p><strong>rs</strong> —— 第一源操作数字段<br>
用 IR[rs] 或 IR[25:21] 表示</p>
</li>
<li>
<p><strong>rt</strong> —— 第二源操作数字段<br>
用 IR[rt] 或 IR[20:16] 表示</p>
</li>
<li>
<p><strong>rd</strong> —— 目标操作数字段(或结果字段)<br>
用 IR[rd] 或 IR[15:11] 表示</p>
</li>
<li>
<p><strong>shamt</strong> —— 无用</p>
</li>
<li>
<p><strong>funct</strong> —— ALU 指令的运算函数码字段<br>
用 IR[funct] 或 IR[5:0] 表示</p>
</li>
</ul>
<hr>
<p><strong>I</strong></p>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-30-12.webp" alt="alt text"></p>
<ul>
<li>
<p><strong>rs</strong> —— 基址寄存器字段<br>
用 IR[rs] 或 IR[25:21] 表示<br>
对于 beqz 指令来说, 是存放被检测的数据</p>
</li>
<li>
<p><strong>adr</strong> —— 偏移量字段<br>
用 IR[adr] 或 IR[15:0] 表示<br>
rs 和 adr 用于计算访存有效地址或分支目标地址</p>
</li>
<li>
<p><strong>rt</strong> —— 寄存器字段<br>
对于 load 指令来说, rt 所指出的寄存器是存放所取的数据<br>
对于 store 指令来说, 是存放要写入存储器的数据</p>
</li>
</ul>
<h3 id="构建基本的数据通路">构建基本的数据通路</h3>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-39-16.webp" alt="alt text"></p>
<ul>
<li>程序计数器(PC):指出当前正在执行的指令的地址,每执行一条指令,PC+4</li>
<li>指令存储器(IM):假设IM内已经加载好了所需的指令,在IA加载地址,就可以从Ins得到对应指令</li>
<li>数据存储器(DM):两个输入端,一个是DA,给出要写入或读出的存储单元的地址,另一个是WD,给出要写入DM的数据;有两个控制信号:DMRead和DMWrite,任何时候最多只有一个有效</li>
<li>通用寄存器组:输入端有4个,RR1和RR2给出两个读操作的地址,WR给出写操作的地址,WD给出要写入的数据;输出端有两个:RD1和RD2分别给出读出的寄存器单元的数据;有一个控制信号RegWrite,当对寄存器组进行写入时才有效</li>
<li>ALU:输入两个32位的数据,输出ALUo是运算结果,由ALUCtrl(4位)给出运算操作</li>
<li>加法器:将两个输入数据相加,结果放到输出端SUM</li>
<li>符号位扩展部件:把16位的数据按符号扩展为32位的数据</li>
<li>判0部件:输入一个32位的数据,输出是一位信号,若输入为0时输出为真<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-53-11.webp" alt="alt text"></li>
</ul>
<h4 id="构建r类指令">构建R类指令</h4>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-55-38.webp" alt="alt text"></p>
<h4 id="构建访存指令-load和store">构建访存指令(load和store)</h4>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-58-09.webp" alt="alt text"><br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_10-59-29.webp" alt="alt text"><br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-01-46.webp" alt="alt text"></p>
<h4 id="beqz指令">beqz指令</h4>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-10-09.webp" alt="alt text"><br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-10-38.webp" alt="alt text"></p>
<h3 id="alu控制器">ALU控制器</h3>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-18-57.webp" alt="alt text"></p>
<blockquote>
<p>ALU完成具体的运算有5个：加、减、或、与、比较</p>
</blockquote>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_11-20-40.webp" alt="alt text"></p>
<h3 id="多周期实现方案">多周期实现方案</h3>
<h4 id="为什么用多周期">为什么用多周期</h4>
<p><strong>单周期方案的不足</strong></p>
<ul>
<li>
<p><strong>效率低下</strong><br>
不同类型的指令所完成的工作量有很大的差别<br>
所要用到的部件和所通过的数据通路不同<br>
所用时间的长短也有很大的差别</p>
</li>
<li>
<p><strong>硬件利用率低</strong><br>
每个时钟周期中功能部件最多被使用一次<br>
如果在执行一条指令的过程中多次使用某一部件<br>
就需要重复设置该部件（增加实现成本）</p>
</li>
</ul>
<hr>
<p><strong>解决方法：采用多周期方案</strong></p>
<ul>
<li>采用更短的时间作为时钟周期</li>
<li>允许一条指令的执行跨越多个时钟周期</li>
<li>该时钟周期通常等于一个基本部件的延迟时间</li>
</ul>
<p><strong>好处</strong></p>
<ul>
<li>可以共享同一个功能部件</li>
</ul>
<h3 id="控制器设计">控制器设计</h3>
<p>实现控制器的技术有两种：硬连逻辑和微程序设计</p>
<ul>
<li>硬连逻辑是建立在有限状态机的基础上，并且一般是以状态图的形式表示。</li>
<li>微程序设计则是采用微指令的方式来表示和实现控制。</li>
</ul>
<h4 id="控制器的组成">控制器的组成</h4>
<ul>
<li>指令部件
<ul>
<li>程序计数器PC</li>
<li>指令寄存器IR</li>
<li>指令译码器ID</li>
<li>地址形成部件</li>
</ul>
</li>
<li>时序控制部件
<ul>
<li>时钟脉冲CP</li>
<li>时序信号发生器</li>
</ul>
</li>
<li>微操作控制信号形成部件</li>
<li>中断控制逻辑</li>
<li>程序状态寄存器</li>
</ul>
<h3 id="流水线技术">流水线技术</h3>
<blockquote>
<p>什么是流水线技术<br>
定义：<br>
流水线技术是把一条指令的执行过程划分为若干个顺序阶段，每个阶段由专门的部件完成，不同指令在不同阶段上并行执行的一种处理技术。</p>
</blockquote>
<blockquote>
<p>为什么要采用流水线技术<br>
提高处理器吞吐率：在同一时间并行处理多条指令的不同阶段，使单位时间内完成的指令数增加<br>
提高硬件利用率：各功能部件（取指、译码、执行等）可以同时工作，减少空闲时间<br>
提升整体性能：在不显著增加主频的情况下，提高平均指令执行速度</p>
</blockquote>
<h2 id="第九章-微程序控制器">第九章 微程序控制器</h2>
<blockquote>
<p>组合逻辑控制器存在的两个比较突出的缺点:</p>
</blockquote>
<ul>
<li>设计复杂、繁琐，缺乏规律性，设计效率低</li>
<li>不易修改和扩充，缺乏灵活性</li>
</ul>
<blockquote>
<p>微程序控制器的缺点:速度比较慢</p>
</blockquote>
<ul>
<li>因此RISC仍旧采用硬连逻辑设计</li>
</ul>
<h3 id="基本原理">基本原理</h3>
<blockquote>
<p>用二进制编码字（称为微指令字）来代替组合逻辑控制器中的微操作控制信号的产生</p>
</blockquote>
<h4 id="微操作和微命令">微操作和微命令</h4>
<p>微命令:构成控制信号序列的最小单位<br>
微操作:接受微命令后进行的最基本的操作</p>
<ul>
<li>分为两种：
<ul>
<li>相容的微操作：可以同时进行的微操作</li>
<li>互斥的微操作：不能同时进行的微操作</li>
</ul>
</li>
</ul>
<h4 id="微指令和微程序">微指令和微程序</h4>
<p><strong>微指令</strong><br>
微指令：用来产生微控制信号的二进制编码字,用于控制完成一组微操作</p>
<p><strong>微程序</strong><br>
微程序：由一系列微指令构成的有序集合<br>
每一条机器指令都对应一段微程序<br>
通过解释执行该微程序，完成指令所规定的操作</p>
<hr>
<h4 id="微指令周期">微指令周期</h4>
<p><strong>微指令周期</strong><br>
微指令周期：微程序控制器的工作周期<br>
从控制存储器中读取一条微指令到执行完相应微操作所需时间的最大值</p>
<h3 id="微指令的编码方法">微指令的编码方法</h3>
<blockquote>
<p>设计目标: 减少微指令的宽度, 减少微程序的长度, 提高执行速度, 保持微程序设计的灵活性</p>
</blockquote>
<p>共有四种编码方法</p>
<hr>
<h4 id="直接控制编码法-不译码法">直接控制编码法(不译码法)</h4>
<ul>
<li>微操作控制字段的每一位直接对应一个微操作</li>
<li>当某位为 1 时, 表示执行相应的微操作;为 0 时不执行该微操作</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>结构简单</li>
<li>并行性最好</li>
<li>操作速度快</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>微指令字太长<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_14-53-30.webp" alt="alt text"></li>
</ul>
<hr>
<h4 id="最短字长编码法">最短字长编码法</h4>
<ul>
<li>将所有微命令进行统一的二进制编码</li>
<li>每条微指令只定义一个微操作</li>
</ul>
<p><strong>微操作控制字段长度关系</strong></p>
<ul>
<li>
<p>微操作控制字段长度 L 与微命令总数 N 的关系</p>
<ul>
<li>L ≥ log2 N</li>
</ul>
</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>微指令字长最短</li>
<li>需要经过译码才能得到所需的微命令, 执行速度受影响</li>
<li>一条微指令只能产生一个微命令</li>
<li>无法利用硬件的并行性<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_14-54-21.webp" alt="alt text"></li>
</ul>
<hr>
<h4 id="字段直接编码法">字段直接编码法</h4>
<ul>
<li>将微操作控制字段进一步划分为若干字段</li>
<li>每个字段单独编码</li>
<li>每个码点表示一个微命令</li>
</ul>
<p><strong>折中方案</strong></p>
<ul>
<li>字段之间采用直接控制</li>
<li>字段内部采用最短字长编码</li>
</ul>
<p><strong>字段划分原则</strong></p>
<ul>
<li>
<p>可按功能或部件划分</p>
<ul>
<li>对机器中的每一类功能或每一个部件分配一个字段</li>
</ul>
</li>
<li>
<p>将互斥的微操作分在同一字段</p>
</li>
<li>
<p>将相容的微操作分在不同字段</p>
</li>
<li>
<p>字段划分应与数据通路相适应</p>
</li>
<li>
<p>一般每个字段应保留一个码点,用于表示不发任何微命令<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_14-55-50.webp" alt="alt text"></p>
</li>
</ul>
<hr>
<h4 id="字段间接编码">字段间接编码</h4>
<ul>
<li>字段编码的含义需要由另一个字段的编码来解释确定</li>
<li>一个解释字段可同时对多个字段进行控制</li>
<li>只有这样才能有效缩短微指令字长</li>
<li>解释字段应具有一定的分类特征<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_14-56-53.webp" alt="alt text"></li>
</ul>
<hr>
<h4 id="常数源字段的设置">常数源字段的设置</h4>
<p><strong>作用</strong></p>
<ul>
<li>提供常数</li>
<li>参与其他字段的间接编码</li>
</ul>
<h3 id="微指令的格式">微指令的格式</h3>
<p>分为两大类: 水平型微指令 和 垂直型微指令</p>
<hr>
<h4 id="水平型微指令">水平型微指令</h4>
<p>一次能定义并执行多个微操作的微指令</p>
<p><strong>特点</strong></p>
<ul>
<li>
<p>微指令字较长,一般为几十位到上百位</p>
</li>
<li>
<p>描述并行微操作的能力强<br>
在一个微周期中可并行执行多个微操作</p>
</li>
<li>
<p>微指令译码简单<br>
一般采用直接控制编码法和分段直接编码法</p>
</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>
<p>优点</p>
<ul>
<li>并行操作能力强</li>
<li>执行速度快</li>
<li>代码长度短</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>微指令字较长,明显增加控存宽度</li>
<li>微程序编制复杂,难度较大,不易实现设计自动化</li>
</ul>
</li>
</ul>
<hr>
<h4 id="垂直型微指令">垂直型微指令</h4>
<blockquote>
<p>一次只能定义一两个微操作,微指令字长较短</p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>
<p>微指令字短<br>
一般为十几位到二十位左右</p>
</li>
<li>
<p>并行微操作能力差<br>
一条微指令只能控制数据通路的一两种信息传送</p>
</li>
<li>
<p>通过微操作码字段定义微指令的基本功能和信息传送路径<br>
执行时需要完全译码<br>
译码过程较复杂</p>
</li>
<li>
<p>微指令各二进制位与数据通路控制点之间不存在直接对应关系</p>
</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>
<p>优点</p>
<ul>
<li>结构直观、规整,易于编制微程序</li>
<li>微指令字较短,控存横向较窄</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>微程序较长,微指令需经译码产生微命令,执行速度较慢</li>
<li>描述并行微操作能力差,不适合并行性较强的数据通路机器</li>
</ul>
</li>
</ul>
<h3 id="后续微地址的产生">后续微地址的产生</h3>
<blockquote>
<p>两种方式: 增量方式, 断定方式</p>
</blockquote>
<hr>
<h4 id="增量方式">增量方式</h4>
<ul>
<li>设置一个微程序计数器 μPC</li>
<li>顺序执行时<br>
给 μPC 增加一个增量(通常为 1), 得到下一条微指令地址</li>
<li>遇到转移时<br>
由微指令给出转移目标微地址</li>
</ul>
<p><strong>微地址字段 SCF 的组成</strong></p>
<ul>
<li>
<p>转移控制字段 BCF<br>
用于规定是顺序执行还是转移<br>
若为转移, 由 BCF 指出转移地址的来源</p>
</li>
<li>
<p>转移地址字段 BAF<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_15-45-43.webp" alt="alt text"><br>
<strong>转移地址的来源有 3 种</strong></p>
</li>
<li>
<p>由 BAF 给出的地址</p>
</li>
<li>
<p>机器指令所对应微程序的入口地址</p>
</li>
<li>
<p>微子程序入口地址和返回地址<br>
返回地址存放在返回地址寄存器中</p>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>SCF 字段较短</li>
<li>后继微地址生成逻辑较简单</li>
<li>微程序编制较容易</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不能直接实现多路转移</li>
</ul>
<hr>
<h4 id="断定方式">断定方式</h4>
<p><strong>后继微地址的确定方式</strong></p>
<ul>
<li>
<p>由微程序设计者直接指定</p>
</li>
<li>
<p>由微程序设计者指定的测试判别逻辑字段控制产生<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-14_15-46-10.webp" alt="alt text"><br>
<strong>后继微地址的组成</strong></p>
</li>
<li>
<p>非测试地址<br>
由微程序设计者直接指定<br>
地址不变<br>
构成微地址的高位部分</p>
</li>
<li>
<p>测试地址<br>
在微程序执行过程中<br>
通过测试某些状态位动态决定<br>
构成微地址的低位部分</p>
</li>
</ul>
<p><strong>分支能力与字段位数</strong></p>
<ul>
<li>
<p>若测试地址位数为 m<br>
分支路数为 2^m<br>
测试字段个数为 m</p>
</li>
<li>
<p>测试字段位数 n 取决于测试条件个数 N<br>
一般有<br>
n = [log2 N] + 1</p>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>可实现快速多路转移</li>
<li>提高微程序执行速度</li>
<li>微程序在控存中的存放位置灵活、方便</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>后继微地址生成逻辑较复杂</li>
<li>微程序执行顺序不直观</li>
</ul>
<h3 id="微指令的执行方式">微指令的执行方式</h3>
<h4 id="串行执行">串行执行</h4>
<blockquote>
<p>取微指令和执行微指令串行进行。在前一条的微指令执行完之后，才能取下一条微指令。<br>
<strong>特点</strong><br>
设备效率低，执行速度慢。控制简单，易于实现。</p>
</blockquote>
<h4 id="并行执行">并行执行</h4>
<blockquote>
<p>当前微指令的执行和下一条微指令的取出重叠进行</p>
</blockquote>
<p><strong>优点</strong></p>
<ul>
<li>提高了执行速度和设备利用率</li>
</ul>
<hr>
<p><strong>存在的问题</strong></p>
<ul>
<li>当需要根据当前微指令的执行结果进行转移时<br>
会产生控制上的困难</li>
</ul>
<hr>
<p><strong>两种处理方法</strong></p>
<ul>
<li>
<p><strong>方法一: 推迟取指</strong><br>
推迟下一条微指令的取出<br>
使其取出时间与串行执行方式相同</p>
</li>
<li>
<p><strong>方法二: 猜测法</strong><br>
采用猜测方式<br>
在两条可能的分支中<br>
猜测性地选择其中一条作为后继微指令</p>
</li>
</ul>
<h2 id="第十章-运算方法和运算器">第十章 运算方法和运算器</h2>
<h3 id="移位运算">移位运算</h3>
<h4 id="逻辑移位">逻辑移位</h4>
<p>逻辑移位中,被移动的数据是逻辑数,没有符号和数值大小</p>
<ol>
<li>逻辑左移: 数据各位左移一位,最高位丢弃,最低位移入0</li>
<li>逻辑右移: 依次右移,最低位丢弃,最高位移入0</li>
</ol>
<h4 id="循环移位">循环移位</h4>
<p>将被移位的数据左右两端相连形成闭合回路<br>
如10011左移变成00111</p>
<h4 id="算术移位">算术移位</h4>
<p>对带符号的数进行移位;会引发数值变化</p>
<h5 id="原码算术移位">原码算术移位</h5>
<p>符号位不参加移位,将相应数值进行逻辑移位</p>
<h5 id="补码算术移位">补码算术移位</h5>
<p>对补码进行算术移位时,符号位一起参与移位</p>
<ol>
<li>算术左移: 连同符号位一起左移一位,最高位丢弃,最低位移入0</li>
<li>算术右移:连同符号位一起右移一位,符号位不变,最低位移出丢弃</li>
</ol>
<ul>
<li>左移时可能发生溢出,取模时得到负数</li>
</ul>
<h3 id="定点数加减法运算">定点数加减法运算</h3>
<h4 id="补码加减法">补码加减法</h4>
<p>若符号位产生进位则舍弃进位</p>
<h4 id="判断溢出">判断溢出</h4>
<blockquote>
<p><strong>采用两个操作数和结果的符号来判断</strong><br>
当两个同号数的补码相加，若得到的结果的符号与两个操作数的符号不同，则发生了溢出</p>
</blockquote>
<blockquote>
<p><strong>采用最高数值位产生的进位与符号位产生的进位是否相同来判断</strong> ,当不相同时，则发生了溢出</p>
</blockquote>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_17-40-21.webp" alt="alt text"></p>
<blockquote>
<p>采用变形补码,将符号位扩展为2位,若运算结果的两个符号位不同,则发生了溢出</p>
</blockquote>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_17-46-46.webp" alt="alt text"></p>
<h3 id="定点数乘除法运算">定点数乘除法运算</h3>
<h4 id="原码一位乘法">原码一位乘法</h4>
<p><img src="/images/archives/2026-01-11/PixPin_2026-01-14_17-53-17.webp" alt="alt text"></p>
<h3 id="浮点数加减法运算">浮点数加减法运算</h3>
<p>设有两个规格化浮点数 X 和 Y, 分别为<br>
X: XEXM<br>
Y: YEYM</p>
<p>其中</p>
<ul>
<li>XE 和 YE: 阶码</li>
<li>XM 和 YM: 尾数</li>
</ul>
<hr>
<h4 id="浮点加减法运算的步骤">浮点加减法运算的步骤</h4>
<ol>
<li>判 0 操作</li>
<li>对阶</li>
<li>尾数加减</li>
<li>规格化与舍入<br>
（在规格化过程中需要判断运算结果是否溢出）</li>
</ol>
<hr>
<h4 id="1-判-0-操作">1. 判 0 操作</h4>
<ul>
<li>
<p>若两个操作数 X 和 Y 中有一个为 0<br>
则不需要进行运算<br>
直接设置运算结果为 0<br>
运算结束</p>
</li>
<li>
<p>否则进入下一步</p>
</li>
</ul>
<hr>
<h4 id="2-对阶">2. 对阶</h4>
<p><strong>目的</strong></p>
<ul>
<li>使小数点对齐</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>对其中一个操作数进行变换<br>
使两个操作数的阶码相等</li>
</ul>
<ul>
<li>对齐大阶码<br>
<strong>实现步骤</strong></li>
</ul>
<ol>
<li>
<p>求阶差<br>
△E = XE − YE</p>
</li>
<li>
<p>若 △E &gt; 0</p>
<ul>
<li>
<p>表示 X 的阶码大于 Y 的阶码</p>
</li>
<li>
<p>调整操作数 Y</p>
<ul>
<li>将 Y 的尾数 YM 右移</li>
<li>每右移一位<br>
阶码 YE 加 1</li>
<li>直到两数阶码相等</li>
</ul>
</li>
</ul>
</li>
<li>
<p>若 △E &lt; 0</p>
<ul>
<li>表示 X 的阶码小于 Y 的阶码</li>
<li>调整操作数 X</li>
<li>调整方法与上述相同</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-尾数加减">3. 尾数加减</h4>
<ul>
<li>将两数的尾数 XM 和 YM<br>
按照相应的定点加减运算规则<br>
进行加法或减法运算</li>
<li>得到运算结果的尾数</li>
</ul>
<hr>
<h4 id="4-结果规格化并判溢出">4. 结果规格化并判溢出</h4>
<ol>
<li>
<p>右规情况</p>
<ul>
<li>
<p>若运算结果的绝对值大于 1</p>
<ul>
<li>将结果右移一位</li>
<li>相应的阶码加 1</li>
<li>右规最多只需一位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>左规情况</p>
<ul>
<li>
<p>若运算结果的绝对值小于 1</p>
<ul>
<li>将结果左移</li>
<li>每左移一位<br>
阶码减 1</li>
<li>直到结果的绝对值大于等于 1/2 为止</li>
</ul>
</li>
</ul>
</li>
<li>
<p>溢出判断</p>
<ul>
<li>
<p>每次阶码加 1 或减 1 后<br>
都要判断阶码是否越界</p>
</li>
<li>
<p>阶码上溢</p>
<ul>
<li>阶码大于可表示的最大正数</li>
<li>可置溢出标志</li>
<li>或将结果作为 +∞ 或 −∞ 处理</li>
</ul>
</li>
<li>
<p>阶码下溢</p>
<ul>
<li>阶码小于可表示的最小负数</li>
<li>可置溢出标志</li>
<li>或将结果作为 0 处理</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-舍入处理">5. 舍入处理</h4>
<p>常用的舍入方法有</p>
<ol>
<li>0 舍 1 入法:类似四舍五入</li>
<li>截断法:直接舍去右移的数字</li>
<li>朝 +∞ 舍入法:若为正数,只要移出的数位不全为0,则最低有效位加1;若为负数则采用截断法</li>
<li>朝 −∞ 舍入法:若为负数,只要移出的数位不全为0,则最低有效位加1;若为正数则采用截断法</li>
</ol>
<h2 id="第十一章-存储器">第十一章 存储器</h2>
<h3 id="存储子系统概述">存储子系统概述</h3>
<blockquote>
<p>三级存储系统:</p>
<ul>
<li>Cache（高速缓冲存储器）</li>
<li>主存储器</li>
<li>磁盘存储器（辅存）</li>
</ul>
</blockquote>
<ul>
<li>
<p>最靠近CPU的Cache速度最快,容量最小;离CPU最远的硬盘速度最慢，但容量最大</p>
</li>
<li>
<p>CPU所访问的指令和数据的绝大部分都能在Cache中找到,之所以可以做到,是根据程序访问的局部性原理,即程序在一小段时间间隔内访问的指令和数据在地址上是相对集中的</p>
</li>
<li>
<p>两个存储层次</p>
<ul>
<li>“Cache—主存”层次：解决主存速度不足的问题</li>
<li>“主存—辅存”层次：解决主存容量不足的问题<br>
<img src="/images/archives/2026-01-11/PixPin_2026-01-13_21-57-01.webp" alt="alt text"></li>
</ul>
</li>
</ul>
<h3 id="存储器分类">存储器分类</h3>
<h4 id="按在计算机系统中的作用分类">按在计算机系统中的作用分类</h4>
<ol>
<li><strong>主存储器</strong>,又简称为主存或内存。</li>
</ol>
<ul>
<li>它是整个存储系统的核心，用来存放计算机当前运行的程序以及所需的数据，CPU可直接随机地对它进行访问。</li>
</ul>
<ol start="2">
<li><strong>辅助存储器</strong>,简称为辅存或外存</li>
</ol>
<ul>
<li>弥补主存的容量不足,用来存放暂时不用的程序和数据。CPU不能直接访问它，当需要运行辅助存储器中的程序时，需将它们调入主存后供CPU使用。</li>
</ul>
<ol start="3">
<li>高速缓冲存储器Cache</li>
</ol>
<ul>
<li>弥补主存的速度不足,位于CPU和主存储器之间</li>
</ul>
<h4 id="按照存取方式分类">按照存取方式分类</h4>
<blockquote>
<p>存取方式：指访问存储单元的方法</p>
</blockquote>
<ul>
<li>
<p><strong>随机存储器 RAM</strong><br>
Random Access Memory</p>
</li>
<li>
<p><strong>只读存储器 ROM</strong><br>
Read Only Memory</p>
</li>
<li>
<p><strong>顺序存取存储器 SAM</strong><br>
Sequential Access Memory</p>
</li>
</ul>
<ol>
<li>随机存储器RAM</li>
</ol>
<blockquote>
<p>可随机地读取或写入存储器的任何一个单元，访问时间是固定的，与存储单元的物理位置无关</p>
</blockquote>
<ul>
<li>在系统断电后大多数随机存储器RAM所保存的信息将丢失</li>
<li>常用来作主存和Cache</li>
</ul>
<ol start="2">
<li>只读存储器ROM</li>
</ol>
<blockquote>
<p>只能随机读取存储器的任何一个单元，不能写入信息。</p>
</blockquote>
<ul>
<li>系统断电后，所保存的信息不会丢失。</li>
<li>用来存放不需要改变的信息,比如存放系统程序</li>
</ul>
<ol start="3">
<li>顺序存取存储器SAM</li>
</ol>
<blockquote>
<p>只能按顺序访问存储器中的信息，访问时间与信息在存储器中所处的物理位置有关。</p>
</blockquote>
<ul>
<li>信息通常以文件或数据块的形式存放,如磁带</li>
</ul>
<h4 id="按照存储介质分类">按照存储介质分类</h4>
<blockquote>
<p>存储介质一般具备3个特点:</p>
</blockquote>
<ol>
<li>
<p>具有两种稳定的状态，分别代表二进制代码0和1</p>
</li>
<li>
<p>能方便地检测出存储介质所处的状态</p>
</li>
<li>
<p>两种状态容易相互转换</p>
</li>
<li>
<p>半导体存储器</p>
</li>
<li>
<p>磁表面存储器</p>
</li>
<li>
<p>光存储器</p>
</li>
</ol>
<h3 id="主存储器">主存储器</h3>
<h4 id="主存的组成结构">主存的组成结构</h4>
<ol>
<li>存储体</li>
</ol>
<blockquote>
<p>存储二进制信息的主体，由许多存储单元构成，每一个存储单元存放1～8个字节<br>
每一个存储单元都有一个统一的编号，称为地址,地址与存储单元之间是一一对应的。</p>
</blockquote>
<ol start="2">
<li>地址译码和驱动电路</li>
<li>读写电路</li>
<li>存储控制电路</li>
</ol>
<h3 id="主存的主要技术指标">主存的主要技术指标</h3>
<h4 id="存储容量">存储容量</h4>
<p>一个存储器中所能存储的二进制信息的总量.<br>
常用位 b 和字节 B 来表示<br>
如 64Kb, 512KB, 4MB.</p>
<hr>
<h4 id="存取速度">存取速度</h4>
<p>指访问存储器的速度.</p>
<p><strong>存取时间 TA</strong><br>
又称访问时间或读写时间, 指从启动一次存储器访存操作到完成该操作所需要的时间.</p>
<p><strong>存储周期 TM</strong><br>
指连续两次启动存储器访问所需的最小时间间隔.</p>
<ul>
<li>包括存储器的存取时间和自身恢复时间.</li>
<li>存储周期通常大于或等于存取时间.</li>
</ul>
<p><strong>主存带宽 BM</strong><br>
存储器单位时间内所能存取的信息量.</p>
<ul>
<li>也称为数据传输率或主存的数据传输频率.</li>
<li>单位为 bit/s 或 byte/s.</li>
</ul>
<p>BM 的计算公式为:</p>
<ul>
<li>BM = 每个存储单元的位数 / TM (bit/s)</li>
<li>BM = 每个存储单元的位数 / (TM × 8) (byte/s)</li>
</ul>
<p>提高 BM 的方法有三种:</p>
<ul>
<li>增加存储单元的位数</li>
<li>减少 TM</li>
<li>采用多个存储体</li>
</ul>
<hr>
<h4 id="可靠性">可靠性</h4>
<p>在规定的时间内, 存储器无故障读写的概率.<br>
通常用平均无故障间隔时间 MTBF (Mean Time Between Failures) 来衡量.<br>
MTBF 越长, 说明存储器的可靠性越高.</p>
<hr>
<h4 id="功耗">功耗</h4>
<p>指单位时间存储器所消耗的电能,功耗越小越好</p>
<h3 id="随机存储器">随机存储器</h3>
<h4 id="静态随机存储器sram">静态随机存储器SRAM</h4>
<blockquote>
<p>利用触发器来储存二进制信息<br>
优点：SRAM 工作速度快，稳定可靠，不需要外加刷新电路，从而简化了外电路设计<br>
缺点：所含晶体管较多，故集成度较低，功耗较大</p>
</blockquote>
<h4 id="动态随机存储器dram">动态随机存储器DRAM</h4>
<blockquote>
<p>利用 MOS 晶体管的管极电容来存储二进制信息<br>
优点：基本存储位元电路中所含晶体管数目少、集成度高、成本低、功耗小<br>
缺点：它需外加刷新电路，工作速度比 SRAM 慢得多（破坏性读出且需要刷新）</p>
</blockquote>
<h3 id="dram的刷新">DRAM的刷新</h3>
<blockquote>
<p>什么叫刷新：为维持 DRAM 所存信息不变，需要定时地对 DRAM 中的电容充电，以补充泄漏掉的电荷。这个过程叫刷新</p>
</blockquote>
<blockquote>
<p>DRAM 为什么需要刷新： DRAM 是利用电容上保存的电荷来存储信息的，由于存在漏电阻，即使电源不掉电，时间长了，电容上的电荷也会慢慢泄漏掉，DRAM 内存储的信息会自动消失。</p>
</blockquote>
<blockquote>
<p>什么叫刷新周期：从上一次对整个存储器刷新结束到下一次对整个存储器刷新结束所需的时间</p>
</blockquote>
<ol>
<li>集中式刷新：在一个刷新周期内，集中一段时间连续地对全部存储单元逐行刷新一遍。</li>
</ol>
<ul>
<li>在刷新操作期间，不允许 CPU 对存储器进行正常的访问</li>
</ul>
<p>优点：读写操作时不受刷新工作的影响，系统的存取速度比较高<br>
缺点：在集中刷新期间必须停止读写，这一段时间称为“死区”，而且存储容量越大，死区就越长。<br>
2. 分散式刷新：把对每行存储单元的刷新分散到每个系统存取周期内完成。此时系统存取周期被分为两部分，周期前半段时间进行正常的存储器访问，后半段时间进行刷新操作。在一个系统存取周期内刷新存储矩阵中的一行,增加了系统的存取周期<br>
优点：没有死区<br>
缺点：刷新过于频繁。系统存取周期是存储芯片存取周期的两倍，降低了访问存储器的速度。<br>
3. 异步式刷新：把刷新操作平均分配到整个最大刷新间隔内进行，相邻两行的刷新间隔为：刷新周期÷行数</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/revival-of-hope">Revival-of-hope</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/">https://revival-of-hope.github.io/2026/01/15/archives-2026-01-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></div><div class="post-share"><div class="social-share" data-image="/images/archives/2026-01-18/67962380_p0-%E5%A4%A2%E4%B8%AD.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/18/archives-2026-01-18-astro%E5%B0%9D%E8%AF%95/" title="2026-01-18 astro尝试"><img class="cover" src="/images/archives/2026-01-18/68751548_p0-%E5%A4%8F.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">2026-01-18 astro尝试</div></div><div class="info-2"><div class="info-item-1">本来觉得hexo的图片管理太麻烦了,部署速度又比较慢,做不到动态同步,就想着换其他的博客框架试试,经过多方搜寻敲定了astro来尝鲜,下面是没有模板时的效果   看着还不错,之后再改改就是个还不...</div></div></div></a><a class="pagination-related" href="/2026/01/11/archives-2026-01-11-%E5%86%8D%E6%88%98%E7%AE%97%E6%B3%95/" title="2026-01-11 再战算法"><img class="cover" src="/images/archives/2026-01-18/67313183_p0-%E7%84%A1%E9%A1%8C.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">2026-01-11 再战算法</div></div><div class="info-2"><div class="info-item-1">昨天考了程序设计范式,一开始觉得三个小时三道题不是有手就行,后来发现我太天真了. 第一道题是leetcode2002,一道关于不相交回文子串的中级题,我硬是没想到用dfs做,可能是一个月没碰算法...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/reimu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Revival-of-hope</div><div class="author-info-description">为赋新词强说愁</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/revival-of-hope"><i class="fab fa-github"></i><span>My Github Page</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/revival-of-hope" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/rss.xml" target="_blank" title="'#ff6600'"><i class="fas fa-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.</span> <span class="toc-text">考试事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E6%9D%82%E9%A1%B9"><span class="toc-number">2.</span> <span class="toc-text">重要的杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%87%E9%80%89%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.1.</span> <span class="toc-text">片选信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%91%E7%A0%81%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">译码器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%AE%BA"><span class="toc-number">3.</span> <span class="toc-text">第一章 概论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA5%E4%B8%AA%E9%83%A8%E4%BB%B6%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">计算机5个部件的示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E9%83%A8%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">各部件详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">3.3.</span> <span class="toc-text">计算机的性能指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA-%E4%BD%9C%E4%B8%BA%E7%AC%AC%E5%8D%81%E7%AB%A0%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">第二章 数的表示（作为第十章的基础）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">原码表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">反码表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">补码表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-number">4.3.1.</span> <span class="toc-text">深入理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">移码表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.5.</span> <span class="toc-text">数的浮点表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E6%A0%BC%E5%8C%96%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">规格化浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">4.5.2.</span> <span class="toc-text">例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">第六章 计算机执行程序的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="toc-number">5.1.</span> <span class="toc-text">指令说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#load-%E6%8C%87%E4%BB%A4-%E8%A3%85%E8%BD%BD%E5%AF%84%E5%AD%98%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.1.1.</span> <span class="toc-text">Load 指令（装载寄存器指令）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#store-%E6%8C%87%E4%BB%A4-%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.1.2.</span> <span class="toc-text">Store 指令（存储指令）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-%E6%8C%87%E4%BB%A4-%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-number">5.1.3.</span> <span class="toc-text">Add 指令（加法指令）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jump-%E6%8C%87%E4%BB%A4-%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">5.1.4.</span> <span class="toc-text">Jump 指令（跳转指令）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%8F%B7%E8%AF%B4%E6%98%8E"><span class="toc-number">5.2.</span> <span class="toc-text">记号说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.</span> <span class="toc-text">指令示例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-1-%E6%9D%A1"><span class="toc-number">5.3.1.</span> <span class="toc-text">第 1 条</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-2-%E6%9D%A1"><span class="toc-number">5.3.2.</span> <span class="toc-text">第 2 条</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-3-%E6%9D%A1"><span class="toc-number">5.3.3.</span> <span class="toc-text">第 3 条</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-4-%E6%9D%A1"><span class="toc-number">5.3.4.</span> <span class="toc-text">第 4 条</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-5-%E6%9D%A1"><span class="toc-number">5.3.5.</span> <span class="toc-text">第 5 条</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-6-%E6%9D%A1"><span class="toc-number">5.3.6.</span> <span class="toc-text">第 6 条</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4-load-r1-200-r0-%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.4.</span> <span class="toc-text">第一条指令**Load R1，200(R0)**详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">第七章 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A0%81"><span class="toc-number">6.2.</span> <span class="toc-text">指令的地址码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.1.</span> <span class="toc-text">零地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.2.</span> <span class="toc-text">一地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.3.</span> <span class="toc-text">二地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4%E5%92%8C%E5%A4%9A%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.4.</span> <span class="toc-text">三地址指令和多地址指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">6.3.</span> <span class="toc-text">指令的操作码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">6.3.1.</span> <span class="toc-text">固定长度操作码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">6.3.2.</span> <span class="toc-text">可变长度操作码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">6.3.3.</span> <span class="toc-text">扩展操作码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6"><span class="toc-number">6.4.</span> <span class="toc-text">指令长度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF%E7%9A%84%E5%85%B3%E7%B3%BB%E5%88%86%E7%B1%BB"><span class="toc-number">6.4.1.</span> <span class="toc-text">按与机器字长的关系分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.1.</span> <span class="toc-text">直接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.2.</span> <span class="toc-text">间接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.3.</span> <span class="toc-text">立即寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.4.</span> <span class="toc-text">寄存器直接寻址与寄存器间接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.5.</span> <span class="toc-text">隐含寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pc%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.6.</span> <span class="toc-text">PC相对寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.7.</span> <span class="toc-text">变址寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.8.</span> <span class="toc-text">基址寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80-%E5%8F%98%E5%9D%80-%E5%AF%BB%E5%9D%80"><span class="toc-number">6.5.9.</span> <span class="toc-text">“基址+变址”寻址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%8C%89%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">指令按功能分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.7.</span> <span class="toc-text">指令系统设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82"><span class="toc-number">6.7.1.</span> <span class="toc-text">对指令系统的基本要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.7.2.</span> <span class="toc-text">指令格式的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.7.2.1.</span> <span class="toc-text">可变长度编码格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.7.2.2.</span> <span class="toc-text">固定长度编码格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%9E%8B%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.7.2.3.</span> <span class="toc-text">混合型编码格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5"><span class="toc-number">6.7.3.</span> <span class="toc-text">指令系统的两种设计策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cisc-%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">6.7.3.1.</span> <span class="toc-text">CISC（复杂指令系统计算机）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#risc-%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">6.7.3.2.</span> <span class="toc-text">RISC（精简指令系统计算机）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A0%94%E5%8F%91risc"><span class="toc-number">6.7.3.3.</span> <span class="toc-text">为什么研发RISC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E5%9E%8Brisc%E5%AE%9E%E4%BE%8B-mips"><span class="toc-number">6.8.</span> <span class="toc-text">典型RISC实例:MIPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">6.8.1.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.8.2.</span> <span class="toc-text">数据表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">6.8.3.</span> <span class="toc-text">数据寻址方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.8.4.</span> <span class="toc-text">指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#i-%E7%B1%BB%E6%8C%87%E4%BB%A4-immediate"><span class="toc-number">6.8.4.1.</span> <span class="toc-text">I 类指令（Immediate）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#r-%E7%B1%BB%E6%8C%87%E4%BB%A4-register"><span class="toc-number">6.8.4.2.</span> <span class="toc-text">R 类指令（Register）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#j-%E7%B1%BB%E6%8C%87%E4%BB%A4-jump"><span class="toc-number">6.8.4.3.</span> <span class="toc-text">J 类指令（Jump）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mips%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.8.5.</span> <span class="toc-text">MIPS的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.8.6.</span> <span class="toc-text">数据表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.8.7.</span> <span class="toc-text">数据表示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-cpu"><span class="toc-number">7.</span> <span class="toc-text">第八章 CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">7.1.</span> <span class="toc-text">CPU的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">7.1.1.</span> <span class="toc-text">基本组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.1.2.</span> <span class="toc-text">指令执行的基本步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%9C%BA-mips%E7%BB%93%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.</span> <span class="toc-text">模型机:MIPS结构的简单实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="toc-number">7.3.</span> <span class="toc-text">构建基本的数据通路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BAr%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">7.3.1.</span> <span class="toc-text">构建R类指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%AE%BF%E5%AD%98%E6%8C%87%E4%BB%A4-load%E5%92%8Cstore"><span class="toc-number">7.3.2.</span> <span class="toc-text">构建访存指令(load和store)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#beqz%E6%8C%87%E4%BB%A4"><span class="toc-number">7.3.3.</span> <span class="toc-text">beqz指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alu%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">ALU控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">7.5.</span> <span class="toc-text">多周期实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%A4%9A%E5%91%A8%E6%9C%9F"><span class="toc-number">7.5.1.</span> <span class="toc-text">为什么用多周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.6.</span> <span class="toc-text">控制器设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">7.6.1.</span> <span class="toc-text">控制器的组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">7.7.</span> <span class="toc-text">流水线技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">第九章 微程序控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%92%8C%E5%BE%AE%E5%91%BD%E4%BB%A4"><span class="toc-number">8.1.1.</span> <span class="toc-text">微操作和微命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E5%92%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.1.2.</span> <span class="toc-text">微指令和微程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">8.1.3.</span> <span class="toc-text">微指令周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">微指令的编码方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E7%BC%96%E7%A0%81%E6%B3%95-%E4%B8%8D%E8%AF%91%E7%A0%81%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">直接控制编码法(不译码法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AD%97%E9%95%BF%E7%BC%96%E7%A0%81%E6%B3%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">最短字长编码法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%B3%95"><span class="toc-number">8.2.3.</span> <span class="toc-text">字段直接编码法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81"><span class="toc-number">8.2.4.</span> <span class="toc-text">字段间接编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E6%BA%90%E5%AD%97%E6%AE%B5%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.2.5.</span> <span class="toc-text">常数源字段的设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">微指令的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">8.3.1.</span> <span class="toc-text">水平型微指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">8.3.2.</span> <span class="toc-text">垂直型微指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E5%BE%AE%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">8.4.</span> <span class="toc-text">后续微地址的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">8.4.1.</span> <span class="toc-text">增量方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E5%AE%9A%E6%96%B9%E5%BC%8F"><span class="toc-number">8.4.2.</span> <span class="toc-text">断定方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">8.5.</span> <span class="toc-text">微指令的执行方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">8.5.1.</span> <span class="toc-text">串行执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">8.5.2.</span> <span class="toc-text">并行执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">第十章 运算方法和运算器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">9.1.</span> <span class="toc-text">移位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D"><span class="toc-number">9.1.1.</span> <span class="toc-text">逻辑移位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D"><span class="toc-number">9.1.2.</span> <span class="toc-text">循环移位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D"><span class="toc-number">9.1.3.</span> <span class="toc-text">算术移位</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">原码算术移位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D"><span class="toc-number">9.1.3.2.</span> <span class="toc-text">补码算术移位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">9.2.</span> <span class="toc-text">定点数加减法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">9.2.1.</span> <span class="toc-text">补码加减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%BA%A2%E5%87%BA"><span class="toc-number">9.2.2.</span> <span class="toc-text">判断溢出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">9.3.</span> <span class="toc-text">定点数乘除法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="toc-number">9.3.1.</span> <span class="toc-text">原码一位乘法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">9.4.</span> <span class="toc-text">浮点数加减法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.4.1.</span> <span class="toc-text">浮点加减法运算的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A4-0-%E6%93%8D%E4%BD%9C"><span class="toc-number">9.4.2.</span> <span class="toc-text">1. 判 0 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E9%98%B6"><span class="toc-number">9.4.3.</span> <span class="toc-text">2. 对阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%BE%E6%95%B0%E5%8A%A0%E5%87%8F"><span class="toc-number">9.4.4.</span> <span class="toc-text">3. 尾数加减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BB%93%E6%9E%9C%E8%A7%84%E6%A0%BC%E5%8C%96%E5%B9%B6%E5%88%A4%E6%BA%A2%E5%87%BA"><span class="toc-number">9.4.5.</span> <span class="toc-text">4. 结果规格化并判溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%88%8D%E5%85%A5%E5%A4%84%E7%90%86"><span class="toc-number">9.4.6.</span> <span class="toc-text">5. 舍入处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">第十一章 存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">存储子系统概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">存储器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB"><span class="toc-number">10.2.1.</span> <span class="toc-text">按在计算机系统中的作用分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%AD%98%E5%8F%96%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">10.2.2.</span> <span class="toc-text">按照存取方式分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB"><span class="toc-number">10.2.3.</span> <span class="toc-text">按照存储介质分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">10.3.</span> <span class="toc-text">主存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-number">10.3.1.</span> <span class="toc-text">主存的组成结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">10.4.</span> <span class="toc-text">主存的主要技术指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F"><span class="toc-number">10.4.1.</span> <span class="toc-text">存储容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E9%80%9F%E5%BA%A6"><span class="toc-number">10.4.2.</span> <span class="toc-text">存取速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">10.4.3.</span> <span class="toc-text">可靠性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%80%97"><span class="toc-number">10.4.4.</span> <span class="toc-text">功耗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">10.5.</span> <span class="toc-text">随机存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8sram"><span class="toc-number">10.5.1.</span> <span class="toc-text">静态随机存储器SRAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8dram"><span class="toc-number">10.5.2.</span> <span class="toc-text">动态随机存储器DRAM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dram%E7%9A%84%E5%88%B7%E6%96%B0"><span class="toc-number">10.6.</span> <span class="toc-text">DRAM的刷新</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/03/fastapi%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" title="2026-02-03 fastapi模板项目学习"><img src="/images/2026-02-01/85139347_p0-%E7%84%A1%E9%A1%8C.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2026-02-03 fastapi模板项目学习"/></a><div class="content"><a class="title" href="/2026/02/03/fastapi%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" title="2026-02-03 fastapi模板项目学习">2026-02-03 fastapi模板项目学习</a><time datetime="2026-02-08T08:17:43.105Z" title="Updated 2026-02-08 16:17:43">2026-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/02/08/archives-2026-02-08-%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/" title="2026-02-08 方向选择与信息差"><img src="/images/2026-02-06/91882132_p0-glow.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2026-02-08 方向选择与信息差"/></a><div class="content"><a class="title" href="/2026/02/08/archives-2026-02-08-%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/" title="2026-02-08 方向选择与信息差">2026-02-08 方向选择与信息差</a><time datetime="2026-02-08T07:20:55.968Z" title="Updated 2026-02-08 15:20:55">2026-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/02/04/archives-2026-02-04-%E8%BF%B7%E8%8C%AB%E6%97%B6%E5%B0%B1%E5%A4%9A%E7%9C%8B%E7%9C%8B%E5%8D%9A%E5%AE%A2/" title="2026-02-04 迷茫时就多看看博客"><img src="/images/2026-02-06/88252299_p0-%E7%A7%81%E6%9C%8D.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2026-02-04 迷茫时就多看看博客"/></a><div class="content"><a class="title" href="/2026/02/04/archives-2026-02-04-%E8%BF%B7%E8%8C%AB%E6%97%B6%E5%B0%B1%E5%A4%9A%E7%9C%8B%E7%9C%8B%E5%8D%9A%E5%AE%A2/" title="2026-02-04 迷茫时就多看看博客">2026-02-04 迷茫时就多看看博客</a><time datetime="2026-02-08T06:42:08.611Z" title="Updated 2026-02-08 14:42:08">2026-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/19/python-2026-01-19-python%E9%87%8D%E5%AD%A6/" title="2026-01-19 python语法"><img src="/images/archives/2026-01-21/68936009_p0-%E6%97%A5%E5%90%91%E3%81%AE%E5%B9%BD%E9%9C%8A.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2026-01-19 python语法"/></a><div class="content"><a class="title" href="/2026/01/19/python-2026-01-19-python%E9%87%8D%E5%AD%A6/" title="2026-01-19 python语法">2026-01-19 python语法</a><time datetime="2026-02-07T05:15:43.085Z" title="Updated 2026-02-07 13:15:43">2026-02-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/101891205_p0-Epilogue.webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Revival-of-hope</span></div><div class="footer_custom_text">仰天大笑出门去,谁想门槛撞到头</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3-b1"></script><script src="/js/main.js?v=5.5.3-b1"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.25/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'revival-of-hope/hexo-blog-comments',
      'data-repo-id': 'R_kgDORAMULA',
      'data-category-id': 'DIC_kwDORAMULM4C1W_w',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div></div></body></html>